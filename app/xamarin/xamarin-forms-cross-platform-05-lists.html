<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Lists</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>In a lot of applications we have some kind of list. So in this lecture we are going to learn how to
                    present data in beautiful interactive lists. You will learn how to handle selections, how to display
                    context actions, how to implement pull to refresh and how to add a search bar on top of your list.
                </p>
                <h3>Populating a Basic List</h3>
                <p>Let's start with a very simple list. Create a new Content Page called BasicListPage.xaml. In the Xaml
                    add a ListView element:
                </p>
                <figure>
                <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.BasicListPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot;/&gt;
&lt;/ContentPage&gt;</code></pre>
                    <figcaption>Fig 05-001</figcaption>
                </figure>
                <p>To populate this list with data we are going to go in the code-behind and create a list of names then
                    set the ItemsSource of the listView:
                </p>
                <figure>
<pre><code class="csharp">public BasicListPage ()
{
    InitializeComponent ();

    var names = new List&lt;string&gt;
    {
        &quot;Mosh&quot;,
        &quot;John&quot;,
        &quot;Bob&quot;
    };

    listView.ItemsSource = names;
}</code></pre>
                    <figcaption>Fig 05-002</figcaption>
                </figure>
                <p>If we run the app we can see our list populated with three names:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-003.png"/>
                    <figcaption>Fig 05-003</figcaption>
                </figure>
                <p>If you look closely you can see we have a feint border below each item - this is a separator. We can
                    hide this:
                </p>
                <figure>
                    <pre><code class="xml">&lt;ListView x:Name=&quot;listView&quot; SeparatorVisibility=&quot;None&quot; /&gt;</code></pre>
                    <figcaption>Fig 05-003</figcaption>
                </figure>
                <p>or change it's colour:</p>
                <figure>
                    <pre><code class="xml">&lt;ListView x:Name=&quot;listView&quot; SeparatorColor=&quot;Blue&quot; /&gt;</code></pre>
                    <figcaption>Fig 05-004</figcaption>
                </figure>
                <p>This is a pretty basic list but in most real world applications you want to display complex objects.
                    That is the topic of the next lecture.
                </p>
                <h3>Cell Appearance</h3>
                <p>Let's say we want to display a list of contacts. Each contact can have a name, a status and an image.
                </p>
                <p>First create a new Content Page called ContactListPage.xaml and add a ListView element:</p>
                <figure>
                <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.ContactListPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot; SeparatorColor=&quot;Blue&quot; /&gt;
&lt;/ContentPage&gt;</code></pre>
                    <figcaption>Fig 05-005</figcaption>
                </figure>
                <p>Next create a new folder in our shared project called Models - this is where we will store all our
                    domain classes (e.g. Contact class).
                </p>
                <p>Add a new public class to the Models folder called Contact.cs with three properties - Name, Status
                    and ImageUrl:
                </p>
                <figure>
                <pre><code class="csharp">public class Contact
{
    public string Name { get; set; }
    public string Status { get; set; }
    public string ImageUrl { get; set; }
}</code></pre>
                    <figcaption>Fig 05-006</figcaption>
                </figure>
                <p>Let's go to the code-behind for ContactListPage.xaml and initialize the listView:</p>
                <figure>
                <pre><code class="csharp">public ContactListPage ()
{
    InitializeComponent ();

    listView.ItemsSource = new List&lt;Contact&gt;
    {
        new Contact { Name = &quot;Mosh&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/1&quot; },
        new Contact { Name = &quot;John&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/2&quot;, Status=&quot;Hey let's talk!&quot; }
    };
}</code></pre>
                    <figcaption>Fig 05-007</figcaption>
                </figure>
                <p>If we run the application now we see the following:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-008.png"/>
                    <figcaption>Fig 05-008</figcaption>
                </figure>
                <p>Each item appears as UdemyXamarinForms.Models.Contact. This is because by default the ListView calls
                    the ToString() method on each item in the list. The default implementation of the ToString() method
                    returns the fully qualified name of our class. We actually want to render the Name and Status
                    properties for each Contact.
                </p>
                <p>Back in the Xaml edit the ListView to add an ItemTemplate:</p>
                <figure>
                <pre><code class="xml">&lt;ListView x:Name=&quot;listView&quot;&gt;
    &lt;ListView.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
        &lt;/DataTemplate&gt;
    &lt;/ListView.ItemTemplate&gt;
&lt;/ListView&gt;</code></pre>
                    <figcaption>Fig 05-009</figcaption>
                </figure>
                <p>ListView has a property called ItemTemplate. Just like we have ItemsSource we have ItemTemplate -
                    which is the Template for each item. Inside ItemTemplate we add a DataTemplate element. Inside
                    DataTemplate we use the built-in TextCell template. If you want to have more control over the
                    appearance of each item you can create a custom template which is the topic of the next lecture. The
                    two built-in templates that we often use with ListView are TextCell and ImageCell.
                </p>
                <p>
                    TextCell has a Text property which we supply with a Binding Expression. Notice we don't set the
                    Source in this Binding Expression because when we initialize ItemsSource each Contact object will be
                    the Binding Context for each item in the ListView. Remember Binding Context - we covered that in
                    Chapter 02 - Xaml Essentials. I explained that if you have multiple elements that have reference the
                    same object as their Binding Source you can clean up the code by setting the Binding Context on the
                    Container.
                </p>
                <p>In this example each Contact will be the Binding Context for each item in the ListView. So in our
                    Binding Expression we simply use the name of the target property - in this case Name.
                </p>
                <p>TextCell has another property called Detail which we supply with another Binding Expression this time
                    binding to Status
                </p>
                <p>TextCell also has TextColor and DetailColor properties.</p>
                <p></p>
                <p>Let's run the application:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-010.png"/>
                    <figcaption>Fig 05-010</figcaption>
                </figure>
                <p>You can see each item has text and detail (where available).</p>
                <p>Now if you want to add an image here we can use the other built-in template called ImageCell:</p>
                <figure>
                    <pre><code class="xml">&lt;ImageCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; ImageSource=&quot;{Binding ImageUrl}&quot;  /&gt;</code></pre>
                    <figcaption>Fig 05-011</figcaption>
                </figure>
                <p>Let's look at the result:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-012.png"/>
                    <figcaption>Fig 05-012</figcaption>
                </figure>
                <p>Now in the next lecture we are going to look at creating a Custom Cell to have full control over the
                    appearance of each item.
                </p>
                <h3>Custom Cells</h3>
                <p>Alright, let's imagine you want to add a follow button to the right side of each element:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-013.png"/>
                    <figcaption>Fig 05-013</figcaption>
                </figure>
                <p>For this scenario we would need a Custom Template. Create a new Content Page called
                    CustomTemplateContactListPage.xaml and add the following Xaml:
                </p>
                <figure>
                <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.CustomTemplateContactListPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;ViewCell&gt;
                    &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt;
                        &lt;Image Source=&quot;{Binding ImageUrl}&quot;/&gt;
                        &lt;StackLayout&gt;
                            &lt;Label Text=&quot;{Binding Name}&quot; /&gt;
                            &lt;Label Text=&quot;{Binding status}&quot; TextColor=&quot;Gray&quot; /&gt;
                        &lt;/StackLayout&gt;
                        &lt;Button Text=&quot;Follow&quot; /&gt;
                    &lt;/StackLayout&gt;
                &lt;/ViewCell&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</code></pre>
                    <figcaption>Fig 05-014</figcaption>
                </figure>
                <p>Now let's run the application and see what happens:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-015.png"/>
                    <figcaption>Fig 05-015</figcaption>
                </figure>
                <p>It looks pretty messy. Let's try an workout what's going on here. First of all I'm going to apply a
                    BackgroundColor to the outer StackLayout:
                </p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-016.png"/>
                    <figcaption>Fig 05-016</figcaption>
                </figure>
                <p>So for each item we can see that the StackLayout stretches to fill it's container and each item
                    contains plenty of unused space. What we want to do is allocate that unused space to this vertical
                    StackLayout:
                </p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-017.png"/>
                    <figcaption>Fig 05-017</figcaption>
                </figure>
                <p>This will push the Follow buttons to the right side of the screen. To achieve this set the inner
                    StackLayout's HorizontalOptions to StartAndExpand (because I want this StackLayout to be
                    horizontally on the left):
                </p>
                <figure>
                    <pre><code class="xml">&lt;StackLayout HorizontalOptions=&quot;StartAndExpand&quot;&gt;</code></pre>
                    <figcaption>Fig 05-018</figcaption>
                </figure>
                <p>Any option that ends with AndExpand means that any available space should be allocated to this
                    element.
                </p>
                <p>Let's run the application again:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-019.png"/>
                    <figcaption>Fig 05-019</figcaption>
                </figure>
                <p>Ok, that's better! So we can see that any extra space is now allocated to our inner StackLayout.
                    Another thing that will improve the UI is some padding because currently the image and the follow
                    button are very close to the edges of the page.
                </p>
                <p>Remove the BackgroundColor from the outer StackLayout and instead apply Padding of 5 units:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-020.png"/>
                    <figcaption>Fig 05-020</figcaption>
                </figure>
                <p>Ok so we have some padding around the items but we have introduced another issue - the detail for the
                    second item is leaking into the third item. The reason for this is that, by default, all rows in a
                    ListView have the same height. We can easily fix this problem by setting the HasUnevenRows property
                    on the ListView to true:
                </p>
                <figure>
                    <pre><code
                            class="xml">&lt;ListView x:Name=&quot;listView&quot; HasUnevenRows=&quot;True&quot;&gt;</code></pre>
                    <figcaption>Fig 05-021</figcaption>
                </figure>
                <p>With this change the height of each item will be based on it's content. Let's take a look at the
                    result:
                </p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-022.png"/>
                    <figcaption>Fig 05-022</figcaption>
                </figure>
                <h3>Grouping Items</h3>
                <p>Now let's see how to group items in a ListView. For example here I've grouped the contacts based on
                    their first letter:
                </p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-023.png"/>
                    <figcaption>Fig 05-023</figcaption>
                </figure>
                <p>So currently we two groups - M & J. In iOS we also have an index on the right side of the screen:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-024.png"/>
                    <figcaption>Fig 05-024</figcaption>
                </figure>
                <p>This can be handy when going through a list with a lot of items.</p>
                <p>Add a Content Page called GroupingItemsPage.xaml</p>
                <p>Add another class to the Models folders called ContactGroup.cs</p>
                <figure>
                <pre><code class="csharp">public class ContactGroup : List&lt;Contact&gt;
{
    public string Title { get; set; }
    public string ShortTitle { get; set; }

    public ContactGroup(string title, string shortTitle)
    {
        Title = title;
        ShortTitle = shortTitle;
    }
}</code></pre>
                    <figcaption>Fig 05-025</figcaption>
                </figure>
                <p>We derived the class from List of Contact so it's a List by nature. Next I'm going to define a couple
                    of properties - Title and ShortTitle. The ShortTitle will be used to render the index on iOS.
                </p>
                <p>Next we initialize the properties in the Constructor.</p>
                <p>Back in the code-behind for GroupingItemsPage.xaml instead of setting the listView.ItemsSource to a
                    List of Contacts I want to set it to a list of ContactGroups:
                </p>
                <figure>
                <pre><code class="csharp">public GroupingItemsPage ()
{
    InitializeComponent ();

    listView.ItemsSource = new List&lt;ContactGroup&gt;
    {
        new ContactGroup(&quot;M&quot;, &quot;M&quot;)
        {
            new Contact { Name = &quot;Mosh&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/1&quot; },

        },
        new ContactGroup(&quot;J&quot;, &quot;J&quot;)
        {
            new Contact { Name = &quot;John&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/2&quot;, Status=&quot;Hey let's talk!&quot; }
        }
    };
}</code></pre>
                    <figcaption>Fig 05-026</figcaption>
                </figure>
                <p>We initialize the ContactGroup List with two new ContactGroups - one for M and one for J. Now because
                    these ContactGroups are a List of Contacts we initialize them with Contact objects. We don't
                    necessarily have to use single letters for the ContactGroup Titles. For example in another
                    application you might have groups like Friends, Family, Colleagues, Acquaintances etc. However in
                    this app because I am grouping Contacts by the first letter of their name I am using a single letter
                    as the Group Title.
                </p>
                <p>In the Xaml file we need to set a couple properites in our ListView:</p>
                <figure>
                <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.GroupingItemsPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot; HasUnevenRows=&quot;True&quot;
              IsGroupingEnabled=&quot;true&quot;
              GroupDisplayBinding=&quot;{Binding Title}&quot;
              GroupShortNameBinding=&quot;{Binding ShortTitle}&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</code></pre>
                    <figcaption>Fig 05-027</figcaption>
                </figure>
                <p>For the ListView we add a property called IsGroupingEnabled and set it to true. The other property we
                    set is called GroupDisplayBinding which we set to a Binding Expression that binds to the Title
                    property of ContactGroup. The last property - GroupShortNameBinding provides the index functionality
                    we discussed for iOS. We bind this property to ShortTitle of ContactGroup
                </p>
                <p>Let's look at the result:</p>
                <figure>
                    <img src="app/xamarin/images/05/Fig05-028.png"/>
                    <figcaption>Fig 05-028</figcaption>
                </figure>
                <p>Here is our grouped contacts. Next we will discuss working with selections.</p>
                <h3>Handling Selections</h3>
                <p>Now let's see how we can work with Selections. Add another Content Page called
                    HandlingSelectionsPage.xaml and add the following Xaml:</p>
                <figure>
                <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.HandlingSelectionsPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot;
              ItemTapped=&quot;listView_ItemTapped&quot;
              ItemSelected=&quot;listView_ItemSelected&quot;
              IsGroupingEnabled=&quot;True&quot;
              GroupDisplayBinding=&quot;{Binding Title}&quot;
              GroupShortNameBinding=&quot;{Binding ShortTitle}&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</code></pre>
                <figcaption>Fig 05-029</figcaption>
                </figure>
                <p>The Udemy video lecture shows a Xaml file withouth the Grouping attributes but if you miss these
                out you will see an error in the Output window saying that Name and Status were not found.</p>
                <p>We added a couple of events. The first is ItemTapped and we let Visual Studio create the default
                event handler.</p>
                <p>The other event we implement is called ItemSelected and again we let Visual Studio create the default
                event handler for us.</p>
                <p>ItemSelected has an argument called e which gives us information about the SelectedItem. e is of type
                object. Because we have bound our ListView to List of Contacts each item in the list is a Contact object.
                Which means I can get the Selected Item and cast it as a Contact storing the result in a variable called
                contact:</p>
                <figure>
                <pre><code class="csharp">var contact = e.SelectedItem as Contact;</code></pre>
                <figcaption>Fig 05-030</figcaption>
                </figure>
                <p>Next in this method we display an alert with the Name of the selected Contact:</p>
                <figure>
                <pre><code class="csharp">DisplayAlert(&quot;Selected&quot;, contact.Name, &quot;OK&quot;);</code></pre>
                <figcaption>Fig 05-031</figcaption>
                </figure>
                <p>For the Tapped event the e argument has a property called Item which gives us access to the item
                that has been tapped. So first we cast to a Contact and store the result in a variable called contact:</p>
                <figure>
                <pre><code class="csharp">var contact = e.Item as Contact;</code></pre>
                <figcaption>Fig 05-032</figcaption>
                </figure>
                <p>Then we call DisplayAlert with the Name of the tapped Contact:</p>
                <figure>
                <pre><code class="csharp">var contact = e.Item as Contact;</code></pre>
                <figcaption>Fig 05-033</figcaption>
                </figure>
                <p>Now if you run the application and tap a Contact you will get the Tapped alert then when you click
                    ok you will get the Selected alert the first time you tap each Contact.</p>
                <p>Subsequent taps will only fire the Tapped event until you tap on another contact.</p>
                <p>This differs to the behaviour specified in the video which says when we select a Contact we get 
                the Selected event but not the Tapped event and then subsequent taps result in the Tapped event firing.
                </p>
                <p>Which event you want to work with depends on your application but quite often we use the Selected 
                event. A real world example of this is where a user taps an item to select it perhaps we want to 
                navigate them to a second page where we can see more detail about an item.</p>
                <p>If you want to disable Selection in the ItemSelected handler simply set listView.SelectedItem to null:
                </p>
                <figure>
                <pre><code class="csharp">private void listView_ItemSelected(object sender, SelectedItemChangedEventArgs e)
{
    var contact = e.SelectedItem as Contact;
    DisplayAlert(&quot;Selected&quot;, contact.Name, &quot;OK&quot;);
}</code></pre>
                <figcaption>Fig 05-034</figcaption>
                </figure>
                <p>Now you will only see the Tapped event and the item will not be Selected (no grey background).</p>
                <p>If we didn't handle the Tapped event either basically by commenting out the two lines inside the 
                ItemTapped event handler:</p>
                <figure>
                <pre><code class="csharp">private void listView_ItemTapped(object sender, ItemTappedEventArgs e)
{
    //var contact = e.Item as Contact;
    //DisplayAlert(&quot;Tapped&quot;, contact.Name, &quot;OK&quot;);
}</code></pre>
                <figcaption>Fig 05-035</figcaption>
                </figure>
                <p>The list wouldn't respond to the Tap or Selected events at all.</p>
                <p>Next we are going to discuss context actions.</p>
                <h3>Context Actions</h3>
                <p></p>
                <h3>Pull to Refresh</h3>
                <p></p>
                <h3>Search Bar</h3>
                <p></p>
                <h3>Cheat Sheet</h3>
                <p></p>
                <h3>Exercise - Airbnb's Recent Searches</h3>
                <p></p>
            </div>
        </div>
    </div>
</div>