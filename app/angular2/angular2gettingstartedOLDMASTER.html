<!doctype html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
  </head>
  <body>
    <h2>Course Overview</h2>
    <h3>Course Overview</h3>
    <p>Hello, my name is Deborah Kurata and I'd like to welcome you to my course, Angular 2: Getting Started, from Pluralsight. This beginner-level course takes you on a journey through the basic features of Angular 2. It guides you down the right path, making your own journey with Angular 2 more pleasant and productive. Along the way, we build a sample application so you can code along or use it as a reference for your own development.>You'll see how Angular provides a consistent set of patterns for building components, templates, and services, helping you come up to speed quickly. This course covers how to build components,>how to create the user interface for your application in a template, and power it up with data binding and directives.>You'll discover how to build services for logic needed across components, and inject those services where they are needed.>You'll learn how to send requests to a web server using HTTP and observables.>And you'll see how to set up routing to navigate between the views of your application. By the end of this course, you will know the basics you need to get started building an Angular 2 application. I hope you'll join me on this journey through Angular 2: Getting Started from Pluralsight. </p>

    <h2>>Introduction</h2>
    <h3>Introduction</h3>
    <p>Whether you are new to Angular>or new to Angular 2, you want to come up to speed quickly with Angular 2's components, templates and services. Welcome to Angular 2 Getting Started from Pluralsight. My name is Deborah Kurata>and this course provides the basics you need to get started building an Angular 2 application. As we journey through this course, we'll discover Angular's many features and uncover the answers to key questions. For example, what is a component? Where do we put the HTML for our user interface? When should we use data binding? Why do we need a service?>And how, how do we build an Angular 2 application? The who of course is you.>This course guides you down the right path>making your own journey with Angular 2 more pleasant and productive. As we start this journey,>let's get the lay of the land and take a high level look at Angular. Simply stated, Angular is a JavaScript framework for building client-side applications using HTML, CSS and a programming language>such as JavaScript.>Why Angular and not some other JavaScript framework? And there are lots of JavaScript frameworks out there. Angular makes our HTML more expressive. It powers up our HTML with features such as if conditions, for loops and local variables.>Angular has powerful data binding. We can easily display fields from our data model, track changes and process updates from the user. Angular promotes modularity by design. Our applications become a set of building blocks making it easier to create and reuse content and Angular has built-in support for communication with a back-end service.>This makes it easy for our web applications>to integrate with a back-end service>to get in post data or execute server side business logic. No wonder Angular is so very popular>with millions of web developers. With so any developers already using Angular 1, why do we need an Angular 2?>Angular 2 is built for speed. It has faster initial loads, faster change detection and improved rendering times. Angular 2 is modern.>It takes advantage of features>provided in the latest JavaScript standards and beyond such as classes, modules and decorators yet it supports both green field and legacy browsers, Edge, Chrome, Firefox and Internet Explorer. Angular 2 has a simplified API. It has fewer built-in directives to learn, simpler binding and a lower overall concept count and Angular 2 enhances our productivity to improve our day to day workflow. You'll see these productivity improvements>as we go through this course>and we'll discern a consistency of patterns>for building the blocks that form an Angular application. In this first module,>we lay out the anatomy of an Angular 2 application. We consider several suggestions for getting the most from this course. We explore the sample application that we'll build throughout this course and we'll look at the topics we'll cover in the remainder of this course. Okay then, let's check out the anatomy of an Angular 2 application.</p>

    <h3>Anatomy of an Angular 2 Application</h3>
    <p>In Angular 2, an application is comprised of a set of components>and some services that provide functionality across those components.>So the next obvious question is what is an Angular 2 component? Each component is comprised of a template which is the HTML for the user interface fragment to finding a view for the application. Add to that a class for the code associated with the view. The class contains the properties or data elements available for use in the view and methods which perform actions for the view such as responding to a button click. A component also has metadata which provides additional information about the component to Angular. It is this metadata that identifies the class as an Angular component.>So a component is a view defined with a template, its associated code defined with a class and additional information defined with metadata. We'll look at this in more detail in the upcoming modules. As we build these components, how do we pull them together into an application? We define Angular modules.>Angular modules help us organize our application into cohesive blocks of functionality. Every Angular application has at least one Angular module called the Application's root Angular module. An application can have any number of additional Angular modules>including feature modules that consolidate the components for a specific application feature. We'll see much more about Angular modules along our journey. For now, let's look at some tips for getting the most from this course. </p>

    <h3>Get the Most from This Course</h3>
    <p>First are the prerequisites.>This is a beginner level course but this course assumes you have some basic knowledge of JavaScript for code, HTML for building the user interface and Cascading Style Sheets or CSS for styling. You don't have to have much experience but a working knowledge of each will help you get the most from this course. Though not required, it is helpful if you have had some exposure to Object-oriented programming concepts maybe through coding with C++, C#, Java or PHP but if you don't have any exposure to OOP, that's okay. You do not need any prior knowledge of Angular, Angular 2 or TypeScript.>We'll cover what you need in this course. Another way to get the most from this course is to join the discussion.>Thoughts, comments or questions as you watch this course? Feel free to use the Discussion tab.>You can find the link to the Discussion on the Pluralsight page for this course or follow me on Twitter.>It would be great to hear about your experiences with Angular 2.>There is also a blog post specifically for this course at the URL shown here.>This posts lists common issues along with their solutions. If you are having problems with the code for the course, check here first.>There may already be a solution posted. Keep this URL handy as you work through the course. When building web applications>regardless of the technologies we use, there are often lots of steps and places where things can do wrong. That's where a good checklist can come in.>I'll present checklists at the end of each module and we'll use them as a brief review>of what was covered in that module. Feel free to jump ahead to the checklist if you have any problems>when coding along with the demos in the module and consider referencing these checklists as you start building your own Angular 2 applications. Coding along on this journey is another great way to get the most from this course. Though not required, it is often helpful to try out the presented code as you navigate through the course. To get you started, I've set up a public GitHub repository specifically for this course. It is called Angular 2 Getting Started and you can find it at this URL. The starter files for the sample application are here. You can use these files as a starting point>if you want to code along with the demos. If you'd prefer to follow along with the completed code, you can find that here.>If you're new to GitHub, simply click this button to download all of this code as a zip file.>So what is this sample application? Let's take a look.</p>

    <h3>Sample Application</h3>
    <p>To demonstrate the basic features of Angular 2, we'll build a simple application step by step as we journey through this course. Let's see the finished sample application in action. Welcome to Acme Product Management. As its name implies, this application manages our current list of products. Here at the top is our menu>for access to the key features of the application. In a full featured application, there would of course be more options here>but we want to limit this sample application to the features we can build within this course. Clicking on the Product List option displays the Product List page. We see the page title>and a table containing the list of products. If the user clicks the Show Image button, the product images appear>and the button changes to Hide Image. Click the button again to hide the images and compress the display.>Notice the nice formatting of our price and instead of a number for the rating, we display the rating in stars. Here at the top is an input box where the user can enter a filter string. When the input box contains a value,>a Filtered by message appears and the product list is filtered to only those with a product name that contained the entered string. Click on a product name to navigate to the product details. On the Product Detail page, we see the page title with the name of the product and all of the product details including a product description, the nicely formatted price and the star rating. Click the Back button to navigate back to the Product List page.>So not a huge app but big enough to demonstrate the basics of Angular 2.>As with any Angular 2 application, this application is comprised of a set of components including a nested component for the rating stars. It has a service to get the data and it incorporates routing to navigate between the pages. Now that we've seen the sample application,>how do we build it?>As stated earlier, an Angular 2 application>is comprised of a set of components and services that provide data and logic across those components.>With that in mind, let's break the sample application into components and services. For the Welcome page, we'll build a Welcome component. For the Product List page,>we'll build a Product List component. Recall that we had a nice visual display of stars for our ratings.>We want to reuse that feature so we'll build a separate nestable Star component. Clicking on a product in the Product List page displayed the product detail. We'll build a component for that as well and reuse the Star component>then we need an App component that ties our application pieces together and our application gets data so we'll want a product data service. Lastly, we need the obligatory index.html file. We'll build the basics of each of these pieces and learn how to organize them into Angular modules as we journey through this course. </p>

    <h3>Course Outline</h3>
    <p>We start with first things first. We'll select a language and editor to use then walk through how to setup an Angular 2 application. Next, we'll dive into components. We'll build the App component using a simple template and minimal component code and metadata. We'll see how to build the user interface for our application using templates,>interpolation and directives. We'll power up that user interface with data binding and nicely format our data with pipes. Next, we'll tackle some additional component techniques. We'll define interfaces, encapsulate styles>and leverage life cycle hooks to build better components. We'll see how to build a component designed to be nested within other components and how to communicate between the nested component and its container.>We often have logic or data>that is needed across components. We'll learn how to build services specifically for this purpose and use dependency injection to inject those services into the components that need them. Most web applications need to communicate with a back-end server to get our post data>and to execute back-end business logic. In this module, we'll leverage Http to retrieve the data for our application. Our sample application displays multiple views. We'll see how to set up routing to navigate between those views. Next is Angular modules.>We learn about and use the root Angular module throughout this course>but as the application grows, we want to separate its concerns. This course module reviews the basics of Angular modules and refactors our application into logical blocks using multiple Angular modules. We're covering a lot of territory and by the end of our journey,>we'll have a simple but fully operational Angular 2 application.>You can use that application as a reference>for your own development.>Let's start our journey through Angular 2. </p>

    <h2>First Things First</h2>
    <h3>Introduction</h3>
    <p>First things first.>Before we can start coding with Angular 2,>there are some preparatory steps. Welcome back to Angular 2, Getting Started from Pluralsight. My name is Deborah Kurata,>and in this module, we set up what we need>to work with Angular 2.>A little preparation goes a long way>towards a successful adventure. Before we take that first step on our journey with Angular 2, we need to make some decisions, gather our tools, and get everything ready.>In this module, we evaluate several languages we could use to build an Angular 2 application, and select one.>Once we've picked a language, we select an editor that fully supports development in that language. Then, we set up the boilerplate code>for an Angular 2 application. Then, we talk about modules>and what they mean in Angular 2. Let's get started.</p>

    <h3>Selecting a Language</h3>
    <p>When building Angular 2 applications, we have many language choices available to us. First, some background.>The JavaScript language specification standard is officially called ECMAScript, or ES. Up until recently, the ES versions were defined by a sequential number.>ES 3 is supported by older browsers.>ES 5 is the version currently supported by most modern browsers.>The ES 6 specification was recently approved and renamed ES 2015.>Most browsers don't yet support ES 2015. So, ES 2015 code must first be transpiled to ES 5. What does that mean?>Code developed with ES 2015 must be compiled by a tool that converts the ES 2015 syntax>to comparable ES 5 syntax,>before the browser executes it. That way, we as developers get the benefits>of the new ES 2015 productivity features, and the browsers still get code they understand. Since Angular is a JavaScript library, we could use any of the many compiled of JaveScript languages to build our Angular 2 application. But, the most common language choices for Angular 2 include, the ES 5 version of JavaScript. ES 5 code runs in the browser today without transpilation, so no compile step is required. If we wanted to take advantage of some of the new ES 2015 features to improve our productivity, such as classes, the let statement, and arrow syntax, we can write our Angular 2 code using ES 2015. We then transpile our code to ES 5 before running it. Another language option is TypeScript. TypeScript is a superset of JavaScript, and must be transpiled.>One of the key benefits of TypeScript is its strong typing, meaning that everything has a data type.>Because of this strong typing, TypeScript has great tooling, including inline documentation, syntax checking, code navigation, and advanced refactorings.>So, TypeScript helps us better reason about our code. The Angular team itself takes advantage of these benefits and uses TypeScript to build Angular 2. Most of the demo code in the Angular documentation at present also uses TypeScript. For these reasons, TypeScript is the language of choice for many Angular 2 developers, and is the language we use in this course.>Dart is another option.>It is a non-JavaScript-based language for building Angular 2 applications.>Because we'll use TypeScript throughout this course, let's take a moment to look at what TypeScript is all about. TypeScript is an open source language that is a superset of JavaScript and compiles to plain JavaScript through transpilation. It is strongly typed, so every variable, every function, and every function parameter can have a data type.>How does TypeScript determine the appropriate types when using JavaScript libraries that are not strongly typed? By using TypeScript type definition files.>These files contain the definition of each type in a library.>These files are named with the library name .d.ts. TypeScript implements the ES 2015 class-based object-orientation, plus more.>It implements classes, interfaces, and inheritance. So if you have experience with object-oriented programming language, such as C#, C++, or Java, using TypeScript may feel very natural to you. This course does not require any prior knowledge of TypeScript.>I'll cover what you need as you need it. But if you want to learn more about TypeScript, check out the TypeScript Playground.>This website allows you to do live coding with TypeScript, see the transpiled JavaScript, and run the result, all without installing anything. There are also several TypeScript courses in the Pluralsight Library, including TypeScript Fundamentals,>Angular with TypeScript,>which walks through using TypeScript with Angular 1, and Using ES6 with TypeScript,>which details all of the new ES 2015 features, such as let and arrow syntax. Again, you do not have to know TypeScript for this course. We'll learn it as we go.>Now that we've selected TypeScript as our Angular 2 language, let's pick an appropriate code editor. </p>

    <h3>Selecting an Editor</h3>
    <p>There are many editors that fully support TypeScript, either out of the box or with a plugin, including all of these.>Select one of these, or whichever editor suits you best, but keep in mind, that your experience with TypeScript will be much more pleasurable if you select>an editor that understands TypeScript. For this course, I am using Visual Studio Code. Visual Studio Code runs on Linux, Windows, and OS X. It has great features that support TypeScript, such as Auto Completion and Telesense syntax checking and refactoring. If you wanted to use VS Code as your editor, you can download and install it from this URL. If you are interested in using Visual Studio Code and want to learn more, check out their website or this Pluralsight course.>But, you are free to use whichever editor you choose. Now that we've picked a language and selected and installed an editor, let's set up our environment.
    </p>
    <h3>Setting up Our Environment</h3>
    <p>Setting up our development environment for Angular requires two basic steps,>install npm or Node Package Manager,>and set up the Angular 2 application. There's no need to manually install Angular>or TypeScript or any other library. However, this step two is really quite a process. But, first thing's first, what is npm? Npm, or Node Package Manager, is a command line utility that interacts with the repository of open source projects. Npm has become the Package Manager for JavaScript. Using npm, we can install libraries,>packages, and applications, along with their dependencies. We'll need npm to install all of the libraries for Angular, and to execute scripts to transpile our code and launch our Angular 2 application. If you don't already have npm,>you can download it from this link. Let's take a look.>Here is the npm website.>To install npm, scroll down to Getting Started. You click here.>That takes us to the Download page for Node. Angular suggests npm version three or better, so click Current to get the latest features. Then, select the installer appropriate for your OS and Install Node, which installs npm. Feel free to pause the video and install npm now if you don't already have it. Okay, with npm installed, we are ready to set up our Angular 2 application.
    </p>
    <h3>Setting up an Angular 2 Application</h3>
    <p>Setting up an Angular 2 application can be somewhat laborious. Before we begin, let's list the required steps. Then, we'll look at ways we can set up Angular without actually performing all of these steps.>But to manually set up an Angular 2 application, we'd need to create an application folder add package definition and configuration files, install the packages, create the application's Root Angular Module, because every application needs at least one Angular Module, then create the main.ts file to load that Angular Module, and create the host web page, normally index.html. Luckily, we have some options.>We can manually perform each of these steps. The detailed instructions for each step are provided in the Angular documentation at Angular IO.>Or, we can simply download the result of these quick start steps from Github. Alternatively, we could use tooling,>such as AngularCli.>AngularCli is a command line tool for generating the setup files and boilerplate code for an Angular 2 application, including scaffolding the unit and end-to-end tests.>The AngularCli can be found here. We'll look more at the Cli when we visit Setup later in this course.>To keep the grunt work for our sample application to a minimum, I've prepared another option, starter files. I've created the initial files we need for our Angular 2 application.>These files are available in my Github repository. In addition to the basic setup files>for an Angular 2 application, the starter files include extra files we need as we build our sample application.>So, let's go with this option.>I've navigated to my Github repository following the URL from the slide. If you are comfortable with Git, you can clone this repository.>Otherwise, click this button to download all of the files as a single ZIP file. The APM-Final folder contains the completed>code for our sample application. Use these files if you want to see the end result. The AMP-Start folder contains the starter files. These are the files we will use as the starting point for building our Angular 2 application. After downloading the files, copy or extract the files in the APM-Start folder to>a working directory called just APM.>Your APM folder should then look like this.>Now, let's open the APM folder with a code editor. I've opened the APM working folder in my selected editor, VS Code. First, let's talk about the directory structure. By convention, all of the files specific for our application are under a folder called app. We only have a few folders and files here now, but we'll add more as we progress through this course. For applications for any size, we'll have subfolders under the app folder for each major feature>in the application.>These are the setup files.>To get us going quickly,>we won't dive into these files now. We'll learn what these files, what they contain, and what they do in the Angular 2 Setup Revisited Module later in this course. So, the last thing we need to do is install>all of the libraries required to develop and run our application.>Open a Command Prompt or terminal. Be sure it is set to the root folder for the application, which should be the working directory we named APM. Type npm install.>This installs all of the libraries we need,>including the libraries to run the application, such as Angular, and for development, such as TypeScript. Note that you may see warnings and errors during this installation process, like these. In most cases, you can ignore them. If you see something like this tree structure at the end, the install completed successfully. Note that you may see different version numbers than what I have here.>If it ended with an error,>try running npm install a second time. That often completes the installation. Going back to the editor,>notice that we now have a node_modules folder here. This is where npm installed all of our libraries, and we have a typings folder where it installed the TypeScript definition file we needed. We talk more about TypeScript definition files in the Angular 2 Setup Revisited Module. Now that we have everything installed, let's try running the sample application.
    </p>
    <h3>Running an Angular 2 Application</h3>
    <p>To get us started, I've included enough additional code with a set of files to run the sample application.>So, let's give it a try.>Back at the command prompt, or terminal, type npm start.>The start script starts a file server to launch our application called lite-server, an it runs the TypeScript Compiler called tsc in Watch Mode. The TypeScript Compiler and the file server>watch for any code changes.>So anytime we save a change to any of our files, TypeScript recomplies them and the file server refreshes the browser automatically so we can immediately see our changes. We'll try that out in a moment. If all is well, the application appears in the browser and displays some text, as shown here. If you get errors, ensure that you ran npm install as defined in the prior clip. As you can see, our application doesn't look like much, but we'll fix that on our journey through Angular 2. Looking back at our code, notice that we now have a .js file and a .map, or a MAP file,>for each of our .ts files.>The start script started the TypeScript Compiler, which transpiled all of our TypeScript files, or our .ts files, to ES 5 JavaScript>that the browser can understand. The MAP file is a source map that is generated by the compiler to debug TypeScript code. I've moved the videos around so that we could see the editor, the browser, and the command prompt, or terminal window.>Let's see what happens when we make a code change. Any editor will open the index.html file. We'll scroll down to the bottom, and we'll make a change.>We immediately see here that our watchers saw the file change, our code is recompiled, the browser refreshes, and we see our updated text. So anytime we make a change to our application, we'll be able to immediately see the effect of the change. You may have noticed that I actually didn't save the change. When using VS Code, we can set it to automatically save our changes. Here under File, Preferences, Workspace Settings, I have a setting in place to automatically>save after a short delay.>When we are finished working with the browser, we can close it, but the Compiler and file server keep running. To stop them, press Control C, and Y, then you can exit.>Use npm start anytime you want to run the application and keep it running to watch the effect of your code changes. Before we go any further, let's take a moment and talk about modules.</p>

    <h3>About Modules</h3>
    <p>With JavaScript, there is always the problem of namespaces.>If we are not careful, we can easily end up with variables or functions in the global namespace. In addition, JavaScript didn't provide features to help with code organization. Modules help resolve these issues. Angular 1 has modules to help us organize our code and resolve some namespacing issues. TypeScript also has modules that help keep things out of the global namespace. ES 2015 set a standard for defining a module. In ES 2015, a module is a file, and a file is a module.>So when coding in ES 2015, we don't need to define or name modules.>Just create a file, write some code,>export or import something, and bang, the file becomes a module.>Angular 2, leverages ES 2015 modules. So as we could code files and import or export something, we create the modules for our application.>But wait, there's more.>Angular 2 also has Angular Modules. Angular Modules are separate and different>from Angular's implementation of ES 2015 Modules. Let's look at how Angular 2 makes use of ES 2015 Modules.>Then, we'll introduce Angular Modules. How do ES 2015 Modules work?>Say we create a code file called product.ts, and export a class named Product from that file. This file then becomes a module. Because the class is exported,>we can use that class in any>other module by importing it. So here, we have a file called product-list.ts, and we import our Product class. This file also becomes a module because we imported something.>Notice the syntax here.>In curly braces, we find the name we want to import, in this case, Product, and we define the file we want to import it from. Here, we want to import from product.js. Wait, what?>The Product class is in product.ts. But when we compile, the TypeScript file is transpiled into an ES 5 JavaScript file.>So at runtime, we are importing from the .js file. But, notice that we don't list the extension here anyway. We'll see why in a moment.>Now, let's look at Angular Modules. Angular Modules help organizing an application into cohesive blocks of functionality. Every Angular application has at least one Angular Module, by convention called At Module. As an application gets more features, we can group those features into their own feature modules.>We can even define shared or common modules>for code used by multiple Angular Modules.>This keeps the code organized and provides>a cohesive unit we can unit we can load on start, or lazy load as needed.>In each Angular Module, we declare the set>of components and other code files associated with the module, and the dependencies needed by those components.>Each component we create is declared in and belongs to one, and only one, Angular Module. We'll talk much more about Angular Modules>throughout this course.>Let's clarify the difference between ES 2015 Modules and Angular Modules.>ES Modules are code files that import or export something. Angular Modules are code files that organize the application into cohesive blocks of functionality. ES Modules organize our code files. Angular Modules organize our application. ES Modules modularize our code. Angular Modules modularize our application.>ES Modules promote code reuse.>Angular Modules promote boundaries within our application.>So, ES Modules are about code files,>and Angular Modules are about our application. To keep these terms straight, I'll refer to the ES 2015 as ES Modules and Angular Modules as Angular Modules. With that, we are ready to look at how we load our ES Modules and host our application.
    </p>

    <h3>Loading ES Modules and Hosting Our Application</h3>
    <p>When a user accesses our web application, the first file that is downloaded to them is the index.html file.>It is in this file that we define our link and script tags, set up our Module Loader, host our application, and display our first view. We can think of it as the entry point for our application.>Let's look at it.>In the index.html file, we have link tags to define our stylesheets, and script tags>to load up the libraries we need. I cover what these files are>in the Angular 2 Setup Revisited Module later in this course.>The next part of the index.html file, configure system .js for loading library, third-party, or our own modules. In other words, it loads all of our code files for us, so we don't need to add script tags for each file we add to the application.>Here, we pull in the script file that configures systemjs for our application. This line of code starts our application by loading the ES 2015 Module that's in the path app.>Recall from the prior clip that an ES 2015 Module is just a code file that imports or exports something. How does systemjs know which file in the app path to load?>It's defined in the systemjs.config file. Here at the bottom, we find app, and see that the main entry point is main.js. So, systemjs loads and runs the module named main that is located in the app folder. We'll look at that main module>in the next course module.>And we see that the default extension for all modules loaded from the app folder is .js. This is why we don't have to specify>the extension when importing modules. We'll talk more about this configuration file in the Angular 2 Setup Revisited Module of this course. Going back to the index.html file, here is the body of our HTML page. It is here that we host our Angular 2 application. We'll cover hosting in the next course module. With that, we have everything we need in place to build our first Angular 2 application. Since we won't be referring to Angular 1 again, from this point forward, I'll often refer to Angular 2 just as Angular.</p>

    <h3>Summary</h3>
    <p>In this module, we discussed several languages
      and selected TypeScript.>TypeScript has all of the productivity
      features of ES 2015, plus strong typing for better tooling.
      We then selected an editor.>Which editor you use for TypeScript
      is a personal preference.>For the best experience, be sure your selected
      editor fully supports TypeScript.
      We then installed npm and looked
      at the laborious process required
      to manually set up the boilerplate code
      for an Angular 2 application.
      Instead of manually setting this up,>we downloaded the starter files
      from my Github repository.>We then saw how to install, run,
      and edit the sample application.
      We covered ES Modules and how TypeScript
      uses ES Module syntax to export and import>functionality from our ES Modules.
      We introduced Angular Modules and how they>organize our application and promote application boundaries.
      And, we saw how to configure the ES Module Loader.
      Recall the architecture for the sample
      application we are building that we
      outlined in the first module?
      So far, we only have the index.html file defined.
      In the next module, we'll start writing some
      Angular 2 code and build the app component shown here.
    </p>

    <h2>Introduction to Components</h2>
    <h3>Introduction</h3>
    <p>In the last module we set up the infrastructure
      for our Angular application.>Now we are ready to build our first component.
      Welcome back to Angular 2: Getting Started>from Pluralsight.>My name is Deborah Kurata and in this module
      we walk through building a very basic component
      with a focus on clearly defining the component's parts,
      their meaning and their purpose.
      We can think of our Angular application
      as a set of components.>We create each component then arrange them>to form our application.>If all goes well,
      those
      components work together in harmony
      to provide the user with a great experience.
      In this module we take a closer look>at what an Angular component is
      and examine the code we need to build one.>We walk through how to create the component's class
      and how and why we need to define metadata.>We look at how to import what we need from external modules,
      and we discover how to bootstrap the component we've built
      to bring our application to life.
      At this point we'll have>the world's simplest working Angular application.
      We'll continue to add to this application
      throughout this course.>Looking again at the application architecture
      that we defined in the first module,>we currently have the index.html file in place.
      In this module we'll build the app component.
      Let's get started.</p>
    <h3>What Is a Component?</h3>
    <p>An Angular component includes a template
      which lays out the user interface fragment>to finding a view for the application.
      It is created with HTML>and defines what is rendered on the page.
      We use Angular binding and directives in the HTML
      to power up the view.>We'll cover binding and directives in a later module.
      Add to that a class for the code associated with the view.
      The class is created with TypeScript.
      The class contains the properties
      or data elements available for use in the view.
      For example, if we want to display a title in the view,
      we define a class property for that title.>The class also contains methods
      which are the functions for the logic needed by the view.
      For example, if we want to show and hide an image,
      we'd write the logic in a class method.
      A component also has metadata
      which provides additional information
      about the component to Angular.
      It is this metadata that defines this class>as an Angular component.>The metadata is defined with a decorator.
      A decorator is a function that adds metadata to a class,
      its members or its method arguments.>So a component is a view defined in a template.
      Its associated code defined with a class
      and metadata defined with a decorator.
      Want to see what a component looks like in TypeScript?
      Here is a simple component.>It might look complex at first,
      so let's break this component into chunks
      starting at the bottom.>Here is our class.>It defines the properties and methods needed by our view.
      Here is the component decorator that defines the metadata.
      The metadata includes the template that lays out the view
      managed by this component.>And here we import the members that we need.
      Let's examine each of these chunks in more detail,
      starting at the bottom with a class.
    </p>
    <h3>Creating the Component Class</h3>
    <p>If you have done any object-oriented programming
      in languages such as C#, VB.NET, Java, or C++,
      this code should look familiar.
      A class is a construct that allows us to create a type
      with properties that define the data elements
      and methods that provide functionality.
      We define a class using the class keyword
      followed by the class name.>A common Angular convention is>to name each component class with a feature name,
      then append the word component as the suffix.
      Also, by convention, the root component for an application
      is called AppComponent as shown here.
      This class name is used as the component name
      when the component is referenced in code.
      The expert keyword here at the front exports this class,
      thereby making it available for use
      by other components of the application.
      And as we learned in the last course module,
      since this file exports something,
      this file is now an ES module,>and will be loaded by our module loader.
      No need to add a script tag for it.
      Within the body of the class are the properties and methods.
      In this example we only have one property and no methods.
      A property defines a data element associated with a class.
      We start with the property name, which by convention,
      is a noun describing the data element
      and it is in camelCase, whereby the first letter
      of the name is lowercase.>In this example, it is the title of the page.
      Using TypeScript's strong typing,
      we follow the property name with a colon and its data type.
      In this example, the page title property is a string.
      We can optionally assign a default value to the property
      as shown in this example.>Methods are normally defined within the class body
      after all of the properties.>Method names are often verbs>that describe the action the method performs.
      Method names are also in camelCase
      whereby the first letter of the name is lowercase.
      So that's it for the class.>But a class alone is not enough to define a component.
      We need to define the template>associated with this component class.
      How do we provide this extra information to Angular?
      With metadata.>Let's look at that next.</p>
    <h3>Defining the Metadata with a Decorator</h3>
    <p>A class becomes an Angular component>when we give it component metadata.
      Angular needs that metadata to understand
      how to instantiate the component, construct the view,
      and interact with the component.
      We define a component's metadata
      with the Angular component function.>In TypeScript we attach that function
      to the class as a decorator.>A decorator is a function that adds metadata to a class,
      its members or its method arguments.>A decorator is a JavaScript language feature
      that is implemented in TypeScript and proposed for ES2016.
      The scope of the decorator is limited
      to the feature that it decorates.
      A decorator is always prefixed with an at sign.
      Angular has several built-in decorators we use
      to provide additional information to Angular.
      We can also build our own decorators,
      but that is out of the scope of this course.
      We apply a decorator by positioning it immediately
      in front of the feature we are decorating.>When decorating a class as in this example,>we define the decorator
      immediately
      above the class signature.>Notice that there is no semicolon here.
      This syntax is similar to attributes used
      in other programming languages.
      We use the at component decorator
      to identify the class as a component.
      Since the decorator is a function,
      we always add parentheses.>We pass an object to the component function as indicated
      with the curly braces.>The object we pass in has many properties,>we are only using two of them here.
      If we plan to reference the component in any HTML,
      we specify a selector.>The selector defines the component's directive name.
      A directive is simply a custom HTML tag.
      Whenever this directive is used in the HTML,
      Angular renders this component's template.>We'll see how this works in the upcoming demo.
      A component should always have a template.>Here we define the layout for the user interface fragment
      or view managed by this component.
      The double curly braces indicate data binding.
      We bind the H1 element value to the page title property
      of the class so when this HTML is rendered,>the H1 element displays Acme Product Management.
      We'll see that in the upcoming demo as well,
      and we'll cover more about binding in a later module.
      There is one more key task before our component is complete.
      Importing.</p>
    <h3>Importing What We Need</h3>
    <p>Before we can use an external function or class,
      we need to tell the module loader where to find it.
      We do that with an import statement.>The import statement is part or ES2015
      and implemented in TypeScript.>It is conceptually similar to the import statement in Java
      or the C# using statement.>The import statement allows us to use exported members
      from external modules.>Remember how we just exported our class
      using the export keyword?>That means that other modules in our application
      can import our exported class if needed.
      We'll use the import statement throughout our code
      to import any third-party library,
      any of our own modules, or from Angular itself.
      We can import from Angular, because Angular is modular.
      It is a collection of library modules.
      Each library is itself a module made up
      of several related feature modules.
      When we need something from Angular,>we import it from an Angular library module,
      just like we import from any other external module.
      Use this link if you want to view the list>of available Angular 2 library packages
      and their current versions.>In our component code,>we use the component decorator function from Angular
      to define our class as a component.
      We need to tell the module loader
      where to find this function,>so we add an import statement,>an import component from Angular core like this.
      We start with the import keyword.
      We identify the name of the member we need>within curly braces.>In this case we need the component decorator
      function,
      and we define the path to the module containing that member.
      In this case the Angular core library module.
      If we need multiple members from the same module,
      we can list them all in the imports list
      separated by commas.>We'll see examples of that later in this course.
      So this is a component.>Now we're ready to build the first component
      for our sample application.>Let's jump in.</p>
    <h3>Demo: Creating the App Component</h3>
    <p>In this demo we build our app component
      which is the root of our application.
      Here we are in the editor with the APM folder open.
      This is the folder we set up in the last module
      from the starter files I provided.
      Let's open the app folder.>I provided the app component as part of the starter file,
      so that we could run the application right away.
      I named the file app.compenent.ts.
      The file naming convention that we'll follow
      throughout this course is to start with the feature name.
      This is our root application component,
      so by convention, it is called app.
      Then a dot, then the type of ES module defined in this file,
      in this case, component,>to identify this ES module as a component,>another dot and the extension.>Since we are
      using
      TypeScript,>we'll use ts as the extension.>In VS code, I can click the Explorer icon
      to close the Explorer and see more of the code.
      I can reopen the Explorer by clicking the icon again.
      Now I'll delete this starter code for this file
      so we can build the app component from scratch.
      I like to start coding by building the class,
      but the order of these steps really don't matter.
      When we build the class, we first type in the export keyword
      to ensure that other parts>of the application can use this class.
      Next we type in the class keyword,
      then the name of the class.>Since this is our application component class,
      we'll follow conventions and name it AppComponent.
      Inside this class we'll define one property, the page title.
      We type the property name followed by a colon
      and the property data type,>which for the pageTitle is a string.>Notice how IntelliSense helps us here.
      For this property we want to define
      a default value for the pageTitle.
      Next we define the component decorator above the class.
      The component decorator always begins with an at sign
      then the name of the decorator.
      And we're using the component decorator.
      The component decorator is a function,
      so we type parentheses.>And we're going to pass in an object,
      so we type in curly braces.>Notice how TypeScript has underlined the component decorator
      and flagged it as an error.>The error is Can't Find Name Component.
      Any guesses on what the problem is?
      If you said that we are missing the import statement,
      you are right.>We need to import the component decorator from Angular core.
      Now the error underline goes away
      and we can complete the metadata.
      In the component metadata we specify a selector
      for the name of this component>when used as a directive in the HTML.
      Now that we've imported the appropriate module,
      we get IntelliSense for these properties.
      We set the selector to pm-app,>the current convention is to prefix each selector
      with something to identify it as part of our application.
      So we selected pm for product management.
      The second part of the name represents the component,
      so we used app, since this is our app component.
      Next we define the template.>To specify another property here, we enter a comma,
      and then the name of the other property.
      We want to define template,>any valid HTML can be specified in the template.
      We'll dive deeper into templates in a later module.
      So for this example, I'll just paste in the HTML,
      and we're done.>We have now created the first component for our application.
      Yay!>But how do we use it?>How do we display its template?</p>

    <h3>Bootstrapping Our App Component</h3>
    <p>Have you heard the saying, "Pulling yourself up by your bootstraps?"
      Originally meaning to improve your situation
      by your own efforts.>In tech it has come to mean a self-starting process
      that loads and goes.>We need to tell Angular to load our root component
      through a process that's called bootstrapping.
      And we need to setup the index.html file
      to host our application.>Let's look at both of these steps.
      Most Angular applications have an index.html file
      that contains the main page for the application.
      This index.html file is often the one true web page
      of the application, hence an application is often called
      a single-page application or SPA.
      But don't worry, it will look to the user
      like we have lots of pages as we saw in the demo
      at the beginning of this course.
      What we do is insert bits of HTML
      into the one HTML page to find index.html.>Let's see how that works.>Here again is our app.component just shifted
      to
      the right.
      Recall that the selector is the name of the component
      when we use it as a directive in HTML,
      and the template defines the HTML that we want to display.
      So in the index.html file, we simply add the selector
      where we want our template displayed.
      Here in the template we call this a directive.
      A directive is basically a custom element.>When the root element is loaded,
      the loading app message appears.
      As soon as the loading is complete,
      the HTML defined in the component template is inserted
      between the selector element tags and appears on the page.
      Let's go through the Angular application
      startup process in detail.>I've already set this process up for our sample application,
      but it's useful to know how it works>as you start to build your own applications.
      We have the index.html file setup to host the application
      by specifying the selector>from the root application component
      as a directive in the body tag.
      But how does the module loader find
      our root application component?
      Recall from the last course module
      that we configured systemjs, our module loader,
      in index.html to start up the application
      by importing an ES module from the app folder
      and we saw that the systemjs configuration file
      defined the main entry point of the application as main.
      So main is the first ES module loaded for our application.
      And it looks like this.>The main ts file bootstraps our first Angular module,
      providing a starting point to kick off our application.
      For this sample application, we want the Angular compile
      to compile the application in the browser dynamically
      and then launch the application.
      So we begin by importing platformBrowserDynamic.
      Other bootstrapping options are covered
      in the Angular 2 Setup Revisited module
      later in this course.>Here we specify where the module loader
      can find our Angular application module
      by adding an import statement to import AppModule.
      Then we call a function that bootstraps
      our first Angular module.>Once we've bootstrapped our Angular application,
      we can leave the main.ts file and never look upon it again.
      Here is our application's Angular module.
      We talked about Angular modules in the last course module.
      Angular modules help us organize our application
      into cohesive blocks of functionality
      and provide boundaries within our application.
      We define an Angular module with a class.
      We identify the class as an Angular module>by attaching the NgModule decorator
      and passing in metadata defining the details
      of this Angular module and importing what we need.
      In the declarations array, we define which>of our components belong to this module.
      By convention our main application component,
      AppComponent, belongs to the application's Angular module,
      app.module, so we declare it here.
      We can add other components here as well.
      We'll cover best practices for organizing our application
      into Angular modules later in this course.>In the imports array, we define the external modules
      that we want to have available to all of the components
      that belong to this Angular module.
      External modules could be modules provided by Angular,
      a third-party or our own Angular modules.
      Here we import BrowserModule,
      which every browser application must import.
      BrowserModule registers important application
      service providers such as air handling.
      The bootstrap array defines the root component
      of the application, which is our AppComponent.
      This root component should contain the selector we use
      in the index.html file, which it does.
      When this component is loaded, the template defined here
      appears within the directive tags
      and the user sees the user interface for our component.
      So, index.html loads and executes the ES6 module main,
      main bootstraps the application's Angular module AppModule
      which in turn bootstraps the root application component,
      AppComponent and the component's template
      appears in the browser.>Luckily we only need to set up>the bootstrapping process once.
      Now let's see this bootstrapping process in action.
    </p>
    <h3>Demo: Bootstrapping Our App Component</h3>
    <p>In this demo, we'll set up index.html
      to host our application, and bootstrap the app component
      to bring our application to life.
      Here we are back with our sample application
      exactly how we left it.>Let's open the index.html file.
      To host our application, we use the component selector
      as a directive here within the body element.
      We can think of a directive as simply a custom HTML tag.
      Now let's delete our extra text here>and if we want to display a message on the page
      while the application is loading, we add that text
      between the component tags.>The bootstrapping code we discussed in the slides
      is already in place.>So index.html loads and executes the ES module main.
      Main bootstraps the application's Angular module AppModule,
      which in turn bootstraps>the root application component, AppComponent.
      Now we're ready to run.>We saw in the last module how to start the application
      by typing npmstart in a terminal or command window.
      We'll first see the original loading app message,
      and when the root component is loaded,
      that message is replaced with HTML from our component.
      And the binding in that HTML is replaced
      with a value of our page title property.
      We now have a working, albeit very small, application.
      And since the npmstart command>set up the TypeScript compiler to watch for changes,
      we can make a change to the code
      and immediately see the results in the browser.
      Cool.>Before closing the browser, let's take a moment
      and look at the browser developer tools.
      With the browser window active, press F12.>The exact tools you see here>depend on the browser you are using.>I am
      using Chrome.>Most modern browsers provide a Console tab>as part of the development tools.
      This is always the first place to look
      if the page does not appear as expected
      or doesn't appear at all.>Errors, warnings, and other information is displayed here.
      Use the Elements tab or DOM Explorer>to view the HTML displayed in the page.
      This is a depiction of the DOM or Document Object Model.
      The Document Object Model is a document model loaded
      into the browser and represents our HTML as a node tree
      where each node is a part of our HTML.
      Here is the HTML from the index.html file.>And here is our selector tag.
      Open the selector tag and we see the HTML
      that we defined in our component's template.
      This view is a great way to see the HTML
      for the rendered page.>There is also a debugger option available here
      on the Sources tab to view and debug our code.
      Now let's finish up this module
      with some checklists we can use
      as we build our own components.</p>

    <h3>Checklists and Summary</h3>
    <p>Angular is all about components.
      So our first set of checklists are for building a component.
      We create a class for the component
      with code to support the view.>We use a decorator to define the component metadata
      which includes the HTML for the component's template.
      And we import what we need from any third-party library,
      from our modules, or from Angular itself.
      When creating the component class, we give it a clear name.
      This is not only the name of the class,
      but the name of the component as well.
      Be sure to watch the casings>since JavaScript is case sensitive.
      By convention, use PascalCasing,
      whereby every word of the name is capitalized.
      It is common to append component
      to the end of the class name>to make it clear that it is a component class.
      Be sure to include the export keyword
      on the class signature.>Recall what the export keyword does?>It makes the class accessible to be imported
      by other parts of the application.
      If the component view displays data, such as a title,
      the data element is defined as a property of the class.
      To leverage TypeScript's strong typing,
      be sure to set the appropriate data type for each property
      and set a default value where appropriate.>Use camelCase for property names
      with the first letter lowercase.
      If the component view has functionality,
      such as hiding and showing an image,>the logic is to find as methods in the class.
      Use camelCase for method names>with the first letter lowercase.
      How do we find the metadata for our component?
      If you said a component decorator, you are right.
      A class is not a component>unless it has a component decorator.>Be sure to prefix the decorator with an at,>since
      the
      decorator is a function, add parentheses,
      and pass in the appropriate object properties.
      Use the selector property to define the name
      of the component when used as a directive in HTML.
      Be sure to prefix the selector for clarity.>Note that the selector property is not needed
      if the component is not used in any HTML,
      as we'll see later in this course.
      Use the template property in the component metadata
      to define the view's HTML.>Since we define the HTML in a string literal,
      we often get no IntelliSense or syntax checking,
      so take care to define correct HTML syntax.>We'll see alternate ways to create the template
      for a component in the next module.
      So, why do we need to use import?
      The import statement tells Angular where to find
      the members that this component needs
      from any external modules.>The import statement requires the import keyword
      followed by the member name and module path.
      Take care when defining the member name
      as it is case sensitive.>The path to the module file must be enclosed in quotes
      and is also case sensitive.>And remember that we don't need
      to specify the file extension.>So, what do you do if you follow the steps,>but the sample application doesn't work
      for
      you?
      You follow the something's wrong checklist.>First press the F12 key in the browser
      to view the developer tools and check the console.
      The Angular error messages are often quite clear.
      If you repass the initial line of technical details.
      Second, recheck your code.>For any HTML, be sure the tags are all correctly closed,
      and that all of the Angular directives
      are correctly spelled and cased.
      Angular directives are case sensitive.
      For the TypeScript code,>be sure the braces are all properly closed.>And just like JavaScript, TypeScript is case
      sensitive.
      So, in short, everything has the appropriate case.
      If there doesn't appear to be anything wrong with the code,
      check my blog post as described in the first course module.
      Here's the link.>I'll add common sample application problems>and their solutions to this post.
      Note that I don't get notified if you post comments
      on my blog, so consider posting comments elsewhere
      as described next.>If there's nothing on my blog that solves your issue,
      post a comment on the discussion page for the course.
      Here's the link.>I normally get notified of every post
      to the discussion page.>Plus other Pluralsight subscribers will see your post
      and can respond.>Following these steps should get you back on the path
      to success with Angular.>In this module, we detailed what a component was
      and how to build one by creating a component class,
      defining the metadata, and importing what we need.
      And we discovered how to bootstrap the component
      we built to bring our application to life.>Here again is our application architecture.>In this module we built the
      app
      component
      and have the very basics of our application working.
      Next up, let's take a closer look at templates
      and how Angular can power them up
      with binding and directives>as we start building the product list component.
    </p>

    <h2>Templates, Interpolation, and Directives</h2>
    <h3>Introduction</h3>
    <p>To build a user interface for our application
      in Angular, we create a template with HTML.>To really power up that user interface,
      we need Angular's data binding and directives.
      Welcome back to Angular 2: Getting Started from Pluralsight.
      My name is Deborah Kurata and in these next two modules
      we create our user interface using templates,
      directives, and data binding.
      Web applications are all about the user interface.
      And Angular makes it easier to build>rich and powerful user interfaces.
      Angular gives us data binding so we can easily
      display information and respond to user actions.
      With Angular directives we add logic to our HTML,
      such as If statements and For loops.>And with Angular components we build>nested user interface fragments.
      Such as an image rotator or rating stars.
      We've seen that and Angular component
      is a view defined with a template.
      It's associated code defined with a class
      and additional information defined with metadata
      and set using a component decorator.>In these next two modules,>we'll focus on techniques for building the
      template.
      In this module, we evaluate the different ways
      we can build a template for our component.>And demonstrate how to create
      a linked template for our view.
      Then we'll build a component associated
      with that template and use it as a directive.
      We'll detail how to set up data binding
      using interpolation and display the value
      of our component class properties in the view.
      We need some basic logic in the template,
      so we'll leverage Angular's built in directives.
      In the next module, we'll look at
      additional data binding techniques.
      Looking at our application architecture,
      we currently have the index.html file
      and our root App Component in place.>So we have a working sample application,
      but it doesn't look like much.>What we really want is a list of products.>In this module we'll begin work on the
      Product List
      Component to display that list of products.>Let's get started.</p>
    <h3>Building a Template</h3>
    <p>In the prior module, we built an inline template
      for our App Component.>We used the template property to define the template
      directly in the component's metadata.
      But this is not the only way we can build
      a template for our components.>We can use the template property and define>an inline template using a simple
      quoted
      string
      with single or double quotes.
      Or we can define an inline template with a multi-line string
      by enclosing the HTML in ES 2015 back ticks.
      The back ticks allow composing a string over several lines,
      making the HTML more readable.>We used this technique to build our template
      in the last module.>There are some advantages to defining an inline template
      using one of these two techniques.
      The template is directly defined within the component,
      keeping the view and the code for that view in one file.
      It is then easy to match up our data bindings
      with the class properties such as the page title
      in this example.>However, there are disadvantages as well.
      When defining the HTML in a string,
      most development tools don't provide IntelliSense,
      automatic formatting, and syntax checking.>Especially as we define more HTML in the template,
      these issues become challenges.
      In many cases the better option is to define
      a linked template with the HTML in its own file.
      We can then use the template URL property in the component
      metadata to define the URL of our HTML file.
      Let's use this technique and build
      a linked template for our product list view.
      Here is our ultimate goal for the product list view.
      The view has a nice heading.>A Filter by box at the top allows
      the user to enter a string.>The user entered string is displayed here
      and the list of products is filtered to only those
      with a product name containing that string.>The products are listed in a neat table
      with a nicely formatted header.
      The Show Image button shows an image for each product.
      The product name is link that displays the product detail
      view which we'll build later in this course.
      To make this page look nice with very little effort,
      we use the Twitter Bootstrap styling framework.
      You don't need to have experience with this framework
      and if you're using the starter files,
      you don't even have to install it.
      I've already included what we need.
      But if you want to find out more about
      the Twitter Bootstrap styling framework,
      check out this link.>Now let's jump into a demo and start building
      the template for our product list view.
      When we last saw our sample application,
      we had completed the App Component.
      Now we want to add an external template
      for the Product List Component.
      By convention each feature of the application
      has its own folder under the app folder.
      So let's add a new folder here and name it products.
      In that folder, we'll create the template
      for our Product List Component.
      By convention, the name of the template is the same name
      as the component with an HTML extension.
      We'll call our Product List Component,
      product-list.component.html.>Let's widen that up a little bit.
      Now we are ready to create the HTML for our template.
      Let's start with the heading.
      We're using Twitter Bootstrap style classes here
      to display the content in a panel
      and display the heading as the panel heading.
      In the heading we display, Product List.
      If you don't want to type in all of this code,
      you can copy it from the APM final folder
      provided in my GitHub repository as detailed
      in the First Things First module earlier in this course.
      Next is the filter by.>We define an input box for entry of the filter string.
      And we add text that displays the user entered filter.
      We again use Twitter Bootstrap style classes
      to lay out the input box and text into rows.
      Now let's build the table.>We use Twitter Bootstrap's table style classes.
      We have a table header.>The first column header is a button
      to show the product image.>And here is the table body.>Hmm, we definitely don't want
      to hard code in the products here,
      so let's leave the table body empty for now.
      So we have the start of a template
      defined for our component.>Now what?>If you said we need to build the component,>you are exactly right.</p>
    <h3>Building the Component</h3>
    <p>Remember the steps for building a component>that we covered in the last module?
      We define a class.>We add a component decorator to define
      the metadata and specify the template.
      And we import what we need.>The only thing that's really different from the component
      we created in the last module is the template property.
      Here we are using template URL to define the location
      of our linked template instead of defining an HTML string.
      Let's jump right back to the demo and give this a try.
      We are back with the sample application exactly where
      we left it and we are ready to build a new component.
      We start by creating a new file in the products folder.
      We'll name it using the component naming convention.
      .component because it is an Angular component
      and .ts for the extension.>Then we create the class, export class ProductListComponent.
      We're exporting this class so it is available
      to other parts of the application.
      Next, we decorate the class with a component decorator.
      It is the component decorator that
      makes this class a component.
      And we know what that underline means.
      We need the import statement.
      Let's pass an object into the component decorator
      with the appropriate properties.
      For the selector, we'll set pm-products.
      We'll use the same prefix as in the App Component
      to distinguish the selector as part of
      the product management application.
      Then we define the template URL.
      Here we provide the path to our HTML file.>Notice that the path is relative to the index.html file.
      So we specify the app folder and products sub-folder
      before defining the name of the HTML file.>We'll look at relative pathing in the
      More On Components module later in this course.
      So now we have our template defining our view.
      Our class which defines our associated code.
      And the component decorator that defines the metadata.
      Our component is complete and we're ready to use it.
      But, how?</p>
    <h3>Using a Component as a Directive</h3>
    <p>Here is our newly created Product List Component.
      And here is the App Component we created earlier.
      Note that I've excluded some of the code here on this slide,
      such as the import statements
      and class details for a better fit.
      We'll see the complete code when we get back to the demo.
      When a component has a selector defined, as we have here,
      we can use the component as a directive.
      This means that we can insert this component's template
      into any other component's template
      by using the selector as an HTML tag, like this.
      The Product List Component's template is then inserted
      into this location in the App Component's template.
      So this is the first step when using>a component as a directive.>Use the name defined in the selector as an HTML
      tag
      in another component's template.
      When this template is displayed, Angular looks
      for a component that has a selector with this name.
      We could have hundreds of components in our application,
      how does our application know
      where to look for this selector?
      The application looks to the Angular module>that owns this component to find all of the directives
      that are visible to this component.
      Remember the Angular module we looked at
      earlier in this course when we saw
      how to Bootstrap our App Component?
      Every Angular application must have
      at least one Angular module, the root application module,
      commonly called AppModule.>I had provided the first cut of this Angular module
      with the starter files.>Currently our AppModule declares
      our root application component, AppComponent.
      A component must belong to one and only one Angular module.
      Because the AppModule declares the AppComponent,
      the AppComponent belongs to the AppModule.>The AppModule bootstraps the application
      with this component, so it is the first component
      that is loaded for our application.
      Our AppModule also imports the system BrowserModule
      to pull in the features it needs
      to run this application in a browser.
      So this is what our AppModule currently looks like.
      An Angular module defines the boundary
      or context within which the component resolves
      its directives and dependencies.
      So when a component contains a directive,
      Angular looks to the component's module to determine
      which directives are visible to that component.
      What does that mean for us?>Well, for Angular to find the pm products directive
      used in the AppComponent, the ProductList Component
      must also be declared in this Angular module.
      This is the second step when using
      a component as a directive.>We need to ensure that the directive>is visible to any component that uses it.
      There are two ways to expose>a directive in an Angular module.
      We can declare the component>in the Angular module as we show here.
      Or if the component is already declared
      in another Angular module, we can import that module
      similar to how we import BrowserModule here.
      Now let's jump back to the demo and give this a try.
      We are back in our sample app.>We defined a selector for our Product List Component here
      so we can use it as a directive in any other component.
      Let's use it in the App Component.
      Open the App Component file.>So instead of displaying my first component,
      we'll display our new product list template here.
      Replace the div tags with pm-products.
      Are we ready to see our result in the browser?
      And our page does not display.>Let's use our F12 tools to see why.
      The key part of this error is that
      we have a Template parse error,
      pm-products is not a known element.
      And with this error, Angular gives us a solution.
      If pm-products is an Angular component,
      and in our case it is,>then verify that it is part of this module.>Ah, yes.>We didn't do step two and declare
      it>in
      our applications Angular module.
      Let's go back to the code.>We'll open the app module and add ProductListComponent
      to the declarations array.>We'll we're getting a squiggly line here,
      that means we have an error.>Any guess as to what's wrong?
      If you said we're missing the import, you are correct.
      Everything we declare, must be imported.
      We add all of the import statements at the top of the file.
      Okay, our syntax error is gone.
      Now let's try it again.>There's our Loading App message.
      And our page.>It's not complete and it's not interactive yet,
      but we have the basics in place.
      So we successfully used our Product List Component
      as a directive.>We added the selector as the directive
      in the containing component's template.
      We declared the component>to the application's Angular module.>And we added the appropriate import statement.
      Now we are ready to power up our user interface
      with data binding and some built in Angular directives.
    </p>
    <h3>Binding with Interpolation</h3>
    <p>In Angular, binding coordinates communication
      between the component's class and its template
      and often involves passing data.
      We can provide values from the class>to the template for display.>And the template raises events to pass user
      actions
      or user entered values back to the class.
      The binding syntax is always defined in the template.
      Angular provides several types of binding
      and we'll look at each of them.
      In this module, we cover interpolation.
      The remaining data binding techniques
      are covered in the next module.
      The double curly braces that signify interpolation
      are readily recognizable.>The pageTitle in this example is bound
      to a property in the component's class.
      Interpolation is a one-way binding
      from the class property to the template.
      So the value here shows up here.
      Interpolation supports much more than simple properties.
      We can perform operations such as concatenation
      or simple calculations.>We can even call a class method such as getTitle shown here.
      We use interpolation to insert the interpolated strings
      into the text between HTML elements as shown here.
      Or we can use interpolation with
      element property assignments as in this example.
      Here we assign the innerText property
      of the h1 element to a bound value.
      Both of these examples display the same result.
      The syntax between the interpolation curly braces
      is called a template expression.
      Angular evaluates that expression
      using the component as the context.
      So Angular looks to the component
      to obtain property values or to call methods.
      Angular then converts the result of the template expression
      to a string and assigns that string
      to an element or directive property.>So any time we want to display read only data,
      we define a property for that data in our class
      and use interpolation to display that data in the template.
      And if we need to perform simple calculations
      or get a result from a method,>we can do that with interpolation as well.>Let's give this a try.>Looking at the
      product list template>from our sample application, we hard coded in
      the page title here in the heading.
      Binding the heading to a property in the class
      instead of hard coding it in the HTML makes it easier
      to see and change when working on the code.>And we could later retrieve this text
      from a file or database.>Let's start by adding a property
      in the class for the page title.
      We'll open the component to the right
      and close down the Explorer.>Here in the class, we specify the property name.
      We'll call it pageTitle and because we are using TypeScript,
      we define the type for this property.
      Lastly we assign a default value, Product List.
      With the page title property in place, we can now
      bind to the page title property in the template.
      We replace the hard coded Product List here>with interpolation and specify the name of the property.
      Now when this template is displayed,>Angular assigns the string value of the pageTitle property
      to the inner text property of this div element.
      And Product List will be displayed.
      Let's see the result in the browser.>With our binding, the page title appears as before.
      So we can confirm that it works,
      I've rearranged the windows so that we can see
      both the code and the browser.>Now let's make a change to our pageTitle here.
      And we immediately see it in the browser.
      So our interpolation works.>So anytime we want to display the value
      of a component property, we simply use interpolation.
      Now we're ready to add some logic to our template.
    </p>
    <h3>Adding Logic with Directives: ngIf</h3>
    <p>We can think of a directive as a custom HTML element
      or attribute we use to power up and extend our HTML.
      We can build our own custom directives
      or use Angular's built-in directives.
      Previously in this module, we've seen how to build
      a component and use it as a custom directive.
      We use the pm-products directive
      to display our product list template.
      In addition to building our own custom directives,
      we can use Angular's built-in directives.
      The built-in Angular directives
      we'll look at are structural directives.
      A structural directive modifies the structure or layout
      of a view by adding, removing,>or manipulating elements and their children.
      They help us to power up our HTML
      with If logic and For loops.>Notice the asterisk in front of the directive name.
      That marks the directive as a structural directive.
      Let's look at ngIf first.>ngIF is a structural directive that removes or recreates
      a portion of the dom tree based on an expression.
      If the expression assigned to the ngIf
      evaluates to a false value,>the element and its children are removed from the dom.
      If the expression evaluates to a true value,
      a copy of the element and its children
      are reinserted into the dom.>For example, say we only wanted to show the HTML table
      if there are some products in a list of products.
      We use ngIf on the table element
      and set it to products and products.length.>If the products variable has a value>and the products list has length,
      the table appears in the dom.
      If not, the table element and all of its children
      are removed from the dom.>But didn't we just say that an Angular module
      defines the boundary or context within which
      the component resolves its directives and dependencies?
      How will our application find this ngIf directive?
      Looking back at the illustration of our AppModule,
      we see that it imports BrowserModule.
      Luckily for us, BrowserModule exposes
      the ngIf and ngFor directives.>So any component declared by the AppModule>can use the ngIf or ngFor directives.
      With that settled, let's try out the ngIf directive.
      We are back in the sample application
      looking at the Product List Component and its template.
      We only want to display this table of products
      if there are some products to display.
      So the first thing we need is a property
      to hold the list of products.
      Where do we define that products property?>In the component's class, of course.>We'll add a products property
      here.
      Hmm, but what is the type of this property?>Well, we want an array of product instances,
      but we don't currently have anything>that defines what a product is.
      We'll have a better solution in a later module, but for now,
      we'll just define products as an array of any.
      In TypeScript, we use any as the data type any time
      we don't know or don't care what the specific data type is.
      We need to populate our array, but where do we get the data?
      In many cases, we would communicate
      with a back end server to get this data.
      We'll look at how to do that later in this course.
      For now, we'll just hard code in a set of products.
      If you are coding along, consider copying a few
      of the products from the products.json file provided with
      the starter files under the api products folder.
      With the products property in place,>we're ready to use it in the HTML.
      We want to put it on the table element because that is
      the element we want to add or remove from the dom.
      Type *ngIf equals and then our expression
      enclosed in quotes.>We only want to show the table>if there is a list of products>and that list of products
      contains
      some elements.
      Let's see what this looks like in the browser.
      We see the table header so we know our table is displayed.
      Let's try this.>Let's comment out the product property assignment.
      Bring up the browser again,>and we see that the table disappeared.
      Now if we uncomment out our table,
      and look again at the browser, our table reappears.
      With ngIf, the associated element and its children
      are literally added or removed from the dom.
      But notice that we still aren't populating>the table with our products.>Let's do that next.</p>
    <h3>Adding Logic with Directives: ngFor</h3>
    <p>Another structural directive is ngFor.
      ngFor repeats a portion of the dom tree
      once for each item in an iterable list.
      So we define a block of HTML that defines
      how we want to display a single item>and tell Angular to use that block
      for displaying each item in the list.
      For example, say we want to display
      each product in a row of a table.
      We define one table row and its child table data elements.
      That table row element and its children
      are then repeated for each product in the list of products.
      The let keyword here creates>a template input variable called product.
      We can reference this variable anywhere on this element,
      on any sibling element, or on any child element.
      And notice the of instead of in here.
      We'll talk more about that in a moment.
      For now, let's jump back to our demo.
      We are once again looking at>the Product List Component and its template.
      Here in the table body, we want to repeat a table row
      for each product in the list of products.
      In the table body, we'll add a tr element for the table row.
      And in the tr element, we'll specify the ngFor.
      *ngFor = "let product of products".
      Next, we'll add the child elements.
      We'll insert a td or table data element for each property
      of the product that we want to display in the table.
      We'll need to match them up with the table header elements.
      The first column displays the product image.
      Let's skip the image for now.
      We'll add that in the next module,
      but we'll still add the td element as a placeholder.
      The next table header says Product,
      so in this column we want the product name.>We'll use interpolation to bind to the product's name
      by using the local variable, product,
      and a . to drill down to the product properties.
      We want productName here.>How did we know that property name?
      Looking here at the Product List Component,>we see the product property names here.
      So these are the names we use
      in the interpolation template expressions.>Next, I'll add td elements for some
      of the other product properties.
      So for each product in our list of products,
      we will get a tr element for a table row
      and td elements for table data.
      Want to see how this looks in the browser?>Wow, we have our products.>Doesn't that look nice?>Well, our price is
      not
      very well formatted>and it doesn't have a currency symbol.
      We'll fix that with pipes in the next module.
      Looking back at the component,>we defined an array for our list of products.
      In the template, we laid out the HTML
      to display one product.>The product is displayed in a table row
      with product properties in the appropriate columns.
      Using an ngFor structural directive,>we repeat this table row and its columns
      for each product in the list of products.
      So why is this ngFor syntax product of products
      and not product in products?>The reasoning for this has to do with ES 2015 For loops.
      ES 2015 has both a for of loop and a for in loop.
      The for of loop is similar to a for each style loop.
      It iterates over an iterable object such as an array.
      For example, say we have an array of person's nicknames.
      If we use for of to iterate over this list,>we'll see each nickname logged to the console.
      The for in loop interates over the properties of an object.
      When working with an array such as this example,
      the array indexes are innumerable properties
      with integer names and are otherwise>identical to general object properties.
      So we see each array index logged to the console.
      To help remember the difference,
      think of in as iterating the index.
      Since the ngFor directive iterates over iterable objects,
      not their properties, Angular selected to use
      the of keyword in the ngFor expression.
      Now let's finish up this module with some checklists
      we can use as we work with templates,
      interpolation, and directives.</p>

    <h3>Checklists and Summary</h3>
    <p>Checklists are a great way to recheck
      our understanding and our work.
      Let's start with a template.>Use an inline template when building shorter templates.
      Then specify the template property
      in the component decorator.>Use double or single quotes to define the template string.
      Or use the ES 2015 back ticks
      to lay out the HTMl on multiple lines.
      When using inline templates there is often>no design time syntax checking.
      So pay close attention to the syntax.
      Use linked templates for longer templates.>Specify the templateUrl property in the component decorator
      and define the path to the external template file.
      This one is a more visual checklist.>After building the template, we built its component
      and learned how to use that component as a directive.
      Remember our steps?>First, we use the directive as an element
      in the template for any other component.
      We use the directive component selector
      as the directive name.>We then declare the component so it is available
      to any template associated with this Angular module.
      We add the component to the declarations array
      passed into the NgModule decorator of the Angular module.
      Angular's data binding was introduced
      in this module with a look at interpolation.
      Interpolation is one way binding
      from a component class property to an element property.
      Interpolation is defined with curly braces>and a template expression.>That expression can be a simple property,
      a concatenation, a calculation, or a method call.
      Note that no quotes are needed when using interpolation.
      And we saw how to use two>of Angular's structural directives.
      ngIf and ngFor.>When using these structural directives
      be sure to prefix them with an asterisk.
      And assign them to a quoted string expression.
      Use ngIf to add or remove an element and its children
      from the dom based on an expression.>If the assigned expression is evaluated to be a true value,
      the element is added to the dom.
      If false, the element is removed from the dom.
      Use ngFor to repeat an element and its children in the dom
      for each element in an iterable list.
      Define the local variable with let and use of,
      not in, when defining the ngFor expression.>In this module, we evaluated the differences
      between an inline template and a linked template.
      And we created a linked template.
      We then built a component for that template>and learned how to use that component as a directive.
      We took a first look at Angular
      data binding through interpolation.
      And powered up our template by using>built in Angular directives.>Here, once again, is our application
      architecture.
      In this module, we started the Product List Component.
      Next up, let's discover more of
      Angular's data binding features
      and add interactivity to the product list template.
    </p>

    <h2>Data Binding &amp; Pipes</h2>
    <h3>Introduction</h3>
    <p>There's more to data binding than just displaying component properties.
      Welcome back to Angular Two: Getting Started from Pluralsight.
      My name is Deborah Kurata and in this module,
      we explore more data binding features
      and transform bound data with pipes.>To provide a great interactive user experience,
      we want to bind DOM elements to component properties
      so the component can change the look and feel as needed.
      We can use bindings to change element colors or styles
      based on data values,>update font size based on user preferences,>or set an image source from a database field,
      and we want notification of user actions and other events
      from the DOM so the component can respond accordingly.
      For example, we respond to a click on a button
      to hide or show images.>And sometimes, we want the best of both worlds
      using two-way binding to set an element property
      and receive event notifications of user changes
      to that property.>In this module, we'll use Angular's property binding
      to set HTML-element properties in the DOM.>We walk through how to handle user events
      such as a button click with event binding
      and how to handle a user input with two-way binding.
      Lastly, we'll discover how to transform
      bound data with pipes.>And here once again is our application architecture.
      We have the first cut of our product list component,
      but it doesn't have any interactivity.
      In this module, we'll use data binding features
      to add interactivity to the product list component.
      Let's get started.</p>
    <h3>Property Binding</h3>
    <p>Property binding allows us to set a property of an element
      to the value of a template expression.
      Here, we bind the source property of the image element
      to the image URL property of the product,
      effectively defining the source of the image
      from information in our component class.
      Our binding target is always enclosed in square brackets
      to the left of the equals>and identifies a property of the element.
      The binding source is always enclosed in quotes
      to the right of the equals>and specifies the template expression.
      For comparison, here is a similar binding
      using interpolation.>Note that in this case,>the element property is not enclosed in square brackets
      and the template expression is enclosed
      in curly braces with no quotes.
      Like interpolation, property binding is one way
      from the source class property>to the target element property.
      It effectively allows us to control our template's DOM
      from our component class.>When we can use property binding or interpolation
      to achieve the same result, which one is better?
      The general guideline is to prefer property binding
      over interpolation.>However, if you need to include the template expression
      as part of a larger expression such as this example,
      you may need to use interpolation.
      Now let's add some property binding
      to our sample application.>Here we are back in the editor,
      looking at the product list component
      and its associated template.>Let's use property binding to bind the source
      of our product image.>We use an image element to display our product image
      and we'll use property binding to bind the image's source
      or SRC property so we enclose the SRC in square brackets.
      On the right side of the equals,
      we define the template expression in quotes.
      We want to bind to the product's image URL property
      from the product list component class.
      Let's also use property binding to bind the title property
      of the image to the product's name.
      Let's check out the result in the browser.>Whoa, they're big, but we do see images.
      If we hover over an image, we see the image title,
      but this image is rather large for display in our table.
      Let's use property binding to set some style properties.
      Let's add properties for the image width
      and image margin to our component class.
      The image width is a number>so we specify its type with a colon and then number.
      Let's set it to 50.>The image margin is also a number
      and we'll set it two.>Back in the template, we use property binding
      to bind the image styles.>We want to bind the style property width in pixels.
      We'll bind that to the image width property>from the component class.>Notice that we don't prefix this property
      with
      product
      because image width is a property of the component class,
      not the product object.>And we do the same with the style margin in pixels
      and set that to the image margin class property.
      So now we've seen how to use property binding
      to bind several properties of the image element
      to properties of the components class.
      Looking again at the browser, that looks much better,
      but our images are always displayed.>The show image button doesn't work yet.
      To hook up the button, we need to respond to user events.
      Let's do that next.</p>
    <h3>Handling Events with Event Binding</h3>
    <p>So far, all of our data binding has been one way
      from the component class property to the element property,
      but there are times we need to send information
      the other way to respond to user events,
      for example to perform an operation
      when the user clicks a button.>A component listens for user actions using event binding
      as shown here.>Notice how similar this syntax is to property binding.
      In this example, the component listens
      for the click event on a button.
      The name of the bound event is enclosed in parentheses,
      identifying it as the target event.
      To the right of the equals is the template statement.
      This is often the name of a component class method
      followed by open and closing parentheses
      and enclosed in quotes.>If the defined event occurs,>the template statement is executed
      calling the specified method in the component.
      Wondering where you might find a list of valid DOM events?
      Check out this link.>The Mozilla Developer Network provides a thorough list
      of standard events along with some documentation.
      Now let's give event binding a try.
      In this demo, we want to implement our show image button.
      First, we define a class property that keeps track
      of whether the images are currently displayed.
      We'll call that property show image.>Since this property is true or false,
      we define its type as Boolean
      and let's set its default value to false
      so the images are not displayed
      when the page is first loaded.>Next, we build the method that the event binding will call.
      By convention, methods are normally created after
      all of the properties are defined so we'll put it down here.
      Let's name the method toggle image.
      Notice that TypeScript does not require any keyword
      such as function.>Following the method name with open and closing parentheses
      identifies it as a method.>Our method won't have a return type
      so we specify the return type as void.
      The body of the method simply toggles the state
      of the show image property.>Back in the template,>we are ready to set up the event binding.
      On the button element,>we define the click as the target event
      by enclosing it in parentheses.
      We assign it to our method enclosed in quotes.
      When the user clicks the button,
      the binding calls our method.
      So the only thing left is to actually
      hide or show the image.>Recall how we add logic to add or remove
      HTML elements from the DOM?>If you said the NGF directive, you are right.
      We'll add NGF to the image element.
      We only want this image element
      if the show image flag is true.
      So we type star NGF equals quote show image.
      The image element will then only be added to the DOM
      if show image is true.>Let's see if this works.>Are we ready to give it a try?>Click the button and the image
      appears.
      Click the button again and the image disappears.
      Oh, very cool.>The only odd thing is the button text.
      When the image is displayed,>the button text should change to hide image.
      So up here where we have the button text,
      let's use interpolation.>When show image is true,>we want the button text to say hide image.>And when show image
      is
      false,
      we want the button text to say show image.>We accomplish this using a JavaScript conditional operator.
      We specify the condition which is show image
      and a question mark.>Then we specify the true expression
      so when show image is true, we want to display hide image.
      Then we add a colon and the false expression
      so when show image is false, we want it to say show image.
      Basically, we can read this syntax as
      if show image is true, display hide.>Otherwise, display show.>Let's check this out in the browser.>So our button
      text
      now says show image.
      If we click it, it says hide image.
      That seems a little more user friendly, cool.
      Now that we have our images working,>let's tackle the filter by box.
      And for that, we need two-way binding.
    </p>
    <h3>Handling Input with Two-way Binding</h3>
    <p>When working with user entry HTML elements>such as an input element,>we often want to display a component class
      property
      in the template and update that property
      when the user makes a change.
      This process requires two-way binding.
      To specify two-way binding in Angular,
      we use the ngModel directive.
      We enclose ngModel in square brackets
      to indicate property binding from the class property
      to the input element>and parentheses to indicate event binding
      to send a notification of the user-entered data
      back to the class property.>We assign this directive to a template expression.
      To help us remember which order
      to put the two sets of brackets,
      visualize a banana in a box.>Square brackets for the box on the outside>and parentheses for the banana on the
      inside.
      So now we have another Angular directive that we can use,
      every time we want to use>an Angular directive in a template,
      we need to consider how to make that directive
      visible to the component associated with that template.
      Recall that an Angular module defines the boundary
      or context within which the component
      resolves its directives and dependencies.
      The illustration of our AppModule
      currently looks like this.>We want to use the ngModel directive>in our product list component which is owned by
      AppModule.
      So in the AppModule, we need to import the appropriate
      system module that exposes the ngModel directive.
      Since the ngModel directive is most often used
      when building data entry forms,
      ngModel is part of FormsModule so we import that here.
      Now, the ngModel directive>and any of the other Angular forms directives
      are visible to any component declared by AppModule,
      including our product list component.
      Now let's give this a try.>We are back in the editor and looking at the product
      list component and its associated template.>Recall that we defined a filter by input box here
      and display the entered filter here.>We'll later use the filter to filter our list of products.
      Let's start by adding a component class property
      for the list filter.>This property is a string and we'll set a default
      initial value for filtering the list of products.
      We hard code the filter string here,>but you can imagine that we store
      the user's last entered filter>and use that as the default instead.>With that, we can set up the two-way binding.
      On the input element, we draw a banana in a box
      and specify the ngModel directive.
      We bind to the component class list filter property.
      We want to display the list filter here
      so we use interpolation.>Recall that interpolation has no quotes.
      Are we done?>Not quite.>Let's see what happens if we try to run.
      The page doesn't appear.>If we press F12, we see the error is can't bind
      to ngModel model since it isn't a known property of input.
      This is telling us that Angular can't find>the ngModel directive.>Recall from the slides that the ngModel
      directive
      is part of the Angular module for forms called FormsModule.
      To expose this directive to our product list component,
      we need to import the FormsModule
      in the module that owns the product list component
      which is our AppModule.>We start by importing FormsModule from Angular forms.
      We then add FormsModule to the imports array
      for the NG module decorator.>Why the imports array and not the declarations?
      Our directive's components and pipes are declared here
      in the declarations array.>Directives, components and pipes we use from other sources,
      such as Angular itself or third parties,
      are defined in external Angular modules
      we add to the imports array here.
      Now that we've told Angular where to find the ngModel,
      let's see the result.>When the page displays, we see cart as the default value.
      It is displayed here and here.>If we modify the entry,>notice that the displayed filter text is also updated.
      That's because we are using two-way binding.
      Notice that the list of products is not yet filtered.
      We'll do that in the next module.
      There is one more thing we do want to address now
      and that is the data formatting.
      That price should really look like a price>and show the appropriate currency symbol.
    </p>
    <h3>Transforming Data with Pipes</h3>
    <p>With Angular's data binding, displaying data is easy.
      Just bind an element property to a class property
      and we're done.>Well, not always.>Sometimes the data is not in a format
      appropriate for display.>That's where pipes come in handy.
      Pipes transform bound properties before they are displayed
      so we can alter the property values
      to make them more user friendly or more local appropriate.
      Angular provides some built-in pipes for formatting values
      such as date, number, decimal, percent, currency,
      uppercase, lowercase, and so on.
      Angular also provides a few pipes for working with objects
      such as the JSON pipe>to display the content of an object as a JSON string,
      which is helpful when debugging,
      and a slice pipe which selects a specific subset
      of elements from a list.>We can also build our own custom pipes
      as we'll see in the next module.
      Let's start with a simple example.
      Say we want to display the product code in lowercase.
      We can add the pipe character after the property
      in the template expression>and then specify the lowercase pipe.>The product code is then transformed into
      lowercase
      before it is displayed.>We can also use pipes and property bindings.
      Add the pipe after the property in the template expression
      and specify the desired pipe.
      In this example, we specified the uppercase pipe
      so the image title will appear in all caps.>If needed, we can chain pipes.>In this example, the price is
      transformed
      into a currency.
      By default, the currency pipe adds the all caps
      three-letter abbreviation of the local currency
      to the amount.>If we want to display that abbreviation in lowercase,
      we can transform it again by simply adding another pipe.
      Some pipes support parameters.>Parameters are defined by specifying a colon
      and a parameter value.>For example, a currency pipe has three parameters,
      the desired currency code, a Boolean value>indicating whether to display the currency symbol,
      and digit info.>The digit info consists of>the minimum number of integer digits,
      the minimum number of fractional digits,
      and the maximum number of fractional digits.
      The value here of 1.2-2 means at least one digit
      to the left of the decimal>and at least two digits to the right of the decimal
      and no more than two digits to the right of the decimal,
      effectively defining two decimal places.
      With that, let's jump back to the demo.
      We specified the pipes in the template
      so we are looking at the product list component template.
      Let's add a lowercase pipe for the product code
      and a currency pipe for the price.
      For the product code, we simply insert the pipe character
      after the property in the template expression
      and type lowercase, that's it.>For the price, we insert a pipe character and currency.
      That's all that is required,>but let's try out a few of the parameters.>We'll specify USD true to display the
      dollar
      sign
      instead of the currency abbreviation>and 1.2-2 to specify that we want at least one number
      to the left of the decimal place and two
      and only two numbers to the right of the decimal place.
      Let's see how we did.>Looking at the result,>we now see the product code in lowercase
      and the price displayed nicely as a currency.
      So we can easily perform simple data transformations
      using the built-in pipes in the template expressions
      for our bindings.>Feel free to try out>some of the other pipes from the slides.
      Let's finish up this module with some diagrams
      and a checklist we can use>as we work with bindings and pipes.
    </p>
    <h3>Checklists and Summary</h3>
    <p>Data binding makes it easy to display class properties
      from our component and set DOM element properties
      to our class property values to better control the view.
      And the component can listen for events from the DOM
      to respond as needed for an interactive user experience.
      There are four basic types of binding in Angular.
      Here is a diagram as a memory aid.
      Interpolation inserts interpolated strings>into the text between HTML elements
      or assigns element properties.>Be sure to wrap the template expression in curly braces
      and no quotes.>Property binding sets an element's property>to the value of a template expression.
      The binding target specifies a property of the element
      and must be enclosed in square brackets.
      The binding source specifies the template expression
      and must be enclosed in quotes.
      Event binding listens for events
      and executes a template statement when the event occurs.
      The target event specifies an event name
      and must be enclosed in parentheses.>The template statement often defines the name
      of the method to call when the event occurs>and must be enclosed in quotes.
      Two-way binding displays the component class property
      and updates the property when the user makes a change.
      Use the banana in a box syntax with the ngModel directive.
      The binding source specifies the template expression
      and must be in enclosed in quotes.
      Here are some things to remember when using ngModel.
      Define ngModel within the banana in a box
      for two-way binding.>Be sure to add FormsModule from the Angular forms package
      to the imports array of an appropriate Angular module.
      In this case, AppModule.>This ensures that the ngModel directive is available
      to any template defined in a component
      associated with that module.>We'll talk more about Angular modules later in this course.
      The data we have in our component may not be in the format
      we want for display.>We can use a pipe and a template to transform that data
      to a more user-friendly format.
      To use a pipe, specify the pipe character,>the name of the pipe and any pipe parameters
      separated with colons.>Here is an example of the currency pipe
      with three parameters.>This module covered data binding and pipes.>We looked at property binding, event binding
      and two-way binding.>Lastly, we discovered how to transform bound data
      to a more user-friendly format using built-in pipes.
      And here once again is our application architecture.
      In this module,>we finished more of the product list component,
      but it could be better.>Next up, we'll see several techniques
      for improving our component.</p>


    <h2>More on Components</h2>
    <h3>Introduction</h3>
    <p>When building clean components, we want to ensure everything is strongly typed,
      our styles are encapsulated, we respond to appropriate lifecycle events,
      and we transform data to user-friendly values as needed.
      Welcome back to Angular 2: Getting Started, from Pluralsight.
      My name is Deborah Kurata, and in this module,
      we learn several ways to improve upon our components.
      Components are one of the key building blocks of our application.
      The cleaner, stronger, and more durable
      we make these blocks, the better are our application.
      So, how can we make our components better?>Strong typing helps minimize errors
      through better syntax checking and improved tooling.
      But what if there is no pre-defined type for a property?
      To strongly type a property that has no pre-defined type,
      we define the type ourselves using an interface.
      If a component needs special styles,>we can encapsulate those styles within the component
      to ensure they don't leak out
      to any other component in the application.>A component has a lifecycle managed by Angular.
      Angular provides a set of lifecycle hooks we can use
      to tap into key points in that lifecycle,
      adding flexibility and responsiveness to our application.
      As we saw in the last module, pipes provide a convenient way
      to transform bound data before displaying it in the view.
      But Angular doesn't have built-in pipes
      for sorting or filtering iterable lists.
      And we may have other>application-unique data transformation requirements.
      Luckily, we can build our own custom pipes.>Our components often refer to external template
      and stylesheet files.>We reference these files in the component meta data
      using an absolute path from the application root.
      We can instead use a component relative path approach
      if we set module Ids.>In this module, we explain interfaces
      and demonstrate how to use them
      to strongly type our objects.
      We look at how to encapsulate component styles.
      We introduce the component lifecycle>and how hook into its events.
      We detail how to build a custom pipe.
      And we see how to change to relative paths>by setting the module Id.>Looking at our Application Architecture,
      in this module we'll add features
      to improve the product list component.
      Let's get started.</p>
    <h3>Defining Interfaces</h3>
    <p>One of the benefits of using TypeScript
      is that strong typing.>Every property has a type, every method has a return type,
      and every method parameter has a type.
      This strong typing helps minimize errors
      through better syntax checking and tooling.>In some cases however, we have a property or method
      that does not have a pre-defined type,
      such as our products array here.
      We defined our products array as any,
      which negates the benefits of strong typing.
      To specify custom types, we can define an interface.
      An interface is a specification identifying a related set
      of properties and methods.>A class commits to supporting the specification
      by implementing the interface.>That means the class includes code for each property
      and method identified in the interface.
      We can then use the interface as a data type.
      ES 5 and ES 2015 do not support interfaces,>but TypeScript does.>So interfaces are transpiled out and are not
      found
      in the resulting JavaScript.>This means that interfaces are development time only.
      Their purpose is to provide strong typing
      and better tooling support as we build, debug,
      and maintain our code.>Here is an example of a TypeScript interface.
      We define an interface using the interface keyword,
      followed by the interface name,
      which is often the name of the business object
      that the interface describes.
      By many naming conventions, the interface is prefixed
      with an I for interface,>though some TypeScript developers leave off this prefix.
      The export keyword here at the front exports this interface,
      thereby making it available for use
      anywhere in the application.>The body of the interface defines the set of properties
      and methods appropriate for this business object.
      For each property, the interface includes the property name,
      a colon, and the property data type.>For each method, the interface includes the method name,
      the list of parameters along with their data types,
      a colon, and the method return type.>To use the interface as a data type,>we import the interface, then use the
      interface name
      as the data type.>Looks easy enough.>Let's try it out.>We back in the sample application,
      looking at the product list component.
      Here, we see that we defined our products array as any.
      So let's create an interface that defines what a product is.
      We'll put the interface into its own file
      in the products folder.>We'll name that file product.ts,
      after the business object it defines.
      We first type the export keyword
      to ensure the other parts of the application
      can use this interface.>That is, after all, why we are creating it.>Next, we type in the interface keyword.
      Then, the name of the interface.
      I like to use the I prefix to distinguish the interface
      from the business object.>And we are defining a product, so Iproduct.>Inside the interface, we define the
      properties
      and methods appropriate for the business object.
      For our sample application, we only need properties.
      For each property, we define the property name, a colon,
      and the type of the property.
      Notice that we are typing the release date as a string.
      If we later work with this value as the date object,
      we could change this type to a date.>That's it, that's all we have to do to define an interface.
      Now we can use this interface as our data type
      in the product list component.>Before we do though, let's try something.
      Let's introduce a typographical error
      into our products array.>No error is detected.>We won't even know we made a mistake>until we see the application
      in
      the browser.
      And we notice that no image is displayed
      for one of the products.>As you can imagine, these kinds of errors
      could cause hard to find bugs.>Now let's replace the any with Iproduct.
      We get a syntax error.>What did we miss?>Yep, we need an import.>And, bang.>Now that our array of products is
      strongly
      typed,
      we are notified that we made an error
      in our product array property.>We don't even have to view it in the browser
      to see that something is amiss.
      So this is a good demonstration of one of the benefits
      of strong typing.>Let's fix that error.>Notice that we get intellisense now for these properties.
      Another great benefit of strong typing.
      Let's check this out in the browser.>Now everything works as it did.
      In our interface file, we could define a class
      for the product business object here as well.
      Something like this.>In general, we only create a business object class
      if that class provides some functionality
      that we want to use throughout our application,
      such as this calculate discount method.
      And if we think we might want to create a business object
      at some point in the future,>then we definitely want to add the I prefix>to our interface.>But for our sample
      application,
      we don't need any product methods.
      So we don't really need a product class.
      We will use this interface throughout the application
      to strongly type our products.>Before we move on, let's make one change.
      Notice that we're getting lots of files here.
      Unless we want to look at them,
      we really don't need to open the .js or .map files.
      Let's hide them from the editor.
      In VS code, we do that by selecting file, preferences,
      workspace settings.>I'll paste exclude entries for the .js and .map files.
      Now we see that the .js and .map files
      don't appear in the explorer window here on the left.
      And we can more easily find the files we need to edit.
      Neat!>Next, let's look at encapsulating component styles.
    </p>
    <h3>Encapsulating Component Styles</h3>
    <p>When we build the template for a component,>we sometimes need styles unique to that template.
      For example, if we build a sidebar navigation component,
      we may want special li or div elements styles.
      When we nest a component that requires special styles
      within a container component,
      we need a way to bring in those unique styles.
      One option is to define those styles directly
      in the template's HTML.>But that makes it harder to see, reuse,
      and maintain those styles.>Another options is to define the styles
      in an external stylesheet.>That makes them easier to maintain,
      but that puts the burden on the container component
      to ensure the external stylesheet is linked>in the index.html.>That makes our nested component somewhat more
      difficult
      to reuse.>But there is a better way.>To help us out with this issue,
      the component decorator has properties
      to encapsulate styles as part of the component definition.
      These properties are styles and styleUrls.>We add unique styles directly to the component
      using the styles property.>This property is an array so we can add multiple styles
      separated by commas.>A better solution is to create one
      or more external stylesheets and identify them
      with the styleUrls property.>This property is an array so we can add multiple stylesheets
      separated by commas.>By encapsulating the styles within the component,
      any defined selectors or style classes are only applicable
      to the component's template and won't leak out
      into any other part of the application.
      Let's try this out.>Before we change any code,>let's look again at our product list view in the browser.
      Notice the table headers.>They could use a little color.>So let's build an external stylesheet
      for our product list component.
      We'll add a new file in the products folder,
      and since this file only contains the styles
      for our product list component,
      we'll call it product-list.component.css.
      In this stylesheet we add a table header style.
      We can modify the t head element styles directly,
      because the stylesheet is encapsulated in this component.
      And the styles defined here won't affect any other component
      in the application.>We could add any other styles as needed
      to jazz up our product list component.
      To use this new stylesheet,>we modify the product list component.
      In the component decorator,>we specify our unique stylesheet.
      We add the styleUrls property and pass it in array.
      In the first element to the array,
      we specify the path to our stylesheet.
      Note that the style path is relative to the index.html file.
      We could add more stylesheets here, separated with commas.
      Let's review the result in the browser.
      And we see that the table header is now a nice, blue color.
      We can use the styles or styleUrls property>of the component decorator anytime we want>to encapsulate unique
      styles
      for our component.
      Next up, let's dive into lifecycle hooks.
    </p>
    <h3>Using Lifecycle Hooks</h3>
    <p>A component has a lifecycle, managed by Angular.
      Angular creates the component, renders it,>creates and renders its children,
      processes changes when its data-bound properties change,
      and then destroys it before removing its template
      from the DOM.>Angular provides a set of lifecycle hooks we can use
      to tap into this lifecycle and perform operations as needed.
      Since this is a getting started course,
      we'll limit our focus to the three most commonly
      used lifecycle hooks.>Use the OnInit lifecycle hook
      to perform any component initialization
      after Angular has initialized the data-bound properties.
      This is a good place to retrieve the data for the template
      from a back-end service, as we'll see later in this course.
      Use the OnChanges lifecycle hook to perform any action
      after Angular sets data-bound input properties.
      We have not yet covered input properties.
      We'll see those in the next module.
      Use the OnDestroy lifecycle hook to perform any cleanup
      before Angular destroys the component.
      To use a lifecycle hook,>we implement the lifecycle hook interface.>We talked about interfaces earlier in this
      module.
      Since Angular itself is written in TypeScript,
      it provides several interfaces we can implement,
      including one interface for each lifecycle hook.
      For example, the interface for the OnInit lifecycle hook
      is OnInit.>Notice that it is not prefixed with an I.
      We are using the OnInit interface from Angular,
      so any guesses as to our next step?
      Yep, we need to import the lifecycle hook interface.
      We can then write the hook method.
      Each lifecycle hook interface defines one method
      whose name is the interface name prefixed with ng
      for Angular.>For example, the OnInit interface hook method
      is named ngOnInit.>Our first step here of implementing the interface
      is actually optional.>Recall from our discussion of interfaces earlier
      in the module that neither ES 5 nor ES 2015>support interfaces.>They are features of TypeScript.
      That means that the interfaces are transpiled
      out of the resulting JavaScript.
      So we don't really have to implement the interface
      to use lifecycle hooks.>We can simply write code for the hook method.
      However, it is good practice, and provides better tooling,
      when we implement the interface.
      At this point in our application,
      we don't need to implement any lifecycle hooks,
      but we'll use them in later modules.>So let's try them out now.>We are looking at the product list component.
      We'll add the OnInit lifecycle hook to this component.
      First, we implement the interface by adding it
      to the class signature.>Type implements and the name of the interface, OnInit.
      The interface name is showing an error and we know why.
      We don't have the import.>Let's add that now.>Since OnInit is also imported from Angular Core,
      we simply add it to our first import statement
      by typing a comma and OnInit.
      Now we have another syntax error here.
      Class product list component>incorrectly implements interface OnInit.
      As the message states,>now that we've implemented the interface,
      we must write code for every property and method
      in that interface.>The OnInit interface only defines one method, ngOnInit.
      So we need to write the code for the ngOnInit method.
      We'll add it down here by the other methods.
      Since we don't really need to do anything with this
      at this point, we'll just use console.log
      to log a message to the console.
      We can view the application in the browser>and use the F12 developer tools to open the console
      and view the logged message.>We can see our message here.>We'll use ngOnInit later in this course.
      Up next, we'll build a custom pipe.
    </p>
    <h3>Building Custom Pipes</h3>
    <p>As we saw in the last module,
      we use pipes for transforming bound properties
      before displaying them in a view.
      There are built-in pipes that transform a single value
      or an iterable list of data.>We covered these in the last module.>In this module, we want to build our own custom
      pipe.
      The code required to build a custom pipe
      may look somewhat familiar at this point.
      It uses patterns similar to other code we've created
      in this course.>Here is the class.>We implement a PipeTransform interface,
      which has one method, transform.
      We write code in the transform method
      to transform a value and return it.
      The first parameter of the transform method>is the value we are transforming.
      In this example, we transform an array of products
      into a filtered array of products.
      Notice that we are using the Iproduct interface
      to strongly type the array that's passed in.
      That is the interface we created earlier in this module.
      The second parameter here is for any arguments we need
      to perform the transformation.>In our case, we want to pass in the filter criteria
      entered by the user.>The method return type is also defined
      as an array of products,>because we are returning the filtered array of products.
      We add a pipe decorator to the class to define it as a pipe.
      Similar to the other decorators we've used,>this is a function so we add parentheses.
      We pass an object to the function
      specifying the name of the pipe.
      This is the name for the pipe used in the template,
      as we'll see shortly.>And of course, we have our imports to import what we need.
      Notice how similar this looks
      to the components we've created in this course?
      Angular provides a very consistent coding experience.
      To use a custom pipe in a template,
      simply add a pipe and the pipe name.>Include any arguments required by the transformation,
      separated by colons.>But of course, that is not enough.
      We also need to tell Angular where to find this pipe.
      We add the pipe to an Angular module.
      How do we know which Angular module?>At this point, that's easy because we only have one,
      AppModule.>But if we had multiple modules, we'd add it to the module
      that declares the component that needs the pipe.
      In our example, the product list component template
      needs the pipe.>So we add the declaration to the same Angular module
      that declares the product list component.
      We define the pipe in the declarations array
      of the NgModule decorator.>Now lets build our custom pipe>and filter our list of products.
      Since our custom pipe is currently designed>to only filter products,>we'll add it to the products folder.>We'll
      create
      a new file and call it product-filter.pipe.ts,
      following our naming conventions.
      We'll start by writing the code for the class.
      Export, so we can import this pipe where we need it.
      Class, and the class name.>We'll call it product filter pipe.
      We want to implement the pipe transform interface,
      so we add that here.>The syntax error is>because we don't have the import statement.>So let's add that next.>We
      still
      have a syntax error,
      because when we implement the pipe transform interface,
      we are required to implement every property and method
      defined in that interface.>For the pipe transform interface,
      there is only one method, transform.>Notice, right away that we have yet another syntax error.
      We are defining the value parameter
      to be an array of Iproduct.>But we have not yet imported that interface.
      So let's do that now.>And we can add a return statement
      to get rid of this last syntax error.
      Next, we need to decorate the class with the pipe decorator.
      Here, we specify the pipe's name.
      And we'll add pipe to our import statement.>Now it's time to implement the transform method.
      I'll pace the code so that we can talk through it,
      but don't worry if you haven't seen
      some of the syntax before.>This is mostly JavaScript>and is not critical for learning Angular.
      But what does this code do?>Our goal is to transform the passed list of products
      to a filtered list based on a user-entered filter string.
      This first line of code>uses a JavaScript conditional operator
      to handle the possibility>that no filterBy string was defined.>If there is a filterBy, this code converts it to
      lowercase.
      Why convert it to lowercase?>So we can compare apples to apples
      when we filter the product list.
      We want a case insensitive comparison.
      If there is no filterBy,>this code sets the filterBy to null.>Then we return the filtered list of products.
      Let's break this down.>This code also uses the JavaScript conditional operator.
      If our filter variable has a true value,
      meaning that it is defined and not null,
      then we filter the list.>Otherwise, there was no filter specified
      and we return the original value,
      which is our full list of products.
      Let's look closer at this filter statement.>We are using the array filter method>to create a new array with
      elements
      that pass the test defined in the provided function.
      We're using the ES 2015 arrow syntax>to define that filter function.
      For each product in the list, the product name
      is converted to lowercase and the IndexOf
      is used to determine if the filtered text is found
      in the product name.>If so, the element is added to the filtered list.
      See the MDN entry for filter at this link
      for more information on the array filter function.
      Now we are ready to use our pipe
      in the product list component.>We'll filter the list of products here.
      In our ngfor clause, we'll add the pipe character
      and the name of our pipe, productFilter.
      Be sure to insert within the quotes.>We also need to pass in our pipe argument.>In this example, we pass in the
      listfilter property.
      That property contains the value the user entered
      in the filterBy input box.>Let's give this a try.>Oh, our page did not display.
      And using the F12 tools, we can see why.
      The pipe, productFilter, could not be found.
      What did we forget?>Recall from the slides that we need to tell Angular
      about our new pipe.>We do that by declaring the pipe in an Angular module.
      Our product list components template>wants to use the productFilter pipe.>So we open the Angular module
      that declares the ProductListComponent,
      which is our app module.>We then add ProductFilterPipe to the declarations array.
      And we import the ProductFilterPipe.>Now any component declared in App module
      can use our product filter pipe.
      Are we ready to see the result?
      Our default filter is cart,>so now we only see the garden cart.
      Change the filter, and we see different entries.
      It's working!>Not too shabby, not too shabby at all!
      So to create a custom pipe, we built a class,
      implemented the pipe transform interface,
      and decorated the class with the pipe decorator.
      To use the pipe in a template,>we specify a pipe character, the pipe name,>and any pipe arguments.>And we declare
      the
      pipe>in the Angular module's declarations array.>Next up, let's look at how we can replace the absolute paths
      in our components with relative paths.
    </p>
    <h3>Relative Paths with Module Id</h3>
    <p>Our components often refer to external template and stylesheet files.
      We reference these files in the component metadata,
      using an absolute path from the application root.
      As an example, here is our product list component.
      We specify the location to the template
      with an absolute path from the application root,
      which is the location of the index.html file.
      Because of our folder structure,
      our path is app/products.>We use the same absolute path for the location
      of our stylesheet file.>There are several downsides to using absolute paths.
      They make it harder to adjust our folder structure over time
      as the application grows.>They make it harder to reuse our components>in other applications.>And some tools, such
      as
      the ahead of time compiler
      that we'll discuss later in this course,
      require component relative paths.
      So what do we do?>We can instead use a component relative path approach
      if we set moduleId.>Here we set the component's module Id,
      so we can change to component relative URLs.
      What is this module id?>The module id is a semi-global variable that
      is available when using the CommonJS module format.
      It contains the absolute URL>of the component class module file.
      Using module id requires that we write our modules
      in the CommonJS format.>We are writing our modules in CommonJS format
      as we've defined in our tsconfig.jason file.
      We'll discuss this file more>in the Angular 2 Set-up Revisited module
      later in this course.>Using module.id also requires that we use a module loader,
      such as SystemJS.>We saw in the First Things First module,
      at the beginning of this course,
      that we are indeed using the SystemJS module loader.
      So we are all set up such that we can use module.ids.
      Let's give this a try.>Here, in our product list component,>we'll add the module.id property to the component
      decorator.
      Then we can remove the absolute paths
      from both the template URL and the style URL.
      Running the application, we can see that it still works.
      And if we look at the command window,
      we see that Angular determined>the appropriate full path for us.
      Specify a module.id anytime you want>to use component relative paths
      for the template and stylesheet URLs.
      Note that the sample code in this course
      uses absolute paths and no module.ids,
      just to keep the code simple.
      Feel free to add module.ids and use component relative paths
      if desired.>Now let's finish up this module with some checklists
      we can use as we work more with components.
    </p>
    <h3>Checklists and Summary</h3>
    <p>We've covered several discrete topics in this module,
      so we have a checklist for each one.>First, interfaces.>We use interfaces to specify custom types,>such as product
      in
      our sample application.>Interfaces are a great way to promote strong typing
      in our applications.>When creating an interface, use the interface keyword
      in the body of the interface>to find the appropriate properties and methods
      along with their types.>And don't forget to export the interface,
      so it can be used anywhere in our application.
      We implement an interface,>including built-in Angular interfaces,
      to ensure that our class defines every property and method
      identified in that interface.
      Add the implement's keyword and the interface name
      to the class signature.>Then be sure to write code for every property
      and method in the interface.>Otherwise, TypeScript displays a syntax error.
      We can encapsulate the styles for our component
      in the component itself.>That way the styles required for the component
      are associated with the component alone
      and don't leak into any other parts of the application.
      Use the styles property of the component decorator
      to specify the template styles as an array of strings.
      Use the styleUrls property of the component decorator
      to identify an array of external stylesheet paths.
      The specified styles are then encapsulated in the component.
      Lifecycle hooks allow us to tap into a component's lifecycle
      to perform operations.>The steps for using a lifecycle hook are
      import the lifecycle hook interface,>implement the lifecycle hook interface
      in the component class.>This step is not required, but highly recommended.
      Then, write the code for the hook method
      defined in the lifecycle hook interface.
      To build a custom pipe, import Pipe and PipeTransform.
      Create a class that implements the PipeTransform interface.
      This interface has one method, transform.
      Be sure to export the class so the pipe can be imported
      from other components.>Write code in the Transform method
      to perform the needed transformation.
      And decorate the class with Pipe decorator.>We can use a Custom Pipe in any template,
      anywhere we can specify a pipe.
      In an Angular module, import the pipe.
      In the meta data, declare the pipe
      in the declarations array.>Then any template associated with a component
      declared in that Angular module, can use that pipe.
      In a template, immediately after the property to transform,
      type a pipe character, specify the pipe name,
      and enter the pipe arguments, if any, separated by colons.
      Our components often refer to external template
      and stylesheet files.>To use a component relative path
      when specifying template URL and style URLs, set moduleids.
      Set the moduleid property of the component decorator
      to module.id.>Then change each Url to a component-relative path
      in the templateUrl or styleUrl properties.>This module provided a set of techniques
      for improving our components.
      We walked through how to use an interface
      to strongly type our custom objects.>We saw how to encapsulate styles within a component.
      We were introduced to the component lifecycle
      and how to tap into that lifecycle with lifecycle hooks.
      And we discovered how to build a Custom Pipe
      that we can use in any component template.>We also saw how to change to relative paths>by setting the Module
      Id.>So in
      this module,>we've completed the Product List Component.>Yay!>Next up, we'll see how to build nested components
      and build this Star Component.</p>


    <h2>Building Nested Components</h2>
    <h3>Introduction</h3>
    <p>Our user interface design may include features that are complex enough
      to be separate components, or that are reusable across our views.
      Welcome back to "Angular 2: Getting Started" from Pluralsight.
      My name is Deborah Kurata and in this module
      we see how to build components designed to be nested
      within other components,>and we'll discover how to establish communication
      between the nested component and its container.
      Just like nesting dolls, we can nest our components.
      We can nest a component within another component
      and nest that component within yet another component
      and so on.>And because each component is fully encapsulated
      we expose specific inputs and outputs
      for communication between a nested component
      and its container,>allowing them to pass data back and forth.>There are two ways to use a component
      and display the component's template.
      We can use a component as a directive.
      We saw how to use a component as a directive
      when we displayed the App Component template
      in the index.html file.>The mh-app directive is defined
      as the App Component selector.>The template is then displayed within the directive text.
      We use the same technique with nested components.
      Alternatively, we can use the component as a routing target,
      so it appears to the user>that they've traveled to another view.
      The template is then displayed in a full page style view.
      We'll use this technique later in this course
      to route to our Product List View.
      Our Product List View is currently used
      as a directive, but that's only because
      we have not yet covered routing.
      In this course module we'll focus
      on building a nested component.
      So, what makes a component nest-able?
      Technically speaking, any of our components could be nested
      if they have a selector defined in the component decorator.
      But, does it really make sense to nest a large view
      such as our Product List?>For our purposes we'll define a component as nest-able
      if its template only manages a fragment of a larger view,
      if it has a selector so it can be used as a directive,
      and, optionally, if it communicates with its container.
      In this module we'll build a nested component,
      then we'll review how to use that nested component
      as a directive in a container component.
      We'll examine how to pass data to the nested component
      using a property with the @Input decorator.>And how to pass data out of the nested component
      by raising an event to find with the @Output decorator.
      In our sample application, to improve the user experience
      we want to replace the rating number>displayed in the Product List Component with stars.
      In this module we'll build the Star Component
      and nest it within the Product List Component.
      Let's get started.</p>
    <h3>Building a Nested Component</h3>
    <p>Here is a visual representation
      of a component that is nest-able.
      Here is another component.>It wants to use the nest-able component in its template.
      We then refer to the outer component>as the container or parent component.
      And we refer to the inner component
      as the nested or child component.
      When building an interactive application
      the nested component often needs to communicate
      with its container.>The nested component receives information from its container
      using input properties,>and the nested component outputs information
      back to its container by raising events.
      In our sample application we want to change the display
      of the five-star rating from this to this.>Displaying the rating number using a visual representation
      such as stars makes it quicker and easier for the user
      to interpret the meaning of the number.
      This is the nested component we'll build in this module.
      For the Star Component to display
      the correct number of stars,>the container must provide the rating number
      to our Star Component as an input.
      And if the user clicks on the stars
      we want to raise an event to notify the container.
      Let's jump right in and build our Star Component.
      When we last saw our sample application
      we had completed the Product List Component.
      Now, of course, we want to change it.
      Instead of displaying a number for the rating here
      we want to display stars.>Instead of adding the code to the Product List Component
      to display the stars,>we want to build it as a separate component.
      This keeps the template and logic
      for that feature encapsulated and makes it reusable.
      So let's begin by creating a Star Component.
      The Star Component can be used>by any feature of the application,
      so it really doesn't belong in our Products folder,
      we'll instead put it in a shared folder
      where we'll put all our shared components.>If you are using the starter files
      I've already created this folder and included the template
      and style sheet for our component here.
      Now we are ready to build the Star Component.
      We begin by creating a new file.
      We'll name it "star.component.ts".
      We then create this component just like we'd create
      any other component, starting with the class.
      export class StarComponent.>What's next?>Yup, we decorate the class with the component decorator.
      Recall that it is this component decorator>that makes this class a component.
      As always, it shows as a syntax error here>because we're missing, yup, our import.
      Now, we're ready to set the component decorator properties.
      For the selector we don't want to use the pm prefix
      because this component could be reused
      anywhere in our company,>not just on the Product Management Application.
      We'll instead prefix the selector with an abbreviation
      for our company,>which in this case is "ai" for "Acme Inc".>For the templateurl we provide the path
      to the HTML file provided in our starter files.
      We add the styleurls property,>and in the array we'll set the first element
      to the path of the style sheet that was also provided.
      Now let's take a peek at the Star Component template.
      Here it displays five stars,>it then crops the stars based on a defined width.
      This technique can then display partial stars
      such as four and a half of the five stars
      by setting the width,>such that only four and a half of the stars appear.
      Recall what this syntax is called?
      This is property binding.>We're using it here to set the style width,>and here to bind the title property
      to display the numerical rating value.
      For theses bindings to work>we need two properties and the component's class,
      the rating and the star width.>Let's add these two properties.
      We want the rating property, which is a number
      and defines the rating value.
      Since we don't yet have a way to get this value
      let's hardcode it to four for now
      so we'll see some stars.>And we need the star width.>This value is calculated based on the rating.
      So, where do we put that calculation?
      Well, we'd want to start width recalculated>anytime the container changes the rating number,
      so let's tap into the OnChanges lifecycle hook
      as we discussed in the last module.
      We'll add OnChanges to the import statement.
      We'll implement the OnChanges interface
      and we'll write code for the ngOnChanges method,
      identified the OnChanges interface.
      In this method we'll convert the rating number
      to a star width based on the width of our stars.
      Our component is now complete and we're ready to nest it
      in another component.>How do we do that?</p>
    <h3>Using a Nested Component</h3>
    <p>Now we are ready to nest our new component>within another component.>We do that by using our nested component as
      a
      directive,
      and following the same steps>we covered earlier in this course.
      Here is a shorten form of the code for a container component
      and its template.>And here is the nested component we just created.
      Instead of displaying the star rating number
      we want to display the stars,
      so the container component uses the nested component
      by specifying its directive here.
      This identifies where in the container to place
      the nested component's template.
      As we've seen in prior demos,
      when we use a component as a directive
      we need to tell Angular how to find that directive.
      We do that by declaring the nested component
      in an Angular module.>How do we know which Angular module?>Well, you still only have one Angular module,
      AppModule,
      but if we had multiple modules we'd add it>to each Angular module that declares>a component that uses the
      directive.>In our example, the Product List Component's template
      wants to use the Star Component,
      so we add the declaration to the same Angular module
      that declares the Product List Component.
      We define the nested component in the declaration's array
      of the @NgModule decorator,>and as always, define what we need
      by adding an import statement.>Let's jump right back to our demo.
      Our Star Component is now shown here in the right.
      We want to use our Star Component
      in the Product List template>that is here on the left.>In the table data element we want to replace
      the display of the star rating number
      with our Star Component.>To do that we simply replace the binding
      with our ai-star directive.>Now our Product List template will display our stars here.
      Next we need to tell Angular where to find this directive.
      Since we only have one Angular module
      we'll add the declaration for the nested component there.
      Because we know by now that we'll need it,>we'll add the import for the Star Component first,
      then we add the Star Component to the declaration's array
      passed into the @NgModule decorator.>And since we imported the component first,>IntelliSense helps us here.>These
      are
      the same steps we followed earlier on this course
      to use a component as a directive.
      Nothing new here so far.>Let's see what we did.>We have stars! Yes!>Hmm, but we see five of them.
      Let's clear up the filter.>Yes, we see five every time.>Hover over the stars>and we see our hardcoded star rating
      is
      four.
      It seems that our star width is not being set.
      Let's look at the code again.
      We set the star width property in the ngOnChanges method
      when the OnChanges lifecyle event occurs,
      but the OnChanges lifecycle event never occurs
      because OnChanges only watches for changes>to input properties.>We don't have any input properties.
      So we have two problems here:
      our OnChanges event does not fire
      and we don't currently have a way to get the correct
      rating number from the container.
      Let's see how input properties can solve both of these issues.
    </p>
    <h3>Passing Data to a Nested Component Using @Input</h3>
    <p>If a nested component wants to receive input from its container,
      it must expose a property to that container.
      The nested component exposes a property it can use
      to receive input from its container
      using the aptly named "@Input" decorator.
      We use the @Input decorator to decorate any property
      in the nested component's class.
      This works with any property type, including an object.
      In this example, we want the rating number passed
      into the nested component,>so we mark that property with the @Input decorator.
      The container component then passes data
      to the nest component by setting this property
      with property binding.>When using property binding we enclose the binding target
      in square brackets, we set the binding source to the data
      that the container wants to pass to the nested component.
      In this example the Product List template
      passes the product's star rating number.
      The only time we can specify a nested component's property
      as a property binding target on the left side of an equals
      is when that property is decorated
      with the @Input decorator.>So in this example the Product List template
      can bind to the rating but not the star width.
      Let's give this a try.>Going back to our Star Component
      let's add @Input to our import statement
      'cause we know we're going to need it.
      The Star Component wants to expose the rating property
      to its container>so the container can provide the rating number.
      We'll add the @Input decorator then to the rating property.
      The @Input decorator is a function,
      so we add parenthesis.>We don't need to pass anything to this function,
      so that's it.>And let's remove this default value.>Now that we can get the value from the container
      we don't need that here.>In our example we decorate only one property
      of the nested component with the @Input decorator
      but we are not limited to one,>we can expose multiple input properties as needed.
      In the container's template we use property binding
      and define the nested component's input property
      as the target of the binding.
      Then we set the binding source to the value we want to pass
      into the nested component.>In this example, we pass the product's star rating.
      That's it, the product's star rating property
      is now bound to the rating input property
      of the nested component.>Anytime the container data changes,
      the OnChanges lifecycle event is generated>and the star width is recalculated,
      the appropriate number of stars are then displayed.
      Let's check it out in the browser.
      That looks better.>Well, we're not really displaying the .2 stars here,
      our algorithm could use some improvement,
      but you get the idea.>But, what if we want to send data back
      from our nested component to our container?>Let's look at that next.</p>
    <h3>Passing Data from a Component Using @Output</h3>
    <p>We just saw how the container passes data
      to the nested component>by binding to a nested component property
      that is decorated with the @Input decorator.
      If the nested component wants to send information
      back to its container, it can raise an event.
      The nested component exposes an event
      it can use to pass output to its container>using the aptly named "@Output" decorator.>We can use the @Output
      decorator
      to decorate
      any property of the nested component's class.
      However, the property type must be an event.
      The only was a nested component can pass data back
      to its container is with an event.
      The data to pass becomes the event payload.>In Angular an event is defined with an EventEmitter object,
      so here we create a new instance of an EventEmitter.
      Notice the syntax here.>TypeScript supports generics.
      If you are not familiar with generics,
      this syntax allows us to identify a specific type
      that the object instance will work with.
      When creating an EventEmitter, the generic argument
      identifies the type of the event payload.
      If we want to pass a string value to the container
      in the event payload, we define "string" here.
      If we want to pass an integer, we define "number" here.
      If we want to pass multiple values,
      we can specify an "object" here.
      In this example we define a notify event
      with a string payload.>When the user clicks on the stars
      the Star Component receives that click event,
      we use event binding in the Star Component template
      to call the Star Component's onClick method.
      In the onClick method we use the notify event property
      and call its emit method to raise the notify event
      to the container.>If we want to pass data in the event payload,
      we pass that data into the emit method.
      In this example the onClick method raises the notify event
      and sets the event payload to a string message.
      The container component receives that event>with the specified payload.>In the container component's template we
      use
      event binding
      to bind to this notify event and call a method.
      We access the event payload using "$event".>The only time we can specify a nested component's property
      as an event binding target on the left side of an equals
      is when that property is decorated
      with the @Output decorator.>Lastly, the container component provides the method
      to execute when the notify event occurs.
      Since the event payload is a string,>this function takes in a string.
      Here we can perform any desired action.
      Hmm, lots of moving parts here.
      Let's jump into the code and try it out.
      We are back in the sample application
      looking at the Star Component.>We'll add @Output and EventEmitter to our import statement
      because we know we're going to need 'em.
      We want to expose an event to the container,
      so let's define a ratingClicked event property.
      We define the type of this property to be EventEmitter,
      and we want the event payload to be a string,
      so we specify "string" as the generic argument.
      We set the ratingClicked property to new instance
      of EventEmitter.>We decorate this property with the @Output decorator
      to expose it so that the container
      can respond to this event.>The @Output decorator is a function so we add parenthesis.
      In this example we are decorating only one property
      of the nested component with the @Output decorator
      but we are not limited to one,>we can expose multiple output properties as needed.
      Moving to the template, we use event binding
      to bind the div element's clicked event
      to a local onClick method.>Then let's implement this onClick method in the component.
      When the Star Component processes
      the clicked event on the div,
      it wants to raise an event to the container>and pass along a message.>We use the event property and call its emit
      method
      passing in the desired string.>In this example, we use the ES2015 back text
      to define a template string,>this allows us to bind the rating directly into the string
      using dollar syntax.>Our Star Component is then complete.>Now, let's respond to this event in our container.
      The Product List Component wants to listen>for this ratingClicked event,
      so let's update the Product List template.>Here, in the nested component's directive,>we'll add event binding to
      respond
      to the ratingClicked event exposed by the Star Component,
      and we'll get the event payload.
      We'll respond by calling our own local method,
      we'll call it onRatingClicked.>The event payload is available using $event,
      so we pass that in to the onRatingClicked method.
      We then need to write code for this new method
      in the container's class.>In the Product List Component
      we define the onRatingClicked method.
      We'll add it on the bottom with our other methods.
      We define a "message: string" parameter
      for the event payload.>To keep things simple, we'll just modify the pageTitle
      to display "Product List">and the message from the nested component.>Okay, yeah, that is not a very real world
      example
      but I wanted to keep this as straightforward as possible.
      We'd have a better example>if the nested component contained an input box
      and we could pass the user's input in the event payload,
      but you get the general idea here.
      Let's see how this works in the browser.
      We'll clear filter by,>click on the star rating,>and we see the page title changed to display the message
      received from the nested component.
      Success!>We just saw how the container passes data
      to the nested component>by binding to a nest component property
      that is decorated with the @Input decorator,
      and how the nested component uses an event property
      decorated with the @Output decorator to raise events.
      We can think of the properties decorated
      with the @Input or @Output decorators
      as a public API of the nest-able component.>Everything else in the component is encapsulated
      and only accessible to the component's template and class.
      Let's finish up this module with some checklists we can use
      as we build nest-able components.
    </p>
    <h3>Checklists and Summary</h3>
    <p>We build a nested component using the same techniques
      we use to build any other Angular component.
      We won't review that again here,
      let's instead lay out a checklist for inputs and outputs.
      Decorate a nested component property>with the Input decorator any time it needs input data
      from its container.>Any type of component property can be decorated
      with the Input decorator.>Don't forget the @ prefix,>and since the Input decorator is a function,
      follow it with opening-closing parenthesis.>Decorate a nested component property>with the Output decorator anytime
      it
      needs to raise events
      and optionally pass information back to its container.
      Only properties of type EventEmitter should be marked
      with the Output decorator.>Use the EventEmitter's generic argument to specify
      the type of the event payload.>And use the "new" keyword to create an instance
      of the EventEmitter.>Don't forget the @ prefix,>and since the Output decorator is a function
      suffix it with opening-closing parenthesis.>In a container component's template
      use the nested component as a directive.
      For the name of the directive
      see the nested component's selector property.
      Use property binding to pass data to the nested component.
      Any property of the nested component that is decorated
      with the Input decorator can be used as a binding target.
      Use event binding to respond to events
      from the nested component.>Any event that is decorated with the Output decorator
      can be used as the binding target.
      And use $event to access the event payload>passed from the nested component.
      This module was all about nested components.
      We began by building a component that could be nested
      within other components.>We then walked through how to use the nested component
      within a container.>We saw how to pass data into the nested component
      by binding to a property marked with the Input decorator.
      And we discovered how to pass data
      out of the nested component by raising an event
      marked with the Output decorator.
      In this module we built the Star Component>and nested it within the Product List Component.
      We can reuse this component>in any other component of the application
      such as the Product Detail Component.
      Next up, let's check out how to build an Angular service
      so we won't need hardcoded product data in our component.
    </p>

    <h2>Services and Dependency Injection</h2>
    <h3>Introduction</h3>
    <p>Components are great and all, but what do we do with data or logic
      that is not associated with a specific view or that we want to share across components?
      We build services.>Welcome back to Angular 2: Getting Started,>from Pluralsight.>Deborah Kurata here, at your
      service.
      And in this module, we create a service
      and use dependency injection to inject that service
      into any component that needs it.
      Applications often require services,>such as a product data service or a logging service.
      Our components depend on these services
      to do the heavy lifting.>Wouldn't it be nice if Angular>could serve us up those services on a platter?
      Well, yes it can.>But what are services, exactly?
      A service is a class with a focused purpose.
      We often create a service to implement functionality
      that is independent from any particular component,
      to share data or logic across components,
      or encapsulate external interactions, such as data access.
      By shifting these responsibilities from the component
      to a service, the code is easier to test, debug, and reuse.
      In this module, we start with an overview
      of how services and dependency injection work in Angular.
      Then we'll build a service, we'll register that service,
      and we'll examine how to use the service in a component.
      We currently have several pieces
      of our application in place, but we hard coded our data
      directly in the product list component.
      In this module, we'll shift the responsibility
      for providing the product data to a product data service.
      Let's get started.</p>
    <h3>How Does It Work?</h3>
    <p>Before we jump into building a service,
      let's take a look at how services
      and dependency injection work in Angular.
      In this diagram, our service is here,
      and our component that needs the service is here.
      There are two ways our component
      can work with this service.>The component can create an instance>of the service class and use it.
      That simple, and it works.>But the instance is local to the component,>so we can't share data or other
      resources,>and
      it will be more difficult to mock the service
      for testing.>Alternatively, we can register this service with Angular.
      Angular then creates a single instance
      of this service class, called a singleton,>and holds onto it.>Specifically, Angular provides a built-in injector.
      We register our services with the Angular injector,
      which maintains a container of created service instances.
      The injector creates and manages the single instance,
      or singleton, of each registered service as required.
      In this example, the Angular injector
      is managing instances of three different services,
      log, math, and myService,>which is abbreviated svc.>If our component needs a service,
      the component class defines the service as a dependency.
      The Angular injector then provides, or injects,
      the service class instance>when the component class is instantiated.
      This process is called dependency injection.
      Since Angular manages the single instance,>any data or logic in that instance
      is shared by all of the classes that use it.
      This technique is the recommended way to use services,
      because it provides better management of service instances.
      It allows sharing of data and other resources,
      and it's easier to mock the services for testing purposes.
      Now, let's look at a more formal definition>of dependency injection.>Dependency injection is a coding pattern
      in which a class receives the instances
      of objects it needs, called its dependencies,
      from an external source rather than creating them itself.
      In Angular, this external source is the Angular injector.
      Now that we've got a general idea of how services
      and dependency injection work in Angular, let's build a service.
    </p>
    <h3>Building a Service</h3>
    <p>Are we ready to build a service?
      Here are the steps.>Create the service class,>define the metadata with a decorator,
      and import what we need.>Look familiar?>These are the same basic steps we followed>to build our components and our
      custom pipe.
      Let's look at the code for a simple service.
      Here is the class.>We export it so this service can be used
      from any other parts of the application.
      This class currently has one method, getProducts.
      This method returns an array of products.
      Next, we add a decorator for the service metadata.
      When building services,>we often use the Injectable decorator.
      This decorator is only really required here>if the service itself has an injected dependency.
      However, it is recommended that every service class
      use the Injectable decorator for clarity and consistency.
      Lastly, we import what we need.
      In this case, Injectable.>Now, let's build our service.
      I've opened the folder for the sample application
      and the editor once again.>Since our service will only provide product data,
      we'll add it to the Products folder.>We'll create a new file and call it product.service.ts,
      to follow our naming conventions.
      We're then ready to create the service class.
      I bet you can do it in your sleep by now.
      Export, class, and the class name.
      Since the service provides products,>we'll call it ProductService.
      Next, we decorate the class with the Injectable decorator.
      And we'll add the import statement for that decorator.
      As we discussed earlier, this decorator is optional,
      unless the service has an injected dependency of its own,
      but it is good practice to add it to every service,
      so we added it here.>Now that we have the structure in place,
      we can add properties or methods to the class as needed.
      Unless marked private or protected,
      the properties and methods defined in the class
      are accessible to any class that uses this service.
      For our product service, we want a getProducts method
      that returns the list of products.
      We strongly typed this return value
      using our IProduct interface.
      So we need to import this interface.>In the next module, we'll see how
      to retrieve the products using HTTP.>For now, we'll hard code them in here.
      If you're coding along, feel free to copy some products
      from the products.json file in the API products folder.
      Notice that we have no properties defined in this class,
      so we are not using this particular service to share data.
      We are using it to encapsulate the data access features.
      By using this service to provide the list of products,
      we take the responsibility for managing the data
      away from the individual component.
      That makes it easier to modify or reuse this logic.
      So we're done with our service for now.
      How do we use it?>Well, a service is just really an ordinary class
      until we register it with an Angular injector.
      Let's do that next.</p>
    <h3>Registering the Service</h3>
    <p>As illustrated in this diagram,
      we register the service with an Angular injector,
      and the injector provides the service instance
      to any class that defines it as a dependency.
      So what's actually involved with registering a service
      with the injector?>To register a service, we must register a provider.
      A provider is code that can create or return a service,
      typically the service class itself.
      How do we register a provider?>We define it as part of the component
      or Angular module metadata.>If we register a provider in a component's metadata,
      the Angular injector can inject this service
      into the component and any of its children.>So we should take care to register the provider
      at the appropriate level of the application component tree.
      If we register a provider in an Angular module,
      the service is registered with the Angular injector
      at the application's root, making the service available
      everywhere in the application.>We'll talk more about registering a service provider
      in an Angular module when we cover Angular modules in detail
      later in this course.>For now, we'll focus on registering a service
      with a component.>If we register the provider for the product data service
      in the product list component,>the Angular injector can inject the service>into the product list component and any
      of
      its children.
      It could not inject the service
      into the product detail component,
      unless we registered the provider again
      in the product detail component.
      Note that if we did register the provider
      for the service twice, we would no longer have a singleton.
      The Angular injector>would manage two instances of the service,>one for the product list component and its
      children,
      another for the product detail component and its children.
      If instead, we register the provider>in the root app component,>the Angular injector can inject the service>into
      any
      component of the application.
      Since we know the product detail component>will also need the product data service,
      let's register it at the root.>Here is the app component we built early on in this course.
      To register a provider that creates our service,
      we add the providers property to the component decorator.
      The providers property is an array,
      so we could register multiple providers.
      To register a provider for our product service,
      we specify ProductService here, and import it here.
      Let's do that now.>Here is the app component.>In the metadata, we'll add the providers property,
      and specify our product service.
      So we, of course, need to import our product service.
      An instance of the product service
      is then available for injection in the app component
      or any of its child components.
      Now, we can specify where we need this service to be injected.
    </p>
    <h3>Injecting the Service</h3>
    <p>Here, again, is our diagram.>In the last clip, we saw how to register the service
      with the Angular injector.>Now, we just need to define it as a dependency
      so the injector will provide the instance
      in the classes that need it.>So, how do we do dependency injection in Angular?
      Well, the better question is,
      how do we do dependency injection in TypeScript?
      The answer is, in the constructor.
      Every class has a constructor that is executed
      when an instance of the class is created.
      If there is no explicit constructor defined for the class,
      an implicit constructor is used.
      So far, we have not needed an explicit class constructor,
      but if we want to inject dependencies,
      such as an instance of a service,
      we need an explicit constructor.
      In TypeScript, a constructor is defined
      with a constructor function.>What type of code normally goes
      into the constructor function?>As little as possible.>Since the constructor function is executed>when the
      component is
      created,>it is primarily used for initialization,
      and not for code that has side effects
      or takes time to execute.>We identify our dependencies>by specifying them as parameters
      to the constructor function, like this.
      Here, we define a private variable
      to hold the injected service instance.
      We create another variable as the constructor parameter.
      When this class is constructed,
      the Angular injector sets this parameter
      to the injected instance of the requested service.
      We then assign the injected service instance
      to our local variable.>We can then use this variable anywhere in our class
      to access service properties or methods.
      This is such a common pattern
      that TypeScript defined a shorthand syntax>for all of this code.>We simply add the accessor keyword, such as
      private
      here,
      to the constructor parameter.
      Then, this is the shortcut for declaring this variable,
      defining a parameter, and setting the variable
      to the parameter.>Neat.>You'll see this technique used>throughout the Angular documentation>and other code
      examples.>Ready to give it a try?>We want to use our service to get products>in the product list component,>so
      we'll
      define our product service as a dependency
      in the product list component.>We don't have to add the providers array here,
      because the product service is already registered
      in the app component, which is the parent of this component.
      All we need is a constructor.
      The constructor is normally defined
      after all of the properties.>So we'll add it here.>We'll use the shorthand syntax to define the dependency,
      private_productService.>We use an underscore here to denote
      that this is a private variable.
      Then, because we are using TypeScript,
      we type colon and the type, which is ProductService.
      Note that the accessor doesn't have to be private.
      This shorthand syntax works with public
      and protected as well.>So, now we have a syntax error here.>I bet you know why.>Yep, we need to import
      ProductService
      so we can use it as the data type here.
      Now, when an instance>of the product list component is created,
      the Angular injector injects in
      the instance of the product service.>We are at the point now where we can actually use
      the product service.>First, let's delete the hard coded products from here.
      We'll instead get them from the service.
      Now, the question is, where should we put the code
      to call the service?>One thought might be to put in the constructor.
      But, ultimately, our product service>will go out to a back-end server to get the data.
      We don't want all of that executed in the constructor.
      Other thoughts?>Remember our discussion about lifecycle hooks?
      Earlier in this course,>we said that the OnInit lifecycle hook
      provides a place to perform any component initialization.
      And it's a great place to retrieve the data>for the template.>Let's use the OnInit lifecycle hook.>We want to set
      the
      product's property
      to the product's return from our service.
      To call the service, we use our private variable
      containing the injected server instance,
      this._productService.>We then type a dot, and the name of the method
      we want to call.>Notice how IntelliSense helps us with all of this.
      Let's make one more little change.
      Let's remove the default list filter value,>so we'll see all of the products in the list.
      We should be all set to see our result in the browser.
      And here are our products.>Yay.>Notice that we have more products displayed now
      because I hard coded more products into the service.
      Let's finish up this module with some checklists
      we can use as we build our services.
    </p>
    <h3>Checklists and Summary</h3>
    <p>We build a service using the same techniques
      as when we build components and custom pipes.
      We start by creating the service class.
      We specify a clear class name,>appropriate for the services it provides.
      Use PascalCasing,>where each word of the name is capitalized.>Append Service to the name,>and don't forget the
      export
      keyword.>We then decorate the service class
      with the Injectable decorator.>Don't forget the @ prefix,>and since the decorator is a function,
      follow it with open and closing parenthesis.
      This particular decorator is not always required,
      but it is a good practice to add it.>And be sure to define the appropriate imports.
      We can register a service in a component
      or in an Angular module.>We'll talk more about registering services>in Angular modules later in this course.
      When using a component,>the first step to registering the service
      is to select the appropriate level
      in the component hierarchy>that the service should be registered.
      Use the root app component>if the service is shared throughout the application.
      If only one component needs the service,
      register it directly within that component.>Otherwise, select a common ancestor
      of the components that need the service.
      In the selected component's metadata,
      use the providers property to register the service.
      Pass the service provider as an element of an array,
      and be sure to define the appropriate imports.
      In any class that needs the service,>specify the service as a dependency.>Use a constructor parameter to define
      the
      dependency.
      The Angular injector will inject an instance
      of the service when the component is instantiated.
      This module was all about services.
      We began with an overview of how services
      and dependency injection work in Angular.
      Then we walked through how to build a simple service.
      We defined how and where to register the service
      with Angular, and we examined how to define the service
      as a dependency, so the service instance is injected
      into any class that needs it.
      In this module, we built the product data service
      and registered it with the app component,
      so our product list component
      no longer has hard coded products.
      Next up, we'll see how to modify the service
      to retrieve data using HTTP.</p>


    <h2>Retrieving Data Using HTTP</h2>
    <h3>Introduction</h3>
    <p>The data for our application is on a server>somewhere in cloud, at the office, under our desk.
      How do we get that data into our view?
      Welcome back to Angular 2 getting started from Pluralsight.
      My name is Deborah Kurata, and in this module
      we learn how to use Http with observables to retrieve data.
      Most Angular applications obtain data using Http.
      The application issues an Http get request to a web service.
      That web service retrieves the data, often using a database,
      and returns it to the application in an Http response.
      The application then processes that data.
      In this module, we begin with an introduction to observables
      and the reactive extensions.>We then examine how to send an Http request and map
      the result to an array.>We add some exception handling, and we look at how
      to subscribe to observables to get the data for our view.
      We finished the first cut of a product data service
      in the last module, but it still has hard-coded data.
      Now we'll replace that hard-coded data with Http calls.
      Let's get started.</p>
    <h3>Observables and Reactive Extensions</h3>
    <p>Observables help us manage asynchronous data,
      such as data coming from a backend service.>Observables treat events as a collection.
      We can think of an observable as an array
      whose items arrive asynchronously over time.
      On the timeline to the left, the first marble comes in,
      then the second, and some time later the third.
      Observables are a proposed feature for ES 2016,
      the next version of JavaScript.
      To use observables now, Angular uses a third-party library
      called reactive extensions.>Don't confuse this with React,>which is another thing entirely.
      Observables are used within Angular itself,>including Angular's event system
      and its Http client service,>which is why we are covering them here.
      Observables allow us to manipulate sets of events
      with operators.>Operators are methods on observables that compose
      new observables.>Each operator transforms the source observable in some way.
      Operators do not wait for all of the values>and process them at once.>Rather, operators on observables process
      each
      value
      as it is emitted.>Some examples of operators include map, filter,
      take, and merge.>Data sequences can take many forms,
      such as a response from a backend web service,
      a set of system notifications, or a stream of events,
      such as user input.>In this diagram, our stream contains three elements.
      Reactive extensions represent a data sequence as an
      observable sequence, commonly just called an observable.
      A method in our code can subscribe to an observable
      to receive asynchronous notifications as new data arrives.
      The method can then react as data is pushed to it.
      The method is notified when there is no more data
      or when an error occurs.>Observables support operators, such as the map operator.
      The map operator allows us to transform the incoming data.
      The argument to the map operator is an arrow function
      that says to take each data item and transform it
      to 10 times its value.>So when we receive one, it is mapped to 10.>When we receive two, it is mapped to 20, and so
      on.
      This depiction is called a marble diagram
      and is helpful for visualizing observable sequences.
      This is a screenshot from Rxmarbles at this URL.
      You may have worked with asynchronous data>in JavaScript previously using promises.
      Observables are different from promises in several ways.
      A promise returns a single future value.
      An observables emits multiple asynchronous values over time.
      A promise is not lazy.>By the time you have a promise, it's on its way
      to being resolved.>An observable is lazy by default.
      Observables will not emit values
      until they are subscribed to.
      A promise is not cancellable.
      It is resolved or rejected and only once.
      An observable can be cancelled by unsubscribing.
      Plus an observable supports map, filter, reduce,
      and similar operators.>Note, however, that you can use promises
      instead of observables when calling Http in Angular if you wish.
      An example is provided in the Angular documentation.
      In this module, we'll do Http using observables.
    </p>
    <h3>Sending an HTTP Request</h3>
    <p>We often encapsulate the data access for our application
      into a data service that can be used by any component
      or other service that needs it.
      In the last module, we did just that,
      but our product data service still contains a hard-coded
      list of products.>We instead want to send an Http request to get the products
      from a backend web server.>Angular provides an Http service that allows us
      to communicate with a backend web server.
      Using the familiar Http request and response protocol.
      For example, we call a get method of the Http service,
      which in turn sends a get request to the web server.
      The web server response is returned from the Http service
      to our product data service as an observable.
      What does this look like in code?
      This is the product service we built in the last module
      modified to retrieve the products
      using Angular's Http service.
      Let's walk through this code.
      First we specify a URL to the products on the web server.
      This defines where we send our Http requests.
      Note that this URL is shown for illustration purposes only
      and is not a real URL.>Next we add a constructor.>Recall from the last course module that we use a constructor
      to inject dependencies.>In this case, we need Angular's Http service,
      so we inject it here.>Recognize this syntax?>It creates a private_http variable and assigns
      the injected service instance to that variable.
      And since we are strongly typing this variable to Http,
      we import Http from the @angular/http package here.
      As a side note, we had mentioned earlier that in some cases
      the injectable decorator was optional.
      Now that our product service has an injected dependency,
      the injectable decorator is required.
      Recall also from the last course module
      that before we can inject a service in as a dependency,
      we need to register that service's provider>with Angular's injector.>The Http service provider registration is
      done
      for us
      in the Http module included in the @angular/http package.
      To include the features of this external package
      in our application, we add it to the imports array
      of our application's Angular module, AppModule.
      Recall that the declarations array is for declaring
      components, directives, and pipes that belong
      to this module.>The imports array is for pulling in external modules,
      so we use the imports array to pull in
      this external HttpModule.>Now our Angular module illustration looks like this.
      We declare our components.>We declare the directives and pipes that
      those components require, and we import the external
      modules that we need.>And for Http, we need HttpModule.
      Going back to the product service,
      in getProducts we use the injected Http service instance
      and call the get method, passing in the desired URL.
      The Http service then sends a get request
      using the specified URL.>But what does this method now return?
      Since we are using strong typing, we should have a function
      return value here.>The getProducts method returns an observable of Response.
      Does this generic syntax look familiar?
      We used it earlier in this course to define>the event payload when passing event information
      from a nested component to its container.
      Observables take advantage of generics to define
      the type of data it is observing in the observable sequence.
      In this case, it's the Http Response.
      It's important to note that Http calls
      are single asynch operations,
      meaning that the observable sequence contains
      only one element, which is the Http Response object.
      And we need to import Response>from the @angular/http package>and observable from rxjs/Observable.>But let's think
      about this return value for a moment.
      Do we really want an observable of Response?
      Our components, such as the product list component,
      are expecting to receive a list of products,
      not an Http response.>So we need to translate the Response object>to an array of products.>We do that with the map
      operator.
      The map operator takes the raw Http Response object
      returned from the Http get method and translates it
      into an array of products.>The argument to the map method is an arrow function
      that transforms the response to a JSON object.
      We use a casting operator to cast the JSON object
      to an array of products.>So now our getProducts returns an observable
      of IProduct array, which is much more useful
      for our components.>Note that depending on your server, the JSON result
      may be wrapped in another property, such as a data property.
      If that is the case, use response.json.data here.
      To use the map operator, we need to load it>using an import statement.>Using the import statement like this is a
      bit
      unusual.
      It tells the module loader to load this library
      but actually doesn't import anything.
      When a library loaded, its JavaScript is executed,
      and for this particular library, executing the JavaScript
      loads the map operator.>So this particular syntax imports the module
      for its side-effects only, without actually importing
      any of its features.>Now let's add Http to our product service.>We are looking at our applications Angular module
      we called AppModule.>Recall from the slides that Angular registers
      its Http service provider in an Angular module
      called HttpModule.>In our application's Angular module,>we import the HttpModule.>This module is located in the
      @angular/http package.
      We then pull that module into our application
      by adding HttpModule to the imports array here.
      Now we can inject the Angular Http service>into any class that needs it.
      Here is the product data service we created>in the last module with all of the hard-coded data.
      We want to modify our product service
      to get the product data using Http.
      Let's start at the top with the import statements.
      We import the Http client service and the Http Response
      from @angular/http.>We important observable from rxjs/Observable.
      And we import the map operator using the special syntax
      that loads the operator without actually importing anything.
      We want Angular to provide us an instance
      of the Http client service,>So we identify it as a dependency in the constructor.
      We don't have a constructor yet, so let's add that first.
      Then we specify the parameter.>Angular will then inject the Http client service instance
      into this variable.>Now we need to identify the location of our web server.
      Hmm, this doesn't look like a valid URL to a web server.
      To keep things simple, the demonstration reads the data
      from a local JSON file that was provided
      with the starter files.>That way we don't need to set up an actual web server.
      To change this code to work against a web server,
      simply change this URL to point to an appropriate
      web server.>And, of course, you need to write the server-side code
      to return the list of products.
      It's finally time to delete our hard-coded data.
      So let's delete the hard-coded products
      from the getProducts method.>Gone.>We'll call the http.get method here instead,
      passing in the defined URL.>When we get a response back, we use the map operator
      to map the Http response to a product array>using response.json.>We'll need to change the return type as well.
      Now this method returns an observable of IProduct array.
      We can't try this out at this point,>because we are not yet subscribing to the observable
      returned from the service.>Let's add some exception handling first,
      then modify the product list component to subscribe
      to the observable list of products.
    </p>
    <h3>Exception Handling</h3>
    <p>As you can imagine, there are many things that can go wrong
      when communicating with a backend service.>Everything from an invalid request to a lost connection.
      So let's add some exception handling.
      We'll add a catch and pass it the name
      of an error-handling method.>The error-handling method gets one parameter,
      the error: Response object.>In that method, we can handle the error as appropriate.
      We can send the error information
      to the remote logging infrastructure or throw an error
      to the calling code.>And notice here one more thing, the observable
      has a do operator that allows us to peek at the data
      returned from the server without disrupting the flow.
      We can use this operator when debugging to log data
      to the console, for example.>Notice we also need two more import statements,
      one for each additional operator we are using.
      Now let's add exception handling to our product service.
      This code is not really complete
      without the exception handling.
      So we'll add the appropriate imports and use
      the catch operator to call a local handleError method.
      In this method, we can log or handle errors any way we want.
      For our sample application, we simply log to the console
      and throw an error to the calling code.
      Let's also try out the do operator.
      The do operator lets us peek at the response data.
      We use JSON.stringify to display that data>in a nicer format.>So our getProducts method is complete.
      We can add other methods here to post or put data as well.
      We can't see the result of our hard work yet
      because we are not subscribing to this observable.
      Let's do that next.</p>
    <h3>Subscribing to an Observable</h3>
    <p>If you are familiar with promises,
      you know that you receive the result of the promise,
      X in this illustration, by calling then.
      Then takes two arguments, a value function that is called
      when the promise completes successfully
      and an error function to handle any error condition.
      If we define X as an observable instead,
      we simply replace the then with subscribe.>Since observables handle multiple values over time,
      the value function is called for each value>the observable emits.>In some cases, we want to know>when the
      observable
      completes, so observables provide
      an optional third handler that is executed on completion.
      The subscribe function returns a subscription.
      We could use that subscription to call unsubscribe
      and cancel the subscription if needed.
      Now that our product data service is returning
      an observable, any class that needs product data,
      such as our product list component, can call our service
      and subscribe to the returned observable like this.
      As we stated earlier, observables are lazy.>An observable doesn't start emitting values>until subscribe is called,
      so
      this line of code
      calls the product data service getProducts method
      and kicks off the Http get request.
      It is then set up to asynchronously receive data
      and notifications from the observable.
      The first function passed to the subscribe method
      specifies the action to take whenever the observable
      emits an item.>The method parameter is that emitted item.>Since Http calls are single asynch operations,
      only one item is emitted, which is the Http response object
      that was mapped to our product array in the service.
      So the parameter is our array of products.>This code then sets the local products property
      to the returned array of products.
      The second function is executed if the observable fails.
      In this example, it sets a local error message variable
      to the returned error.>A third function not used here specifies the action
      to take when the observable ends
      with a completed notification.>The third function is rarely used when working
      with Http requests since they automatically complete
      after emitting the single response.
      And we aren't using the return value here
      since we have not provided an option for the user
      to cancel the request.>Let's give this a try.>Here in the product list component, we see a syntax error.
      Type observable of IProduct array is not assignable
      to IProduct array.>Now that we've changed the product service>to return an observable, we cannot assign the result
      to our product property directly.
      Rather, we subscribe to the returned observable.
      When the observable emits the data, we set our
      product property to the returned array of products.
      And since that product property is bound
      in the components template,>the retrieved data just appears in the view.
      But things don't always go as expected.
      To handle any errors, let's add an error message property.
      If our request for products fails, our error message
      property is set to the error.
      What is this any syntax?>This is a casting operator.>We are casting the error returned from the observable
      to the any data type.>Are we ready to try it out?>There are our products.>Success.>We have more products here now
      because we are retrieving
      the products form the provided product.json file.
      Sweet.>Remember the do we added to the Http get pipeline?
      It displays the retrieved data.
      If we open the F12 developer tools,
      we see that data in the console here.
      So the recommended way to use Http is to encapsulate it
      in a service like our product service,
      then expose an observable for use by any class
      that needs product data.>The class simply subscribes to the observable
      and waits for data or a notification.
      Let's finish up this module with some checklists
      we can use as we work with Http and observables.
    </p>
    <h3>Checklists and Summary</h3>
    <p>Before we can use Angular's Http client service,
      some setup is required.>We need to ensure that the service prodiver>is registered with the Angular injector.
      This registration is done for us in the Http module
      included in the Angular Http package.
      So all we need to do is pull the Http module
      into our application.>We do this by adding Http module to the imports array
      of one of our application's Angular modules.
      Build a data access service to wrap Http requests.
      In that data service, specify the needed imports,
      define a dependency for the Angular Http client service
      using a constructor parameter.>Create a method for each Http request.
      In the method, call the desired Http method, such as get,
      and pass in the URL to the desired server.>Use a map operator to transform the raw Http response
      to a JSON object.>And do error handling as desired.
      In any class that needs data from a data service,
      call the subscribe method to subscribe to the observable.
      Provide a function to execute when the observable
      emits an item.>This often assigns a property to the returned JSON object,
      and if that property is bound to a template,
      the retrieved data appears in the view.
      And add an error function to handle any returned errors.
      This module was all about Http and observables.
      We began with an overview of observables
      and reactive extensions.>We examined how to build a data access service
      that sends requests for data over Http.
      We walked through how to set up some basic>exception handling, and we saw how to subscribe
      to the returned observable and ultimately display
      the resulting data in the view.
      We've now removed the hard-coded data
      from the product data service.>Yay.>And instead retrieved the data using Http.>In our sample application, we are
      using
      Http
      to retrieve the data from a local JSON file.
      But the techniques are the same for retrieving data
      from a backend service.>Next up, we'll see how to display multiple pages
      with navigation and routing.</p>


    <h2>Navigation and Routing Basics</h2>
    <h3>Introduction</h3>
    <p>A single view does not an application make.>Welcome back to Angular Two, Getting Started from Pluralsight.
      My name is Deborah Kurata and in the next two modules
      we define routes to navigate between multiple views
      in our application.>Users like to have all of the information they need
      at their fingertips, so our applications often provide
      multiple sets of data in multiple layouts
      across multiple views.>Routing provides a way for the user to navigate
      between those many views of the application,
      whether there are five, 10, or hundreds.
      In this module, we start with an overview
      of how routing works in Angular.
      We examine how to configure routes and tie routes to actions
      and we define where to place the router component's view.
      Currently, our app component embeds our Product List
      Component as a Nested Component.
      We instead want to define a set of routes so the user
      can navigate to the welcome view, product list view,
      or product detail view.>We've already built the Product List Component
      and I've provided the Welcome Component
      with the starter files in the Github Repository for this course.
      As part of the demos in this module, we'll build the shell
      for the Product Detail Component.
      When we're finished with this module, we'll have
      a simple application that routes to multiple views.
    </p>
    <h3>How Routing Works</h3>
    <p>An Angular application is a single page application.
      That means all of our views are displayed within one page,
      normally defined in the index.html file.
      So each of the five, ten, or hundreds of views
      take turns appearing on that one page.
      How do we manage which view to display when?
      That's the purpose of routing.>We configure a route for each component that wants
      to display its view on the page.
      As part of our application design, we provide a menu,
      a toolbar, buttons, images, or data links
      that allow the user to select the view to display.
      We tie a route to each option or action.
      When the user selects the option or performs the action,
      the associated route is activated.
      Activating a component's route displays
      that component's view.>So for example, the user selects a menu option
      to display the product list.>The product list route is activated
      and it displays its view.>Hmm, let's look at that process again with an illustration.
      Here is the menu that we'll add to our sample application.
      We tie a route to each menu option using a built-in
      router directive called Router Link.>When the user clicks on the product list option for example,
      the Angular router navigates to the product's route.
      The browser's location URL changes to match this path
      segment and we see slash products appear in the address bar.
      By default, Angular uses html five style URLs
      which don't require the hash symbol
      to indicate local navigation.
      By using the hmtl five style URLs, you need to
      configure your web server to perform URL rewriting.
      How this is done depends on your web server.
      See the documentation for your web server
      on how to configure URL rewriting.
      Angular also supports hash style routing
      which does not require URL rewriting.
      We'll look at how to use hash style routing>later in this module.>When the browser's URL changes, the Angular
      router
      looks for a route definition matching the path segment,
      Products in this example.>The route definition includes the component to load
      when this route is activated.
      In this case, the Product List Component.
      The Angular router loads the components template.
      Where does it display this template?>Where we specified with the built-in routing directive
      called Router Outlet and the Product List appears.
      So that's how routing works.>We'll examine these steps in further detail and try
      them out in demos as we journey through this course module.
      But first, let's add in these two missing components.
      I provided the Welcome Component
      as part of the starter files>so we only need to build the Product Detail Component.
      The Product Detail Component should ultimately
      look like this but we want to focus on routing,
      not building another component, so let's just create a shell
      for the Product Detail Component so we can route to it.
      In the Products folder, create a new file
      called Product dash detail dot component dot ts
      and a new Template called>product dash detail dot component dot html.>In the html file, put some placeholder
      text>and
      use interpellation to bind a page title>so we'll have something to display on the page.
      We'll see this in action a little later.
      Now how about the component?>Recall how to build the basics of a component?
      Consider pausing the video now and creating a first cut
      of the Product Detail Component with a page title
      and product properties.>Continue the video when you want to see my solution.
      Here's what I came up with for the first cut of
      the Product Detail Component.
      We import the component decorator.
      We import the I product interface so we can use it
      as the data type of our product property.
      We export the Product Detail Component class.
      We define properties for the page title and product
      and we decorate the class with the component decorator
      defining our view using template URL.
      Is this close to what you came up with?
      Notice that I don't have a selector property here.
      The selector property is only required if the component
      will be nested within another component
      and we don't need to nest this component.
      We'll instead display the component's view>as part of routing.>There is one more step here we need to take.
      Any idea what it might be?>Every time we add a component to the application,
      we need to declare that component in an Angular module.
      We currently only have one Angular module, AppModule.
      So we'll add the Product Detail and Welcome Component
      to the declaration's array for the app module.
      Let's do that now.>Here we are, looking at the app module.
      We first import the Welcome Component
      and the Product Detail Component.
      Then we add them both to the declarations array.
      With that, we are ready to add routing to our application.
    </p>
    <h3>Configuring Routes</h3>
    <p>Routing is component-based, so we identify the set
      of components that we want to provide as routing targets
      and define a route for each one.
      Let's see how this is done.>An Angular application has one router that is managed
      by Angular's router service and we know that before
      we can use that service, we need to register the
      service provider in an Angular module,
      similar to the http module, Angular provides
      a RoutherModule in the Angular router package
      that registers the router service provider.>To include the features of this external module
      in our application, we need to add it
      to the imports array of our application's Angular module.
      In addition to registering the router service provider,
      the RoutherModule also declares the router directives.
      In the last clip we mentioned two router directives,
      router link and router outlet.>By importing the RoutherModule, our component templates
      can use these or any other router directive.
      RoutherModule also exposes the routes we configure.
      Before we can navigate to a route, we need to ensure
      that the routes are available to the application.
      We do this by passing the routes to RoutherModule like this.
      We call the RoutherModules forRoot method
      and pass our array of routes to that method.
      This establishes the routes for the root of our application.
      If we want to use hash style routes
      instead of html five style routes, we change this code
      to set useHash as shown here.
      With that, we are ready to configure some routes.
      The router must be configured
      with a list of route definitions.
      Each definition specifies a route object.
      Each route requires a path.>The path property defines the URL segment for the route.
      When this route is activated, this URL path segment
      is appended to the URL of our application.>The user can type in or bookmark the resulting URL
      to return directly to the associated components view.
      In most cases we also specify a component,>which is the component associated with the route.
      It is this component's template that is displayed
      when the route is activated.>These are all examples of route definitions.
      The first route simply maps a specific URL path segment
      to a specific component.>So this URL displays the template
      from the Product List Component.
      The colon ID in the second route represents>a route parameter.>The Product Detail Page displays the detail for one
      product
      so it needs to know which product to display.
      The Product Detail Component reads the ID
      from this path segment and displays the defined product.
      We can define any number of parameters here>separated wit slashes.>What does this route do?>Yep, this URL displays
      the
      template
      from the Welcome Component.>This one defines the default route.
      The redirect here translates the empty route
      to the desired default path segment.>In this example, the welcome route.
      A redirect route requires a path match property
      to tell the router how to match the URL path segment
      to the path of a route.>We only want this default route when the entire
      clan side portion of the path is empty,
      so we set the path match to full.
      The asterisks in the last route denote a wildcard path.
      The router matches this path if the requested URL
      doesn't match any prior paths defined in the configuration.
      This is useful for displaying a 404 Not Found Page
      or redirecting to another route.
      A few things to note here.>There are no leading slashes in our path segments
      and the order of the routes in this array matters.
      The router uses a first match win strategy>when matching the routes.>This means that more specific routes should
      always be
      before less specific routes, such as the wildcard route.
      Ready to try this out?>We are back in the sample application
      with index.html file open.>We want to add a base element just after the head tag.
      This element tells the router how to compose
      the navigation URLs.>Since the app folder is the application route,
      we'll set the hRef for the base tag to slash.
      Now we are ready to configure the route definitions.
      For that, we go to our Angular module, add the appropriate
      import statement, then add RoutherModule
      to the imports array.>This registers the router's service provider,
      declares the router directives,
      and exposes the configured routes.
      How does the RoutherModule know about our configured routes?
      We pass them into the RoutherModule
      by calling forRoot method.>We then can figure the routes here by passing them in
      using an array.>Let's start with the product routes.>For each route, we specify the path
      and a reference to the component.
      The template defined in the specified component
      will display when the router navigates to this path.
      Next we add the route to display our Welcome Page.
      We'll set the path to Welcome
      and specify the Welcome Component.
      When the application loads, we want to default
      to the template from the Welcome Component>so we'll specify a default route that redirects
      to our Welcome Component.>And let's define a wildcard path in case the requested URL
      doesn't match any prior paths defined in the configuration.
      This is often used for displaying a 404 Not Found page
      but in our simple example, we'll use it
      to redirect back to the Welcome Page.
      There's a lot of stuff here now
      in our route application module.
      In a later course module, we'll look at how to refactor
      this module into multiple Angular modules
      for a separation of concerns.</p>

    <h3>Tying Routes to Actions</h3>
    <p>With routing, the user can navigate
      through the application in several ways.
      The user can click a menu option link, image,
      or button that activates, or navigates to, a route.
      The user can type the associated URL segment
      in the address bar after the application URL
      or use a bookmark to that URL, or the user can click
      the browser's forward or back buttons.
      The route configuration handles the URLs
      so the last techniques will just work.
      We need to handle the first technique
      by tying routes to the user actions.>We need to decide how we will show the routing options to the user.
      We could display a navigation pane with links.
      We can provide a toolbar or images
      or we can build a navigation menu like this one.
      In a more full-featured application, the menu
      could have many more options and sub-options
      but this will do for our purposes.
      We define that menu as part of this component's template.
      We then need to tie a route to each menu option.
      We do that using the router link directive.>The router link is an attribute directive
      so we add it to an element such as the anchor tag here
      and we enclose it in square brackets.
      We bind it to a template expression that returns
      a link parameters array.>The first element of this array
      is the string path of a route.>Additional elements can be added to this array
      to specify optional route parameters.
      The router uses this array to locate the associated route
      and build up the appropriate URL
      based on any provided parameters.
      when the user selects the option,
      the associated route is activated.
      Activating a component route displays that component's view.
      Now let's add a menu and use the router link directive
      so the user can navigate to the views
      in our sample application.>First, we need to decide how to show the routing options to the user.
      For our sample application, we'll build a menu.
      We want to add that menu at the root of our application
      so we'll add it to the app component.
      In the app component template currently, we're nesting
      the Product List Component.>Let's replace that with a navigation menu.>This menu uses the nav element and the
      navbar
      classes
      from the Twitter bootstraps styling framework.
      Let's see how this look in the browser.
      Here is our new menu, but clicking on the menu options
      don't do anything yet>and our product list no longer appears.
      We need to tie routes to these menu options.
      Note that we currently have some runtime errors
      because we have not completed all of the steps
      needed for routing.>Depending on your selected editor, you many not
      be able to run the application at this point
      with these errors.>We'll be finishing up routing soon.
      We'll use the router link directive to tie a route
      to each of these menu options.>For the Home menu option, we'll add the router link
      to the anchor element,>but we could use any clickable element.
      We want to tie the welcome route to the Home menu option,
      so we specify Welcome here.>Pay close attention to this syntax.
      We assign the router link's directive to an array
      defined within quotes.>The first element of the array is a string,>so it is also enclosed in quotes.
      We'll use similar syntax to tie the product's route
      to the Product List menu option.
      And since we are no longer nesting
      the Product List Component, we can remove its selector.
      Now we just need to tell Angular where to place our views
      and display the routed components template.
    </p>
    <h3>Placing the Views</h3>
    <p>When a route is activated, the associated component's view
      is displayed, but displayed where?
      How do we specify where we want the routed component
      to display its view?>We use the router outlet directive.
      We place that directive in the host component's template.
      The routed component's view then appears
      in this location.>Let's add the router outlet to our sample application.
      We are back looking at the app component
      because it is the host for our router.
      We add the router outlet in the template
      where we want to display the routed component's view.
      We'll put it here.>Whenever a route is activated,>the associated component's view displays here.
      Let's see how that looks in the browser.
      Oh my, where did that page come from?
      That's the welcome page provided in the starter files.
      When the application launches, the default route
      is activated and the welcome view displays.>If we click on the Product List menu,
      the router link directive now activates
      the Product List route and the list view appears, sweet.
      Our application component can now route to multiple views.
      Notice the URL.>The URL segment we defined for the route is displayed here.
      If we type in something, like welcome,
      the welcome component's view is displayed.>Now that we have our routing place, let's review
      how these routing features work together.
      When a user navigates to a feature tied to a route
      with a router link directive, the router uses the link
      parameter's array to compose the URL segment.
      The browser's location URL is changed
      to the application URL plus the composed URL segment.
      The router searches through the list of valid route
      definitions and picks the first match.
      The router locates or creates an instance of the component
      associated with that route.>The component's view in injected in the location
      defined by the router outlet directive
      and the page is displayed.>We now have basic routing in our sample application, yay!
      As we've seen in this course module,>routing is rather intricate, requiring code>in multiple files and strings
      such as
      parameter names
      and route paths that must match across those files,
      so let's finish up this module with some checklists
      that can help ensure all of the bits of routing
      are in the right places.</p>
    <h3>Checklists and Summary</h3>
    <p>To route or to nest, that is the question.>When creating components we need to think about
      how they will be displayed.>For components to be nested within other components
      we need to define a selector>as part of the component decorator.
      This selector provides the name of the directive
      and then we nest the component within another component
      using directive to define>where the component template appears.
      The component does not then need a route.
      For components to be dispalyed as a view
      within our single application page, the component
      needs no selector, but we do need to configure routes.
      We then tie those routes to actions
      and action activates a route to display the view.
      If we want to do routing in our application,
      we need to configure the reroute definitions,
      tie routes to actions, and place the view.>Let's do checklists for each of these tasks.
      The first step for doing routing in an application
      is to configure the routes.>Begin by defining the base element in the index.html file.
      Add RouterModule to an Angular Module's imports array,
      then add each route to the array, passed through
      the RouterModule's forRoot method.
      And remember that order matters.
      The router will pick the first route that matches.
      Each route definition requires a path
      which defines the URL path segment for the route.
      Be sure the path has no leading slash.
      Use an empty path for a default route
      and two asterisks for a wildcard route,
      which is matched if no prior path matches.>Most route definitions also include a component.
      The component is a reference to the component itself.
      It is not a string name and is not enclosed in quotes.
      Once we have the routes configured, we need to tie
      those routes to actions.>First we identify which actions to tie to which routes.
      Then we add the router link directive as an attribute
      to any clickable element in a component's template.
      We can use them in menu options, toolbars, buttons, links,
      images, and so on.>Be sure to enclose the router link in square brackets.
      Bind the router link to a link parameters array.
      The first element of the link parameters array
      is the route's path.>All other elements in the array are values>for the route parameters.>Use the router outlet to
      identify where to display
      the routed component's view.>This is most often specified in the host component template.
      When a route is activated, the route component's view
      is displayed at the location of the router outlet.
      This module was all about navigation and routing.
      We began with a look at how routing works.>We then walked through how to configure routes,
      tie routes to actions, and define where
      the router component's view should appear.>Our app component had embedded our Product List Component
      as a nested component.>In this module, we were finally able to remove that nesting.
      We set up routing so we can now navigate
      to our Welcome and Product List Components.>We've covered the basics of routing in this module,
      but there is so much more.>In the next module, we'll look at
      some additional routing techniques and add navigation
      to the product detail component.</p>


    <h2>Navigation and Routing Additional Techniques</h2>
    <h3>Introduction</h3>
    <p>Now that we know the basics of routing, we are ready for more.
      Welcome back to Angular 2, Getting Started from Pluralsight.
      My name is Deborah Kurata, and in this module,
      we look at several additional routing techniques.
      With what we learned in the prior module,
      a user can now navigate to any defined route
      in our application.>But that only covered the very basic routing scenarios.
      What if we need to pass parameters to a route?
      Or activate a route with code,>instead of with a clickable element?>Or what if we need to protect a route,
      and only allow access to it in special cases
      or by certain users?>Or ask a user to save changes before leaving a route?
      In this second module on routing,
      we examine how to pass parameters to a route,
      how to activate a route with code,
      and how to protect our routes with guards.>When we're finished with this module,
      we'll know how to handle additional routing scenarios,
      including routing to a component that requires parameters,
      such as our product detail component.
      Let's get started.</p>
    <h3>Passing Parameters to a Route</h3>
    <p>We sometimes need to pass parameters to a route.
      For example, to navigate to the product detail view,
      we need to define which product's details to display.
      The first step to passing parameters to a route
      is to configure the route with parameters.>We've already done this step to route to
      our product detail component.
      Here, we define a slash, a colon, and a placeholder
      for the parameter.>If multiple parameters are needed,
      we'd repeat this with another slash, colon, and placeholder.
      With the route definition in place,
      we can decide where we want the user>to activate this route.>Will we add a menu option or a data link?
      It is there we set the router link
      and pass in the required parameter.
      In the product list component template,
      we display a table of products.
      Each table row contains the product name.
      We'll add an anchor tag to the product name>that activates the product detail route,
      and displays that product's data.
      So we add a router link to this anchor tag,>and assign it to the link parameters array.>The first element to the
      array
      is the string path
      of the route.>The second element of the array is the value
      for the route parameter.>When the router composes the URL,
      it uses this array element to construct
      the defined parameter.>To display the appropriate product,
      the product detail component reads this parameter
      from the URL.>It then uses the parameter to retrieve
      the appropriate product and display it in the view.
      To get the parameter from the URL,
      we use the activated route service,
      provided by the router.>We want an instance of the service,
      so we define it as a dependency in our constructor.
      We've seen this syntax before.>This line of code defines a private variable called _route,
      and it assigns it to the instance of the activated route
      provided by the angular service injector.
      Then we use the instance of the activated route service
      to get the desired parameter.
      There are two different ways to get the parameter.
      We could use a snapshot, or we could use an observable.
      Use the snapshot approach if you only need to get
      the initial value of the parameter.
      The code is then a one liner as shown here.>In our example, the user is always returned to the list page
      before navigating to another product,
      so the snapshot approach would be sufficient.
      If you expect the parameter to change
      without leaving the page, use an observable.
      For example, if we had a next button on the product detail
      page to display the next product,
      the URL will change to the next product's ID,
      so you'd want to use an observable instead.>We use the activated route snapshot method here,
      and access the appropriate parameter>from its parameter array.>The string specified here must match the name
      of the parameter from the path.
      Let's give this a try.>We already have the product detail components route
      configured with a parameter.>Looking at that route, here in the path,
      we provide any parameters prefixed with a colon
      and separated by slashes.>For the product detail component, we pass a product ID,
      so the view knows which product's detail to display.
      Next, we need to decide where to tie this route
      to a user action.>We can't add the product detail to the menu,
      because we don't have an easy way for the user
      to specify the ID of the desired product.
      Let's instead modify the list of products
      in the product list view, such that each product name
      is a link, then the user can click on the product
      to display its details.>In the product list template,
      we'll add an anchor tag so the product name becomes a link.
      We add the router link directive to the anchor tag,
      and set up the link parameters array.
      In the array, we define the path of the route
      to activate the first element,>and pass the parameter value in the second element.
      In this example, we want to pass the product's ID.
      When we view the result in the browser,
      we see that the product names are now links.
      And if we click a link, we see the ID and the URL,
      and we navigate to the product detail component.
      Yay!>But that component does not yet get the parameter
      from the URL.>Let's do that next.>We add code in the product detail component>to get the parameter passed in on
      the
      URL.>We use the activated route service provided by the router to help us.
      First, we import the service.
      We don't have to register this service,
      because it is registered as part of the router module,
      we add it to the imports array in the last course module.
      We then set activated route as a dependency>by defining it as a parameter to the constructor function.
      The activated route instance is then injected
      into this component class.>Now, let's get the ID from the route>and store it in a local variable.
      We'll use the snapshot approach here,
      because we don't expect the URL to change.>Where do we put the code to read the parameter?
      We don't want it in the constructor.>We'll instead use the OnInit life cycle hook.
      Recall from earlier in this course how to use
      a life cycle hook?>We start by importing OnInet from Angular core.
      Then we implement OnInet and write the code>for the ngOnInit method.>We start by routing the parameter into a
      variable.
      We use let here, which is new in ES2015,
      and defines a block scoped variable.>We then use this._route.snapshot to get the parameter.
      We pass in the name of the parameter we want to read.
      The parameter name we defined in the route configuration
      is ID, so that's the parameter name we specify here.
      And because the parameter is provided as a string,
      we'll add a plus here at the beginning.
      The plus is a Javascript shortcut to convert the parameter
      string to a numeric ID.>To make it easy to see the ID we got from the URL,
      let's display it as part of the page title.>Here, we use the ES2015 back text to define>a template string and
      display
      the ID.
      Let's see the result in the browser.>Click the menu option to display the product list,
      then click a product.>The URL changes to include the parameter
      and the product detail page is displayed.
      If everything worked, the title displays the same parameter
      as shown in the URL, yay!>To get back to the product list,
      we could use the menu option here,
      but it would be nicer to have a back button.
      Let's add a back button and see how
      to activate a route with code.</p>

    <h3>Activating a Route with Code</h3>
    <p>We want to add a back button to our product detail page
      that navigates back to the product list page.
      We could activate this route using the router link directive
      in the component template,>just like we did with the menu options.
      But it's also possible to route with code.>So let's try that out instead.>When would you want to navigate with
      code
      instead of the router link directive in a template?
      One example is a save button,
      where you need to execute some code to save the data,
      and then route.>To route with code, we use the router service.
      We import the router service from angular router.
      We define a dependency on the router service
      using a constructor parameter.>The router instance is then injected>into this component class.>Every time we
      inject a
      service dependency into a class,
      we should ask ourselves, hmm,
      did we register this service with the angular injector?
      In the case of router, it is registered in router module,
      which we've added to our application's angular module
      imports array.>We use this router instance to activate a route.
      Here, we define a method that we can call
      from the template based on a user action.
      The code uses the navigate method of the router service,
      and passes in the same link parameter array we use
      when binding the router link.
      In this example, we route to the product's route
      and don't pass any arguments.
      Let's give this a try.>Here we are looking at the product detail component.
      We want the product detail component to navigate back
      to the product list component.>We start by importing the router service
      from angular router.>Next we define the dependency by adding
      another constructor parameter.>When this component class is constructed,
      we'll get an instance of both the activated route service
      and the router service.>Now we can build a method that navigates with code.
      Since the purpose of this method is to navigate back,
      we'll call it onBack.>It doesn't return anything,>so we'll set its return type to void.
      In this method, we use the this._router instance,
      and call the navigate method.
      We pass it a link parameters array.
      In this example, we want to navigate back to the
      product list component, and we don't need any parameters.
      We just define the route path, which is products.
      In the product detail template, we'll add a button.
      We again use the twitter bootstrap style classes
      to give the button some style.>We use event binding to bind the click event of the button
      to the onBack method we defined in the class.
      Now let's check it out in the browser.
      Click on the menu option to display the product list,
      then click on a product.>The product detail page is displayed.
      We click our back button,>and we are back on the product list page.
      Let's try another one.>We see the detail page,>now we're back on the product list page.
      Our code-based navigation is working.
      So routing with code involves importing the router
      and using its navigate method to activate the route.
      Now that we have several routes in place,
      let's look at how to protect them with guards.
    </p>
    <h3>Protecting Routes with Guards</h3>
    <p>There may be times that we want to limit access to a route.
      We want routes only accessible to specific users,
      such as an administrator, for example.
      Or we want the user to confirm a navigation operation,
      such as asking whether to save before navigating away
      from an edit page.>For that, we use guards.>The angular router provides several guards,>including CanActivate to
      guard
      navigation to a route,
      CanDeactivate, to guard navigation away
      from the current route,>Resolve, to prefetch data before activating a route,
      and CanLoad, to prevent asynchronous routing.
      In this clip, we work through how to implement
      the CanActivate guard.>You can use the same techniques we're covering here
      to implement any other type of route guard.>We'll build a guard that prevents navigation
      to the product detail route,>unless a specific condition is true.>Building a guard clause follows the common
      pattern
      used throughout Angular.>Create a class, add a decorator, and import what we need.
      Here, we define a ProductDetailGuard class.>Since we are implementing this guard as a service,
      we use the injectable decorator,
      and we import what we need.>This class implements CanActivate.
      To create one of the other kinds of guards,>change this to implement one of the other guard types.
      We then implement the canActivate method.
      For simple cases, this method can return a boolean value,
      true to activate the route,>and false to cancel the route activation.
      For more complex cases, we could return an observable
      or a promise from this method.>Because the guard class is a service,
      we need to register the service provider
      with angular's injector.>Unlike other services, however,
      the guard service provider must be provided>at the angular module level.>By providing this service at the module
      level,
      the router can use these services
      during the navigation process.>So in this example, we register it in our app module,
      by adding it to the providers array.>Using a guard is simple.>We built the guard to protect the product detail
      route,
      so we add the guard to the product detail route.
      We add canActivate and set it to an array containing
      the guards to execute before this route is activated.
      In our case, there is only one, our product detail guard.
      Let's give this a try.>We want to build a guard that prevents navigation
      to the product detail component,
      of the provided URL parameter is not valid,>Recall that the route definition for the product detail
      component includes an ID.>But there is nothing here that defines that this ID
      has to be numeric or greater than zero.
      So our guard should prevent navigation to
      the product detail route if the ID is zero or not a number.
      We begin by creating a new file for the guard service.
      Since this guard is only for the product detail route,
      we'll add it to the products folder.>We'll select new file and name it product-guard.service.ts.
      As always, we start with the class.
      Since this particular guard should be checked before
      activating the product detail route,>we implement canActivate.>So we need the import for that.
      The router guards are imported from angular router.
      Since this is a service, we'll add the injectable decorator,
      and the import for that.>Next, we need to implement the canActivate method.
      And we'll return a simple boolean.
      What do we want this method to do?
      We need to check the route URL and ensure that the ID
      passed in is valid.>Luckily for us, canActivate has a parameter>that gives us the activated route snapshot.>The
      activated route snapshot contains the information
      about the route at any particular moment in time.
      Now I'll paste the code for the method body,
      and we can talk through it.>The product detail route URL is comprised of two segments.
      Product and the requested ID.
      We only care about the ID,>so we pull the path from the second element,
      which is index of one.>The plus here at the beginning converts the URL
      path string to a number.>If the resulting value is not a number,
      or less than one, we display an alert,
      direct the user to the product list page,
      and return false to abort the current operation.
      Notice that this code is the same code we used
      to activate a route with code that we saw in the last clip.
      And as we saw in the last clip, to use the router,
      we need to inject it in to the constructor,>and add it to the imports.>Here, we return false to abort the current
      navigation.
      And here, we return true to continue activating the route.
      Now, we don't normally want to display an alert
      from our application.>In a real application, we'd route to an error page
      that would notify the user of the problem,>and optionally provide a button for navigating
      back to the product list page.>But this is good enough for our purposes.
      Because this class is a service,
      we need to register the service with angular's injector.
      As we discussed on the slides,>the guard's service provider must be provided
      at the angular module level.>We'll start by importing our product guard service.
      We don't have a providers array defined for our app
      module yet, so let's add one.
      Then add the product detail guard to the providers array.
      Now the router can use this service
      during the navigation process.>Next, we need to hook up this guard
      to the appropriate route.>We add the canActivate property to the route definition
      for the product detail component, and set it to an array.
      In the array we specify each guard we want to execute
      when activating the product detail route.
      In this case, we have only one.
      That should do it, let's give it a try.
      If we view the product list page, and select a product,
      our URL is valid and we navigate to the page.
      If we instead type in a URL that is not a number,
      we see our message.>The product detail route navigation is cancelled,
      and we are redirected to the product list page.
      It works.>Use route guards anytime you want to prevent access
      to a route, confirm navigation away from a route,
      or preload data for a route.>So let's finish up this module with some checklists.
    </p>
    <h3>Checklists and Summary</h3>
    <p>We can pass any number of parameters to a route, separated by slashes.
      Add the parameter to the route configuration path
      by specifying a slash, a colon, and the parameter name.
      Pass the parameter value by adding it to an element
      of the link parameters array>bound to the router link directive.
      Read the parameter value in the navigated component
      using the activated route service.
      Notice here that the parameter name, ID in this example,
      is exactly the same as in the route definition.
      To activate a route with code, use the router service.
      Be sure to import the service and define it as a dependency
      on the constructor.>Create a method that calls the navigate method
      of the router service instance,
      and pass in the link parameters array.
      Add a user interface element and use event binding
      to call the created method.>We can use guards to prevent access to a route,
      confirm navigation away from a route,
      or to preload data for a route.
      To create a router guard, we build a guard service,
      implement the guard type, in our case, CanActivate,
      and create the associated method.
      We then register the guard service provider>which must be registered in a module, not a component.
      Lastly, we add the guard to the desired route.
      In this module, we covered some additional routing
      techniques including passing parameters to a route,
      activating a route with code,
      and protecting routes with guards.
      We now have routing to our product detail component, yay!
      However, the product detail component and its associated
      template are not finished.>We only wired up the bare minimum to demonstrate routing.
      As a homework assignment, try building the remainder
      of the product detail template and code.
      To check your answer, you can find the completed application
      on my GitHub, as described in the First Things First module.
      There you will also find a version of the product data
      service that retrieves one product by ID.
      You'll need that to get the data
      for the product detail component.
      There is one important thing in the product detail template
      that I wanted to draw your attention to.
      Here is the completed product detail component template.
      Notice this ngIf here.>When this page is loaded, it retrieves the selected product,
      and displays the product data.>However, since the data access is asynchronous,
      there is a good change that the page will display
      before the data is retrieved.
      When that happens, the product property is not set,
      and the page generates binding errors.
      Adding this ngIf prevents that problem.
      Keep this ngIf trick in mind if you decide to tackle
      the homework assignment, and when binding to retrieve data
      in your own Angular applications.
      At this point, our appModule is looking a little cluttered
      and hard to manage.>Up next, let's spend some more time with Angular modules
      and look at how to refactor our application into more manageable pieces.
    </p>

    <h2>Angular Modules</h2>
    <h3>Introduction</h3>
    <p>As we've seen throughout this course Angular modules are a key part of any Angular application.
      Welcome back to Angular Two, getting started from Pluralsight.
      My name is Deborah Kurata and in this course module
      we focus on Angular modules>and how to use them to better organize our code.
      Ooo, it's so beautiful.>No, it's not a van Gogh, not even a Picasso.
      And yeah, it sort of looks like a metro map.
      This is a picture of what our application
      could look like if leverage the power of Angular modules
      instead of one large app module like we have now,
      there are multiple modules,>and each piece of our application has a logical place
      within one of those modules.>This keeps each module smaller and more manageable.
      In this course module we take another look>at the definition and purpose of an Angular module.
      We then focus in on the Angular module Metadata
      to better understand how to use it.
      We leverage that knowledge to create a feature module
      for our application, and take it one step further defining a shared module to reduce duplication.
      Lastly, we reexamine our applications root Angular module.
      Let's get started.</p>
    <h3>What Is an Angular Module?</h3>
    <p>What is an Angular module?>As we've seen earlier in this course,
      an Angular module is a class with an NgModule decorator.
      It's purpose, to organize the pieces of our application,
      arrange them into cohesive blocks of functionality,
      and extend our application with capabilities
      from external libraries.>Angular modules library the environment for resolving
      the directives and pipes in our components templates.
      We'll talk more about those in a few moments.
      End modules are a great way to selectively>aggregate classes from other modules,
      and re-export them in a consolidated convenience module.
      BrowserModule, HttpModule and RouterModule>are all examples of this,>and we'll create our own convenience
      module>when
      we build a shared module a little later.
      An Angular module can be loaded eagerly
      when the application starts>or it can be lazy loaded asynchronously by the router.
      Lazy loading is out of the scope of this course,
      but it's discussed in detail in the Angular documentation.
      How does an Angular module organize our application?
      An Angular module declares each
      component, directive and pipe that it manages.
      Every component, directive and pipe we create
      belongs to an Angular module.
      An Angular module bootstraps>our root application component.
      Defining the component needed to display our first template.
      An Angular module can export components, directives, pipes
      and even other Angular modules,
      making them available for other modules to import and use.
      An Angular module imports other Angular modules.
      This brings in the export functionality
      from those imported modules.>An Angular module can register service providers
      with the Angular injector, makign the services available
      to any class in the application.
      We can think of Angular module as a box.
      Inside that box we declare each of our components.
      If those components need any functionality>that functionality also needs to be defined>within this box.>The
      AppComponent sets up the routing for our main menu
      using routerLink and includes the router outlet directive,
      so it needs the the router directive's router service
      and routes which are defined in RouterModule.
      The ProductList-Component uses ngModel,
      so it needs the forms module.
      The ProductList-Component also used ngFor and ngIf,
      so it needs the BrowserModule.>The ProductList-Component used the ProductFilterPipe,
      so it needs that too.>The ProductList-Component also uses
      the starRating components directive,>so it needs that as well and so
      until the box contains everything
      that each our components needs.
      Saying this another way,>for each component that belongs to an Angular module
      that Angular module provides the environment
      for template resolution.>The module defines which set of components, directives,
      and pipes are available to the components template.
      Each declared components template is resolved
      using only the capabilities provided within that module.
      Let's look at our ProductList-Component as an example.
      The ProductList-components template used ngModel,
      so ngModel must be available within this module.
      We achieve that by importing the Angular Forms-Module.
      The ProductList-components template also uses
      a directive we created, the Star-Component.>So the Star-Component must be available within this module.
      Since the Star-Component is one we created>we can either declare the Star-Component
      within the module directly,>or we can import another module
      that exports the Star-Component.
      Importing an Angular module brings in the functionality
      exported by that module,>and we'd need to do one or the other, never both.
      We didn't need to thin about template resolution much
      in our sample application up until now
      because all of the pieces of our application
      are in one Angular module,>but we will need to keep this in mind
      as we split our application into multiple Angular modules.
      Let's take a quick look at our current app module.
      Here's the Angular module we defined throughout this course,
      it is the application's root Angular module,
      and by convention is called AppModule.
      The AppModule imports the system Angular modules we need,
      including the RouterModule>which is where we configured our routes.
      It declares each component and pipe that we created
      in this course.>It registers the service provider
      for our ProductDetailGuard,>and it bootstraps the application
      with the root application component, AppComponent.
      We have a lot of information in here,
      and we're mixing up basic application pieces
      such as our WelcomeComponent with pieces specific
      to our product feature.>And look at all those import statements.
      Let's journey through the NgModule MetaData>to better understand how Angular modules work,
      so we can then refactor our app module
      into multiple modules for better code organization.
    </p>
    <h3>Bootstrap Array</h3>
    <p>As we have seen, every Angular application has at least one Angular module called
      the Root Application Module or AppModule.
      And an Angular application has at least one component called
      the root application component or AppComponent.
      The AppModule bootstraps the AppComponent
      to provide the directive use in index.html file.
      We cover the bootstrap in-process in the
      introduction to components earlier in this course.
      The bootstrap array of the NgModule decorator
      defines the component that is the starting point of the application.
      This is the component that is loaded>when the application is launched.
      Here are some things to keep in mind>when using the bootstrap array.
      Every application must bootstrap at least one component,
      the root application component.
      We do this by simply adding the root application component
      to the bootstrap array of the root application module.
      The bootstrap array should only be used
      in the root application module, AppModule.>As we build other Angular modules
      we won't use the bootstrap array.
    </p>
    <h3>Declarations Array</h3>
    <p>Every component, directive, and pipe we create
      is declared by an Angular module.
      We use the declarations array of the NgModule decorator
      to define the components, directives, and pipes
      that belong to this Angular module.
      Here are some things to keep in mind>when using the declarations array.
      Every component, directive, and pipe we create
      has to belong to one and only one Angular module.
      In our sample application all of our components
      are defined in one Angular module, AppModule.
      It would be better to divide the components into
      multiple modules with basic application pieces
      in the app module and feature pieces>in appropriate feature modules.
      We'll do that a little later in this course module.
      As we separate out our pieces it is important to remember
      that each component, directive, and pipe
      belongs to one and only one Angular module.>Only declare components, directives and pipes.
      Don't add other classes, services or modules
      to the declarations array.>Never re-declare components, directives or pipes
      that belong to another module.>This is a corollary to truth number one.
      If we re-declare than the component, directive or pipe
      no longer belongs to one and only Angular module.
      For example, the Star-Component directive
      belongs to Module B so we should never re-declare
      Star-Component in Module A.>We should only declare components, directives and pipes
      that belong to this module.>All declared components, directives and pipes
      are private by default.>They are only accessible to other components,
      directives and pipes declared in the same module.
      So if we declare the Star-Component in Module B
      by default that component is not available>to components in other Angular modules.
      We share components, directives and pipes
      by exporting them.>We'll talk more about exporting in a few moments.
      The Angular module provides the template resolution
      environment for its components templates.
      When we include a component in the declarations array
      of an Angular module,>the component belongs to that Angular module.
      That components templates, directives, and pipes
      are then resolved within that module.
      When we use a directive in a components template,
      like the ai-star directive shown here,
      Angular looks to the module for the definition
      of that directive.>If the component defining that directive
      is not declared within the same Angular module
      or exported from an imported module,>Angular won't find the directive and will generate an error.
      For this example, the Star-Component must be declared
      in the same module as the ProductList-Component
      so Angular can find the template for the ai-star directive.
      Or the Star-Component must be exported
      from an imported module, never both.
    </p>
    <h3>Exports Array</h3>
    <p>The exports array of the NgModule decorator>allows us to share an Angular module's
      components, directives and pipes with other modules.
      We can export any of this module's
      components, directives and pipes
      so they can be pulled in when another module
      imports this module.>We can also re-export system Angular modules.
      such as FormsModule and HttpModule.
      We can re-export 3rd party modules
      such as Material Design.>Material Design is a set of high quality
      user interface components including buttons and dialogs.
      And we can re-export out own modules.
      Here are some things to keep in mind>when using the exports array.
      Export any component, directive or pipe
      if another component needs it.>A module can export any of its declared
      components, directives or pipes.
      Re-export modules to re-export>their components, directives, and pipes.
      This is useful when consolidating features from multiple
      modules to build a convenience or shared module.
      We can re-export something without importing it first.
      An Angular module only needs to import the>components, directives and pipes that are required
      by the components declared in the module.
      But the Angular module can still provide capabilities
      to other modules that import it by re-exporting.
      In this example my SharedModule exports the FormsModule
      even though it did not import it.
      So any module that imports the SharedModule>will have access to the NgModule and other forms directives.
      We'll see this in an upcoming demo.
      Never export a service.>Services added to the the provider's array>of an Angular module are registered
      with a root application injector.
      Making them available for injection
      into any class on the application.
      So there is no point in exporting them.
      They are already shared throughout the application.
    </p>
    <h3>Imports Array</h3>
    <p>An Angular module can be extended by importing
      capabilities from other Angular modules.
      The imports array of the NgModule decorator>allows us to import supporting modules
      that export components, directives or pipes.
      We then use those exported components, directives and pipes
      within the templates of components
      that are declared in this module.
      Many Angular system libraries are Angular modules
      such as the FormsModule and HttpModule
      we've used in this course.>We can import Angular modules to use their capabilities.
      Many 3rd part libraries are also Angular modules
      such as Material Design.>We can import 3rd part Angular modules
      to use their capabilities.>We can import our own modules to extend our application
      with additional features or share capabilities
      across several modules.>We'll see that in an upcoming demo,
      and we could separate out our route configurations
      into it's own module or set of modules and import that.
      Here are some things to keep in mind>when using the imports array.
      Importing a module makes available any exported
      components, directives and pipes from that module.
      We call that we are using ngModel
      in our ProductList-Component for two way binding.
      The ngModel directive is exported in the FormsModule.
      By importing the FormsModule into our AppModule
      we can use ngModel in any component
      declared in our AppModule.>Only import what this module needs.
      Only import modules who's exported
      components, directives or pipes are needed>by this modules component templates.>Don't import anything this module
      does
      not need.
      Importing a module does not provide access>to its imported modules.>Hmm, let's look at that with a picture.
      Here we have AppModule which declares
      the ProductList-Component,>and a SharedModule that declares and exports
      the StarComponent.>AppModule imports the SharedModule
      so the SharedModule's exports are available>to the AppModule's component templates.
      This mean that the ProductList-Component
      can use the StarComponent directive.>If the SharedModule imports FormsModule
      then the FormsModule's exports are available
      to the SharedModule,>and the StarComponent could use the ngModel directive,
      but the FormsModule exports are not available
      to the AppModule.>So the ProductList-Component>could not use the ngModel directive.>I've heard this role also
      stated
      another way,
      imports are not inherited.>Note however, that if the SharedModule
      re-exported the FormsModule then the FormsModule exports
      are available to the AppModule,
      and the ProductList-Component could use
      the ngModel directive.>So when thinking about the relationship between modules
      think of a module more as a box than as a tree structure.
    </p>
    <h3>Providers Array</h3>
    <p>Angular modules can also register service providers for our application.
      We can register services we develop such as>the ProductService we created earlier in this course.
      The products array of the NgModule decorator
      allows us register service providers at the module level.
      This is similar to the providers array
      of the component decorator that allows us to register
      services at the component level.
      We call that at this point our sample application registers
      the ProductService provider at the component level,
      and the ProductDetailGuard at the module level.
      Here are some things to keep in mind>when using the NgModule providers array.
      Any service provider added to the providers array
      is registered at the root of the application.
      So the service is available to be injected>into any class on the application.
      Say for example we have a feature module
      called ProductModule,>we add the ProductService to the providers array
      of this module.>At first glance we may think we have encapsulated
      the ProductService into the ProductModule,>but that is not the case.>Any service provider added to the providers
      array
      is registered at the root of the application,
      and is available to any class.>Even classes in other feature modules.
      So if we want to ensure a particular service
      is encapsulated and only accessible within>a specific component or set of components,>add the service provider to
      the
      providers array
      of an appropriate component instead of an Angular module.
      Note that this is not the case for lazy loaded services.
      See the Angular documentation for more information
      on lazy loading.>Don't add services to the providers array
      of a shared module.>As discussed in the services independencey injection module,
      there should only be one instance of a service
      that is an application wide singleton.
      So a service should not be included in the providers array
      for any module that is meant to be shared.>Instead consider building a CoreModule for services
      and importing it once in the AppModule.
      This will help ensure that the the services>are only registered one time.
      We could even add code to the code modules constructor
      to ensure that it is never imported a second time.
      See the Angular documentation for details.>Routing guards must be added to the providers array
      of an Angular module.>We discussed this in an earlier course model
      when adding guards to routes.
      The guard service provider must be defined>at the module level so that the router can use
      these services during the navigation process.
      Now that we've covered the basics of the NgModule decorator
      let's refactor our application>into multiple Angular modules.</p>

    <h3>Feature Modules</h3>
    <p>So far in this course we created
      the root application module, AppModule.
      It declares all of our components and our pipe.
      It imports the system Angular modules
      that our components need.>It also registers the routing guard that we built,
      but this is getting a little unwieldy.
      We have no separation of responsibilities.>Here we are mixing our basic application features
      such as the WelcomeComponent,
      with our product features>such as the product components,
      with our shared features such as the StarComponent.
      As we add more features sets to this application
      such as customer management, invoicing and so on,
      this is only going to get harder to manage.>So lets organize and refactor to break this into
      multiple Angular modules.>The first thing we want to do
      is extract some of these pieces into feature sets,
      we can then create a feature module for each feature set.
      Using feature modules helps us partition our application
      into logical groupings with separate concerns.
      Our first step is to define a new feature module.
      Creating a feature module involves
      defining a new module file, ProductModule in this example,
      and reorganizing the pieces of the application
      so that all of the associated feature pieces
      and everything they need are here in this module.
      In the declarations array of the features module
      we add the appropriate components that provide the features
      for the application.>In this example we add the ProductList-Component
      and ProductDetail-Component.>Then as we did we the box example at the beginning
      of this course module,>we start to look at what each component needs.
      In this example the ProductList-Component
      uses the ProductFilterPipe so we need that.>And both the ProductList and ProductDetail components
      use the StarComponent so we'll need that here as well.
      But that's not enough, the ProductList-Component
      uses ngModel and ngFor,>and both components use ngIf and routing.
      How do we get that?>We import these needed capabilities
      from other Angular modules.>Our product components use routing
      so we import the system RouterModule.
      The ProductList-Component use ngModel
      so we import the systems FormsModule.
      And we need ngFor and ngIf,>so do pull in the system BrowserModule?
      Nope, the BrowserModule should only be imported
      into the root application module, AppModule.
      Instead we import the system CommonModule.>The CommonModule exposes the ngFor and ngIf directives.
      Not surprisingly the BrowserModule itself actually
      imports and exports the CommonModule>which is why we have access to ngFor and ngIf
      When we import BrowserModule in our AppModule.
      Lastly we add any related services we want to declare
      at the module level which make the services available
      to be injected into any class in the application.
      In this example we add the>ProductService and the ProductDetailGuard
      which must be at the module level.
      So even though these module level services>are available application wide,
      we include them in ProductModule and not the AppModule
      to keep the code better organized and easier to find.
      Our feature module is looking pretty good here,
      but how do we use it?>Now that we've removed these features
      from the root application module,
      how will the application find all of these features?
      What's that, imports array did you say?
      That's correct, we need to import the ProductModule
      into the AppModule.>That extends the AppModule with the ProductModule features.
      You want to try this out?>We are back in the sample application.
      Let's begin by adding a new file for the ProductModule.
      We'll add it to the products folder
      and name it product.module.ts.>We start with a class.>We add the NgModule decorator
      and the required import statement.
      We add the declarations array
      and in that array we add the ProductList-Component,
      ProductDetail-Component and ProductFilterPipe.
      We also need the StarComponent.
      All those red squigglys?>Yeah, we need some import statement.>Now we can remove these from the app module.
      Next we define the imports array.
      We'll add the FormsModule, CommonModule and RouterModule,
      and their associated import statement.
      Now we can remove the FormsModule from the AppModule
      and it's associated import statement.
      When we added the RouterModule to the imports array
      in the AppModule we called forRoot
      to pass in the configured routes for our root component.
      Now that we are adding the RouterModule to the imports array
      of a feature module, we don't call forRoot.>Rather we called forChild and there we pass in the routes
      related to products.>Let's cut the product routes from the AppModule,
      and paste them here in our ProductModule.
      And we need to import the ProductDetailGuard.
      We call that the RouterModule.>Registers the Router service provider,
      declares the router directives,
      and exposes our configured routes.
      But as we've discussed previously,
      we never want to register a service more than once.
      So when we use forRoot to pass in our configured routes,
      the RouterModule knows to register
      the router service provider.>When we use forChild as we did here,>the RouterModule knows not to re-register
      the router service.>Note that we could also consider moving the routes
      into their own modules.>We'll look at that a little later.
      Lastly, we add the providers array.
      We add the ProductService and ProductDetailGuard
      to that array,>and insert their appropriate import statements.
      Now we can remove the ProductDetailGuard
      and its import statement from AppModule.
      Let's remove some our remaining import statements,
      and the ProductService>from the app components providers array.
      Moving the ProductService to the ProductModule is optional,
      we could leave it in the app components providers array.
      Now, do you think our application will run?>Our welcome page comes up,>but clicking on the Product List option
      does not display the Product List page.
      Any idea what could be wrong?
      We know have this ProductModule,
      but our application which is bootstrapped
      with the AppModule,>doesn't know anything about this new module.
      We have to import this module in our AppModule.
      So here we add the import statement
      and add the ProductModule to the imports array.
      Now we should be good to go.>And our application works as expected.
      So we now have our first working feature module,
      but let's think about this for a moment.
      As we build our application we'll build more features.
      Each logical set of features>will have their own feature module,
      and each feature module will most likely need
      the CommonModule for common directives
      such as ngFor and ngIf.>The FormsModule for ngModel and two way binding,
      and we may have other features>that want to reuse our StarComponent.
      Do we really want to repeat all of this
      in each feature module?>There has to be a better way.
      Yep, we can define a shared module.
    </p>
    <h3>Shared Module</h3>
    <p>The purpose of a shared module is to organize a set
      of commonly used pieces into one module,
      and export those pieces so they are available
      to any module that imports the shared module.
      This allows us to selectively aggregate
      our reusable components and any external modules,
      and re-export them in consolidated convenience module.
      Creating a shared module>involves defining a new module file,>SharedModule in this example,
      and reorganizing the pieces of the application
      so that the shared pieces are here in this module.
      First we add the components, directives, and pipes
      that we want to share throughout our application
      to the declarations array.>In this example we only want to add the StarComponent.
      Then we add to the imports array
      anything that the shared component needs.
      In this example we import the CommonModule>because our StarComponent may need it.
      We don't import FormsModule because we don't need it here.
      If our StarComponent did use two way binding
      or we added another component here that did,
      we'd need to import FormsModule as well.
      We then need to export everything that we want to share.
      The exports array defines what this Angular module
      shares with any module that imports it.
      We export the StarComponent that way it is available
      to the components in any module
      that imports the SharedModule.>We re-export the CommonModule and FormsModule
      so their directives and other features are available
      to any module that imports the SharedModule.
      And notice here at we can export something>without importing it first.>To use the SharedModule we import it into
      every feature module that needs the shared capabilities
      such as our ProductModule.>Let's give this a try.>We want to build a new shared module.
      We'll add it to the Shared folder
      that was provided with the starter files.
      We'll begin by adding a new file
      and name is shared.module.ts.
      We'll start with the class and add NgModule decorator,
      and we of course need to import that decorator.
      Next we define the declarations array
      and add the appropriate components to that array.
      In our example we'll add the StarComponent,>and we'll need it to associate an import statement.
      Next we define the imports array
      and add the CommonModule>and it's associated import statement.
      Lastly, we define what we actually want to share.
      In the exports array we add CommonModule,
      FormsModule and StarComponent,>and we need one more import statement.
      Now we want to use the SharedModule in our ProductModule.
      What do we need to do?>We start by adding the SharedModule to the imports array
      of the ProductModule,>and we need it's import statement.
      We can now delete FormsModule, CommonModule>and the StarComponent,>and their associated import statements
      here>since
      these pieces are now coming from
      the imported SharedModule.>Are we good to go?>Yep, our application comes up as it did before.
      Looking back at our code,>notice now that our feature module, ProductModule,
      only contains product pieces and the SharedModule.
      And the SharedModule is clean,>only including the pieces we want to share.>We can reuse the SharedModule
      and any future featured modules
      as we add functionality to our application.
    </p>
    <h3>Revisiting AppModule</h3>
    <p>We now know that every application has a root application module that is by convention called AppModule.
      The main purpose of the AppModule is to orchestrate the application as a whole.
      And now that we've removed the feature and shared pieces
      from this module, it's purpose is easier to see.
      Let's take another look.>We've reduced the code and AppModule such now
      that it fits on one page.>The AppModule normally imports BrowserModule.
      This the module that ever browser application must import.
      BrowserModule registers critical
      application service providers.>It also imports and exports CommonModule
      which declares and exports directives
      such as ngIf and ngFor.>These directives are then available
      to any of the app modules component templates.
      We also import HttpModule to register
      the Angular http client service provider.
      We import RouterModule and call forRoot
      passing in the configured routes
      for the root of the application.
      Here we configure our default route
      and any wild card routes.>Then we import each feature module.
      In this example we have only one
      feature module, ProductModule.>The declarations array identifies the list of components
      that belong to this module.>In this example the root component, AppCOmponent,
      and the applications WelcomeComponent,
      are declared here.>The bootstrap array identifies the root component,
      AppComponent, as the bootstrap component.
      When Angular launches the application
      it loads this component and displays it's template
      inside the PM app directive in the index.html file.
      We could take the refactoring a step further
      and separate the routing into it's own module.
      We could create one Angular module
      for our root application routes,
      and another Angular module for our product feature routes.
      Let's go back to the slides>and see what that code would look like.
      If we wanted to refactor our root application routes
      into their own module this is what it might look like.
      We export a class, add the NgModule decorator,
      and import what we need.>We add the RouterModule to the imports array
      passing in our root application routes
      including our default route and our wild card route.
      Notice that we call forRoot here
      to ensure that register the routing service provider,
      and the export RouterModule so we can use it from any module
      that imports this module.>We import the AppRoutingModule and the AppModule here.
      We can do the same to refactor our product feature routes
      into their own module.>The key difference here is when we import RouterModule
      in any feature module, we pass the configured routes
      to the forChild method instead of the forRoot method.
      This ensures that we don't register
      the routing service provider a second time.>And we import this ProductRoutingModule into ProductModule as shown
      here.
      Now let's finish up this course module with some checklists and a summary.
    </p>
    <h3>Checklists and Summary</h3>
    <p>Your application architecture depends on many factors
      including the size and scope>of the application you are working on,
      your team's size and experience,
      and your project's goals.>But here are some suggestions based on
      what we covered in this course module.
      Every application must always have a root application module
      by convention called AppModule.
      This is normally the module that bootstraps>the root application component, AppComponent.
      For smaller applications this could be the only
      Angular module for the application,
      as was the case with out simple application>prior to this course module.>As the application gets more features
      considering define a separate Angular module
      for each feature set.>For example, a product module, a customer module,
      and an invoice module.>This keeps the code organized, separates the concerns,
      and prevents the app module>from getting excessively large and unwieldy.
      As you add feature modules you may find
      components, pipes and directives that you want to share
      across feature modules.>Define one or more SharedModules for these shared pieces.
      SharedModules primarily use the exports
      and declarations arrays>with most of the declared pieces exported as well.
      If you have a set of services that you want to ensure
      are loaded when the application is loaded
      consider defining a core module for those services.
      Be sure that the core module is imported only once
      in the root application module.
      Since the core module is for services
      they primarily have providers,>none of which are exported.>We did not create a core module for our sample
      application
      since our service needs are limited,>but you may find them useful for your applications.
      And as we discussed in the last clip,
      we can also refactor our routes
      into their own routing modules.
      When creating an Angular module
      we build create a class and decorate it
      with the NgModule decorator.>The NgModule Metadata includes the bootstrap array
      for defining the list of startup components.
      In many cases there is only one,
      the root component of the application.
      The declarations array declares which
      components, directives and pipes belong to this module.
      The exports array identifies the list of components,
      directives and pipes that an importing module can use.
      The imports array lists supporting modules.>These modules provide components, directives and pipes
      needed by the components in this module.
      The providers array lists the service providers.
      Angular registers each provider
      with Angular's root application injector.
      So these services are available to be injected
      into any class in the application.
      This course module was all about Angular modules.
      We took a second look at the definition and purpose
      of an Angular module.>We then focused in on the Angular module Metadata
      and covered the truths to keep in mind
      when using that Metadata.>We leveraged that knowledge to create a feature module
      for our application,>and took it one step further defining a shared module
      to reduce duplication in our application.
      Lastly, we re-examined our root application route
      Angular module and saw how it orchestrates>the application as a whole.>If you are building a small application,
      such as the sample application we've created in this course,
      you may only need the one route application model
      as shown here,>but as your application grows you'll want to refactor
      into feature models and shared modules like this.
      Here we organized our application into multiple modules.
      We have our feature module, ProductModule,>that encapsulates all the product features.>There will be more feature
      modules
      as our application grows.>We have our SharedModule that shares commonly used
      components, directives, and pipes
      with any module that imports it.
      Currently we import it into the ProductModule.
      As build more feature modules we'll import it
      into them as well.>And we have our AppModule>that orchestrates the application.
      Each feature module is added>to the AppModule's imports array
      to extend the application with those features.
      Ooo, it's been quite a journey.
      Now let's circle back to the beginning.
      When we set up Angular in the First Things First module
      we skipped over the explanation of the set up files.
      Next up, let's revisit the Angular set up process
      and look at these boiler played files.
      What they are, how to use them, and when you'll want to change them.
    </p>

    <h2>Angular 2 Setup Revisited</h2>
    <h3>Introduction</h3>
    <p>The Angular application setup process
      may have seemed a bit like wizardry.>Packages and libraries magically installed>and the typescript compiler
      psychically knowing what to do.
      Welcome back to Angular 2 getting started from Pluralsight.
      My name is Deborah Kurata>and in this module we revisit the basic files we need
      to set up an Angular application.
      What looked like installation wizardry
      was instead a set of carefully defined setup files.
      Let's peek behind the curtain and see
      what those files are, what information they contain
      and how to use them.>In this module, we'll take a closer look at>the TypeScript configuration file,
      the TypeScript definitions file,
      the npm package file, the SystemJS configuration file
      and the scripts defined in index.html.
      Then we'll revisit the bootstrapping process
      and take a brief look at the Angular CLI.
      Let's get started.</p>
    <h3><a
      href="//app.pluralsight.com/player?course=angular-2-getting-started-update&amp;author=deborah-kurata&amp;name=angular-2-getting-started-update-m13&amp;clip=1&amp;mode=live"
      target="psplayer">TypeScript Configuration File (tsconfig.json) &amp; TypeScript Definitions File
      (typings.json)</a></h3>
    <p>To begin coding with Angular quickly>at the beginning of this course,
      I provided the basic files needed
      to set up our development environment.
      Those files are part of the starter files
      you may have downloaded>from the GetHub repository for this course,>as detailed in the first things first module.
      Now let's revisit each of these files and see what they do.
      Note that the content of these files may change over time
      so don't worry if your files don't look exactly
      as those shown in these demos.>With that said, let's get to know
      some of these files better, starting with tsconfig.json.
      This file is a TypeScript configuration file.
      It specifies TypeScript compile options and other settings.
      The TypeScript compiler tsc reads this file>and uses these options and settings.>The presence of this file in a
      folder
      indicates that the folder>is the root of a TypeScript project.>Most of today's browsers only understand
      the ES5 version of JavaScript,>so we need to tell the TypeScript compiler>to transpile our TypeScript code into
      ES5
      code.
      So ES5 is our target.>The sourceMap option defines>whether TypeScript should generate map files.
      Map files assist with debugging,
      so it's a good idea to set this to true.
      The emitDecoratorMetadata and experimentalDecorators options
      provide support for our decorators.
      These must be set to true>or our Angular application won't compile.
      The noImplicitAny option>defines whether the TypeScript compiler
      will default untyped variables to a type of any
      if it cannot infer the type.>If we want to insure>all of our variables are strongly typed,
      we can change this to true.>Feel free to add or change this file as needed
      to configure the TypeScript compiler>to the needs of your application and environment.
      So, disappointingly, the TypeScript compiler isn't psychic.
      It uses this file to know how to compile
      our TypeScript code.>Some JavaScript libraries extend the JavaScript environment
      with features and syntax>that the TypeScript compiler doesn't understand.
      We can use TypeScript definition files, d.ts files,
      to tell the TypeScript compiler about the libraries we load.
      These days many libraries>include their type definition files
      within their npm packages>so they are retrieved when the library is installed.
      We don't have to do anything extra in this case.
      For example, here is the TypeScript definition file
      for the common package we imported
      in the last course module.>This file was downloaded when we used npm install
      to download the Angular packages.
      For those libraries that don't provide
      their type definition files as part of their npm packages,
      we can use a typings tool to find and retrieve these files.
      The typings.json file contains the list of these libraries.
      We specify the typings for core.js,
      which brings ES2015 capabilities to ES5 browsers.
      And we need node to develop and build our application
      and to use tools such as LightServer,
      even if we won't use node as our backend server.
      This typings.json file is processed automatically
      as part of the installation process,>as we'll see when we look at the package.json file.
      Let's look at that next.</p>
    <h3>npm Package File (package.json)</h3>
    <p>One of the most important files
      for successful setup and development time execution
      is the npm package file, or package.json.
      When setting up Angular,>we use npm to install the Angular libraries>and all of their dependencies.>And we use npm
      to
      run scripts,>such as npm start to launch our application.
      Looking at the contents of this file>provides helpful insight into how npm knows what to do.
      This file contains basic information about the application,
      such as the application name, version,
      author, description and so on.>For our purposes, the key settings in this file
      are scripts, dependencies and dev dependencies.
      These are the settings that provide the magic
      when installing and running an Angular application.
      Let's look at the dependencies first.
      In this file, there are two sets of dependencies.
      The dependencies defines the libraries
      that our application needs to run.
      Here is Angular, systemjs, our modular loader,
      and reactive extensions, for example.
      And I added Twitter bootstrap here
      because we use it in the sample application for styling.
      The devDependencies define the additional libraries
      we need for development.>Here is where we define TypeScript.
      And some support libraries that the scripts use.
      We'll talk about these scripts in a moment.>At the beginning of this course,
      we set up Angular by typing npm install
      from the folder containing this file.
      When we issued that command,>npm reads these dependencies,
      locates each of these libraries in its repository by name,
      and installs the specified version.
      But please note, as with any software,
      these libraries will most likely change over time
      and the versions you see>may differ from the version numbers shown here.
      Feel free to add or modify these entries as needed
      to include any other third-party library or npm package.
      Up here, we see the list of scripts
      that we can run with npm.>We can execute any of these scripts from the command line
      using npm run and the script name,
      except for start, which does not require the run key word.
      Using npm run tsc, runs the TypeScript compiler.
      We can use the dash W flag with the TypeScript compiler
      to run the compiler in watch mode.
      This keeps the compiler running,
      awaiting changes to any TypeScript files
      and recompiling as needed.>LightServer is a lightweight static file server
      that we use to run our application
      without any backend server>and was specifically written for Angular 2.>Using npm start, runs the TypeScript
      compiler
      and the LightServer at the same time.
      So whenever we save a change to any of our files,
      tsc will recompile them>and LightServer will refresh the browser automatically
      so we can immediately see our changes.
      We saw this in action throughout the demos in this course.
      Using npm run typings, runs the typings tool.
      For TypeScript to be strongly typed,>it needs to know about each library's types.
      These files our stored in TypeScript type definition files
      and indicated with a d.ts extension.>Most libraries install their own
      associated TypeScript type definition files,
      so we don't have to do anything extra to install them.
      We put any other typings files in the typings.json file.
      Running the typings tool>installs any typings defined in this file.>postInstall is called by npm
      automatically>after
      it successfully completes
      the installation of the package.
      Here we have set up postInstall
      so that after npm install is complete,
      any TypeScript type definition files>in the typings.json file are installed as well.
    </p>
    <h3>SystemJS Configuration File (systemjs.config.js)</h3>
    <p>As its name implies, the SystemJS configuration file configures SystemJS.
      SystemJS is an ES module loader that automatically loads
      each of the files for our application.
      That way we don't have to add script tags
      for every file we use in our application.
      The paths property defines an alias
      where our system files are located.
      In this case, in the node modules folder.
      The map property defines to the module loader
      where all of our Angular pieces are located.
      We looked at the packages property earlier in this course
      when we walked through the application bootstrap process.
      The app property defines which file in the app folder
      should be loaded first, which is main,
      and provides a default extension for the paths we specify
      in our import statements.>Now let's move on to the index.html file.
    </p>
    <h3>index.html File Scripts</h3>
    <p>We've covered the contents of the index.html file previously in this course.
      But let's spend a moment looking closer
      at the libraries we are loading with the scripts tags.
      This first one is for core js.>This library brings ES2015 capabilities to ES5 browsers.
      We included the typings for this library
      in the typings.json file.>A zone is an execution context>that persists across asynchronous tasks.
      Angular uses zones for change detection and data binding.
      So we probably want that.>Reflect metadata is used by Angular
      to support reading decorator metadata,
      so we probably want that too.
      And this is SystemJS,>the module loader we discussed in the prior clip.
      So there is no wizardry here.
      Just a set of carefully defined setup files.
      Next, let's revisit the bootstrapping process.
    </p>
    <h3>Bootstrapping Revisited</h3>
    <p>Recall from the beginning of this course that we bootstrapped our root application module
      in the main.ts file as shown here.
      We used dynamic bootstrapping
      and the just in time, or JIT, compiler.
      This means that the Angular compiler>compiles the application in the browser
      and then launches the application
      starting with the root application module, AppModule.
      This is similar to how most>client-side web applications work.
      Alternatively, we could use static bootstrapping
      and the Angular ahead of time, or AOT compiler.
      By compiling ahead of time,>we can produce a much smaller application
      that launches faster,>especially on mobile devices and high latency networks.
      To use the static option,>the Angular compile runs ahead of time
      as part of your build process
      and produces a collection of files
      that contain class factories.
      Setting up a build process, and using the AOT compiler,
      is out of the scope of this course.
      But I did want to make you aware of it
      and show you how this file changes
      when you use ahead of time compilation.
      The code to bootstrap a pre-compiled application
      is similar to what we have here.
      Note that I have not run the AOT compiler,>so I don't have this factory.
      That's why we see a syntax error here.
      Notice how similar these two sets of code are.
      We use platformBrowser instead of platformBrowserDynamic.
      We use bootstrapModuleFactory instead of bootstrapModule,
      and we bootstrap the AppModule factory
      instead of the AppModule itself.
      Even though I've pasted both sets of code here
      so we could compare them,>you would always use one or the other, never both.
      So I'll delete this code.>For more information on the ahead of time compiler, or AOT,
      see the Angular documentation.>Next up, let's take a quick peek at the Angular CLI.
    </p>
    <h3>Angular CLI</h3>
    <p>Throughout this course, we have built our Angular application manually.
      That is one of the best ways to learn,
      by building each component>and typing each class definition and metadata.
      But as you start to build your application,>you may want to use the Angular CLI,>or command line interface.>The
      Angular CLI can generate>the pieces of our application for us.
      With simple command line syntax,
      we can create a working Angular application>with all of the required starter files,
      and we can add components, directives, pipes, services,
      or Angular modules to that application.
      This command adds a new component to the application
      called product list.>The CLI provides much more,>include generating unit and end to end tests.
      The best place to start with the CLI>is cli.angular.io website.>There we can get started with the CLI
      and learn about its commands.
      Here is the Angular CLI website.
      If we click get started,>it takes us to the GetHub repository.
      At the time of this recording,>the CLI version is beta 16 and still changing.
      So we won't demo this CLI here.
      Looking at the read me,>and navigating down to the installation process,
      we see that we can install the Angular CLI>with a simple npm command.>To generate an Angular project,
      type ng for Angular,new, and the project name, such as apm.
      The CLI creates a set of files for us.
      These files include all of the setup starter files,
      the root application module AppModule,
      and the root application component AppComponent,
      along with the first cut of unit and end to end tests.
      We just need to fill in the details.>We can also use the CLI>to generate components, directives, pipes and
      services
      as detailed here.>The Angular CLI provides the quick and easy way
      to build your Angular application
      without the need to download or install
      setup or configuration files.
      And I'm sure it will only get better and more fully featured as time goes on.
    </p>
    <h3>Summary</h3>
    <p>In this module, we revisited the setup files.
      We found that the TypeScript compiler is not psychic,
      rather it uses the TypeScript configuration file
      for options and settings when compiling our TypeScript code.
      We peeked at the TypeScript definitions file
      containing the typings we need.
      We then saw that npm is not wizardry,
      rather it uses the npm package file
      to specify the operation>of npm install, npm start, and npm run.
      We looked at the SystemJS configuration file
      and how it configures the module loader that we use.
      And we looked at the libraries specified
      in the index.html file scripts tags.>Then we revisited the bootstrapping process>and talked about the
      bootstrapping
      difference
      when using JIT versus AOT compilation.
      Lastly, we took a quick look at the Angular CLI.
      Consider trying it out to generate the boilerplate from your application.
      Only one module left.</p>

    <h2>Final Words</h2>
    <h3>Introduction</h3>
    <p>As you have seen throughout this course, Angular provides a consistent set of patterns
      for building components, templates, and services, helping us to come to speed quickly.
      Welcome back to Angular 2: Getting Started from Pluralsight.
      My name is Deborah Kurata and the final words in this course include a recap of our journey,
      a few pointers to additional information, and to look at a broader description of Angular.
      Let's jump right in to this short module.
    </p>
    <h3>Recapping Our Journey</h3>
    <p>The goal of this course was to guide you down
      the right path, making your own adventures with Angular 2
      more pleasant and productive.
      Let's recap our journey>and review the answers to the key questions we identified
      at the beginning of this course.
      What is a component?>We discovered that a component is a view
      defined with a template.>Logic, defined with a class.>And metadata, defined with a decorator.
      Where do we put the HTML for our user interface?
      Either in the metadata, using the template property,
      or in a separate HTML file using the template URL property
      in the metadata.>When should we use binding?>Anytime we want to display a component class property value
      in the view.>When we want to control the DOM by setting a DOM element,
      property, and code.>When we want to respond to user actions,
      and when we want to display a component class property,
      and update the property when the user makes a change.
      Why do we need a service?>We uncovered several reasons for building a service.
      To implement functionality that is independent
      from any particular component.>To share data and logic across components,>and to encapsulate external interactions
      such as with data access.>And how, how do we build an Angular application?
      With code that looks like this.
      Export a class, attach a decorator, and import what we need,
      then put each component directive endpipe
      in its appropriate Angular module.
      Along the way, each module provided a set of checklists
      containing steps and tips.>Feel free to revisit and reference these checklists
      as you start building your own Angular applications.
    </p>
    <h3>Learning More</h3>
    <p>This course covered the basics,
      but there is so much more.>On Pluralsight, the Angular 2: First Look course
      provides a comparison of Angular One to Angular 2
      and presents some more full-featured sample application
      and watch for additional Angular 2 courses coming soon to a device near you.
      The Angular 2 Documentation is very comprehensive and growing everyday.
      It is a great reference to everything Angular.
      And I've set up a GitHub Repository for this course
      so you can use it as a starting point or learning aid.
      It provides starter files if you want to try building an application yourself
      or you can review the completed course files here.
    </p>
    <h3>What Is Angular? (Revisited)</h3>
    <p>At the beginning of this course,
      we defined Angular as a JavaScript framework
      for building client-side applications
      using HTML, CSS and a language such as JavaScript,
      but this is a somewhat narrow view of Angular
      focusing on using it just for client-side web applications,
      but Angular is actually so much more.
      A better definition is that Angular is a platform.
      It supports multiple languages,
      multiple templating syntaxes,
      and multiple rendering targets.
      It has features to support mobile web
      such as material design,>a set of widgets that work across devices.>Angular Universal, to pre-render views on the
      server
      and web workers for background processing,>and Angular supports native mobile development
      using products such as Ionic and NativeScript.
      Keep an eye on Pluralsight and Angular IO
      for more information on these exciting technologies.
    </p>
    <h3>Closing</h3>
    <p>Congratulations, you've made it.
      You've completed the journey>through the basics of Angular 2,
      but the road goes ever on and on.
      There are many more paths for us to take
      and so much more to learn.>Thoughts or comments about this course?
      Please use the discussion tab on the Pluralsight page
      for the course to leave your feedback.
      And follow me on Twitter.>It would be great to hear about your Angular 2 adventures.
      Thanks for listening><a
        href="//app.pluralsight.com/player?course=angular-2-getting-started-update&amp;author=deborah-kurata&amp;name=angular-2-getting-started-update-m14&amp;clip=4&amp;mode=live&amp;start=30.291"
        target="psplayer">and I hope you enjoyed this j
        ourney through Angular 2.</a></p>


  </body>
</html>
