<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Advanced Examples With MVVM Light</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction; Plug-Ins: Introducing the Interfaces</h3>
                <p>The last module of this MVVM Light reference course will show a lot of samples. It will be code, code, code,
                    and almost no slides. The goal here is to show some specific usage of the MVVM Light components, which are not
                    totally usual, while in the rest of the course we showed samples that are rather common when using the
                    Model-View-ViewModel Pattern in the MVVM Light Toolkit.
                </p>
                <p>
                    First, we will show a large sample about building a plugin-based application. Building a plugin framework and
                    adding functionality to an application in the form of plugins is a very popular approach, especially in
                    Windows Presentation Foundation. This is quite typical for larger kinds of applications. It can be very
                    convenient when working with multiple teams, where the need to define a common interface is crucial.
                </p>
                <p>
                    In this sample, we will see how to build a plugin definition interface, then a Bootstrapper to load plugins
                    from a folder, and how we can access the MVVM functionalities through Data Binding, Commands, the SimpleIoc,
                    the Messenger, and more. We will also build two different plugins.
                </p>
                <p>
                    Then we will see a practical usage of the MVVM Light Messenger, in order to build an expandable list for a
                    Windows Phone Application. This is a very frequent UX Pattern in Windows Phone Apps, where elements in a list
                    can be selected by tapping on the far-left of the item. This expands the list to reveal checkboxes. However,
                    when the list is representing ItemViewModels, the interaction can be a little bit tricky to figure out without
                    using a component, such as a Messenger. In the sample here, we will see how to build such an experience from
                    scratch.
                </p>
                <p>
                    Finally, we will talk about unit testing. One of the big selling points of the Model-View-ViewModel Pattern is
                    that it can dramatically increase the testability of your applications. However, it is still relatively rare
                    to see consistent unit testing of apps. With the samples shown here, we will show some techniques and tips to
                    unit test a ViewModelLayer in MVVM Light Applications, and hopefully to promote the creation of unit tests for
                    those apps.
                </p>
                <p>
                    The first sample we will see is about â€˜Using MVVM Light in a Plug-in based Application'. MVVM Light's
                    components are very useful to build decoupled applications. So far in this course, we saw how applications can
                    be divided in layers that are loosely coupled. Of course, there are other kinds of decoupled applications. One
                    very interesting example is a Plug-in based application.
                </p>
                <p>
                    This is quite frequent in WPF to build extensible applications, where plug-ins are built after the
                    MainApplication, the plug-in host is complete. Or, when the project is split in multiple teams and these teams
                    want to work in an independent manner, with a minimal level of interaction in order to reuse the friction.
                </p>
                <p>
                    Plug-ins are very decoupled, and in this case, too, MVVM Light can help you. In this sample:
                </p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex06-001" type="text" value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 6\before\PlugInSample\PlugInSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex06-001">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex06-002" type="text" value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 6\after\PlugInSample\PlugInSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex06-002">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>we will see how the RelayCommand, the Messenger, and the SimpleIoc components can help in a plug-in scenario.
                </p>
                <p>
                    Here, we see the code for the MainApplication, which is also called the Host:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-001.png"/>
                    <figcaption>Fig 06-001</figcaption>
                </figure>
                <p>
                    Typically, a plug-in based application is separated in three types of components. The first one is where the
                    definition of the plugin is hosted:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-002.png"/>
                    <figcaption>Fig 06-002</figcaption>
                </figure>
                <p>
                    For example, here, this is an interface called IPlugIn:
                </p>
                <figure>
<pre><code class="csharp">namespace PlugInSample.Contracts
{
    public interface IPlugIn
    {
        string Name
        {
            get;
        }

        FrameworkElement GetElement();
    }
}</code></pre>
                    <figcaption>Fig06-003</figcaption>
                </figure>

                <p>
                    It has one property and one method. The property is just for information, and returns a name of the plugin:
                </p>
                <figure>
<pre><code class="csharp">string Name
{
    get;
}</code></pre>
                    <figcaption>Fig06-004</figcaption>
                </figure>
                <p>
                    Of course, this probably should be a unique name. The GetElement method returns a FrameworkElement, which can
                    be anything that will be placed into the PlugInHost:
                </p>
                <figure>
                    <pre><code class="csharp">FrameworkElement GetElement();</code></pre>
                    <figcaption>Fig06-005</figcaption>
                </figure>
                <p>
                    In addition to these members, a PlugIn interface could host other information; for example, the desired
                    position for the plugin inside the host, etc. The next interface is called IPlugInHost:
                </p>
                <figure>
<pre><code class="csharp">public interface IPlugInHost
{
    void Clear();
    void PlacePlugIn(IPlugIn plugIn, object dataContext);
}</code></pre>
                    <figcaption>Fig06-006</figcaption>
                </figure>
                <p>
                    It defines what the host needs to do in order to receive a new plugin. In our case, the host will be the WPF
                    Application's MainWindow, but we could have other scenarios or multiple hosts, etc.
                </p>
                <p>
                    Here we have two methods, clearing all the plugins, for example before we reload, and placing the PlugIn into
                    the host.
                </p>
                <figure>
                    <pre><code class="csharp">void PlacePlugIn(IPlugIn plugIn, object dataContext);</code></pre>
                    <figcaption>Fig06-007</figcaption>
                </figure>
                <p>
                    This method gets an instance of the IPlugIn interface that we saw just before and the second parameter is a
                    plugIn's dataContext. In true Model-View-ViewModel form, the dataContext will host functionality and
                    information that the plugin will use.
                </p>
                <p>
                    Note that these interfaces are hosted in a separate assembly:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-008.png"/>
                    <figcaption>Fig 06-008</figcaption>
                </figure>
                <p>
                    This assembly must be implemented early, and must be quite stable during the lifetime of the project. Any
                    change to this assembly will have an impact on every plugin and on the MainApplication, so this should be
                    modified as seldom as possible.
                </p>
                <h3>Plug-Ins: Preparing the View</h3>
                <p>In the MainApplication, the Host, we have a reference to the Contracts assembly:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-009.png"/>
                    <figcaption>Fig 06-009</figcaption>
                </figure>
                <p>
                    Then, we have an important class, the Bootstrapper:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-010.png"/>
                    <figcaption>Fig 06-010</figcaption>
                </figure>
                <p>
                    This class will be responsible for inspecting and loading plugins, so let's check it out. First, the Path of
                    the PlugInFolder is read from the Settings:
                </p>
                <figure>
                    <pre><code class="csharp">var folderPath = (string)Settings.Default["PlugInFolderPath"];</code></pre>
                    <figcaption>Fig06-011</figcaption>
                </figure>
                <p>
                    This allows the path to change, even after the application is compiled, which is convenient. Then, we go
                    further down, and we will use this foreach loop to load each DLL inside the folder:
                </p>
                <figure>
                    <pre><code class="csharp">foreach (var file in folder.GetFiles("*.dll"))</code></pre>
                    <figcaption>Fig06-012</figcaption>
                </figure>
                <p>
                    We will load all the assembly's types:
                </p>
                <figure>
                    <pre><code class="csharp">foreach (var type in assembly.GetTypes())</code></pre>
                    <figcaption>Fig06-013</figcaption>
                </figure>
                <p>
                    and check if one or more of these types are implementing the IPlugIn interface from the Contracts assembly:
                </p>
                <figure>
<pre><code class="csharp">if (typeof (IPlugIn).IsAssignableFrom(type)
    &amp;&amp; !type.IsInterface)</code></pre>
                    <figcaption>Fig06-014</figcaption>
                </figure>
                <p>
                    If that is the case, we use some Reflection to get the default constructor of the IPlugIn implementation:
                </p>
                <figure>
<pre><code class="csharp">var constructor = type.GetConstructor(
        new Type[]
        {
        });</code></pre>
                    <figcaption>Fig06-015</figcaption>
                </figure>
                <p>
                    and we invoke it to create a new instance of the plugin:
                </p>
                <figure>
<pre><code class="csharp">var manager = constructor.Invoke(
    new object[]
    {
    });

PlugIns.Add((IPlugIn)manager);</code></pre>
                    <figcaption>Fig06-016</figcaption>
                </figure>
                <p>
                    Then, this instance is kept in the list. After the plugins have been loaded, the Host can call the GetElement
                    method. Remember that the IPlugIn's GetElement method is returning a FrameworkElement, which can be placed
                    into the user interface:
                </p>
                <figure>
<pre><code class="csharp">public FrameworkElement GetElement(IPlugIn plugInManager)
{
    var fullType = plugInManager.GetType();

    var method = fullType.GetMethod("GetElement");

    var element = method.Invoke(
        plugInManager,
        new object[]
        {
        });

    return element as FrameworkElement;
}</code></pre>
                    <figcaption>Fig06-017</figcaption>
                </figure>
                <p>
                    Here, too, we are going to use some Reflection to invoke the PlugIn's GetElement method:
                </p>
                <figure>
<pre><code class="csharp">  var method = fullType.GetMethod("GetElement");

var element = method.Invoke(
    plugInManager,
    new object[]
    {
    });</code></pre>
                    <figcaption>Fig06-018</figcaption>
                </figure>
                <p>
                    and to return the result casted to a Framework Element.
                </p>
                <p>
                    Now let's discover more about the MainApplication's UI. First, we can open the ViewModelLocator. It is a
                    pretty standard MVVM Light object, as we saw before many times in the course. Here, we register the
                    Bootstrapper into the SimpleIoc in order to make it easily available to the application's objects that need
                    it:
                </p>
                <figure>
                    <pre><code class="csharp">SimpleIoc.Default.Register&lt;Bootstrapper&gt;();</code></pre>
                    <figcaption>Fig06-019</figcaption>
                </figure>
                <p>
                    Now let's see the object that will host the plugins. In this application, we use a MainWindow for that. Here
                    is how it looks like in Blend:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-020.png"/>
                    <figcaption>Fig 06-020</figcaption>
                </figure>
                <p>
                    The orange and green borders will be where the plugins are placed. The button below will reload the plugins
                    for the PlugInFolder. In the code behind, we see that the MainWindow implements the IPlugInHost interface:
                </p>
                <figure>
                    <pre><code class="csharp">public partial class MainWindow : IPlugInHost</code></pre>
                    <figcaption>Fig06-021</figcaption>
                </figure>
                <p>
                    We already saw these kinds of things before; for example, when we implemented the IDialogService interface in
                    order to show messages to the user. Here, the MainWindow registers itself in the IOC container when it is
                    loaded:
                </p>
                <figure>
                    <pre><code class="csharp">Loaded += (s, e) =&gt; SimpleIoc.Default.Register&lt;IPlugInHost&gt;(() => this);</code></pre>
                    <figcaption>Fig06-022</figcaption>
                </figure>
                <p>
                    To keep things clean, the MainWindow also unregisters itself in the closing event handler:
                </p>
                <figure>
<pre><code class="csharp">Closing += (s, e) =>
{
    SimpleIoc.Default.Unregister&lt;IPlugInHost&gt;(this);
    ViewModelLocator.Cleanup();
};</code></pre>
                    <figcaption>Fig06-023</figcaption>
                </figure>
                <p>
                    The Clear method is required by the IPlugInHost interface:
                </p>
                <figure>
<pre><code class="csharp"> Messenger.Default.Send(
    new NotificationMessage(Notifications.CleanupNotification));</code></pre>
                    <figcaption>Fig06-024</figcaption>
                </figure>
                <p>
                    We will first send a message to whomever is concerned, warning that it is time for cleanup. Typically, all the
                    plugins are going to be interested in this message. Here, we use a standard NotificationMessage, which is an
                    MVVM Light element. Then, we clear the UI by setting the orange and green borders' Child property to null:
                </p>
                <figure>
<pre><code class="csharp">PlugInHost1.Child = null;
PlugInHost2.Child = null;</code></pre>
                    <figcaption>Fig06-025</figcaption>
                </figure>
                <p>
                    The PlacePlugIn method is also required by the IPlugInHost interface:
                </p>
                <figure>
                    <pre><code class="csharp">var bootstrapper = ServiceLocator.Current.GetInstance&lt;Bootstrapper&gt;();</code></pre>
                    <figcaption>Fig06-026</figcaption>
                </figure>
                <p>
                    It uses the IOC container to get the Bootstrapper:
                </p>
                <figure>
                    <pre><code class="csharp">element = bootstrapper.GetElement(plugIn);</code></pre>
                    <figcaption>Fig06-027</figcaption>
                </figure>
                <p>
                    Then, it gets a FrameworkElement that is defined in the plugIn assembly using the Bootstrapper's GetElement
                    method that we just saw:
                </p>
                <figure>
                    <pre><code class="csharp">element = bootstrapper.GetElement(plugIn);</code></pre>
                    <figcaption>Fig06-028</figcaption>
                </figure>
                <p>
                    It sets the element's DataContext as required here:
                </p>
                <figure>
                    <pre><code class="csharp">element.DataContext = dataContext;</code></pre>
                    <figcaption>Fig06-029</figcaption>
                </figure>
                <p>
                    Then, it uses an algorithm to find out where to place a plugin into the UI:
                </p>
                <figure>
<pre><code class="csharp">if (PlugInHost1.Child == null)
{
    PlugInHost1.Child = element;
    return;
}

if (PlugInHost2.Child == null)
{
    PlugInHost2.Child = element;
    return;
}

MessageBox.Show("No more room");</code></pre>
                    <figcaption>Fig06-030</figcaption>
                </figure>
                <p>
                    Here, this algorithm is very basic, but it could be much more complex; for example, the plugin might require
                    to be placed in a specific location, for example a sidebar, a footer, a header, etc.
                </p>
                <p>
                    Now let's open the MainViewModel. This will be the ViewModel for the application's MainWindow. It has an
                    ObservableCollection of the IPlugIns:
                </p>
                <figure>
<pre><code class="csharp">public ObservableCollection&lt;IPlugIn&gt; PlugIns
{
    get;
    private set;
}</code></pre>
                    <figcaption>Fig06-031</figcaption>
                </figure>
                <p>
                    We will use this collection to show the PlugIn names into the window. Then we have the RelayCommand, which is
                    going to be used to reload all the plugins from the PlugInFolder. To do this, we will get the PlugInHost from
                    the IOC container:
                </p>
                <figure>
<pre><code class="csharp">var host = ServiceLocator.Current.GetInstance&lt;IPlugInHost&gt;();
host.Clear();</code></pre>
                    <figcaption>Fig06-032</figcaption>
                </figure>
                <p>
                    and, of course, the MainViewModel doesn't know that this IPlugInHost is actually the MainWindow. Again, this
                    is similar to what we did before with the IDialogService.
                </p>
                <p>
                    The MainViewModel instructs the PlugInHost to Clear the PlugIns. Then it calls a Refresh method on the
                    Bootstrapper and saves the PlugIns in the ObservableCollection:
                </p>
                <figure>
                    <pre><code class="csharp">bootstrapper.Refresh();</code></pre>
                    <figcaption>Fig06-033</figcaption>
                </figure>
                <p>
                    And finally, it instructs the PlugInHost to place the PlugIn elements in the user interface:
                </p>
                <figure>
<pre><code class="csharp">foreach (var plugIn in bootstrapper.PlugIns)
{
   PlugIns.Add(plugIn);
   host.PlacePlugIn(plugIn, this);
}</code></pre>
                    <figcaption>Fig06-034</figcaption>
                </figure>
                <p>
                    Note that in this simple demo, the PlugIn's ViewModel is a MainViewModel itself. In a production application,
                    we would have multiple ViewModels with various functionality. Later we will see that the PlugIn itself can
                    also specify a separate ViewModel, etc.
                </p>
                <h3>Plug-Ins: Databinding and Commanding</h3>
                <p>Now that we saw how the PlugIn infrastructure works, let's add some functionality and see how the PlugIns can
                    get access to that. First, I will add a Counter property in the MainViewModel. Let's use the MVVM Light's inpc
                    snippet to do that; for example, inpcsetlambda, that we saw just before:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-035.png"/>
                    <figcaption>Fig 06-035</figcaption>
                </figure>
                <p>
                    I'm going to type the name of the property, Counter, and let's make that a string and the name of the field is
                    also going to be _counter. And then I'm going to type the initial value, which I set to "Initializing":
                </p>
                <figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="Counter" /&gt; property's name.
/// &lt;/summary&gt;
public const string CounterPropertyName = "Counter";

private string _counter = "Initializing";

/// &lt;summary&gt;
/// Sets and gets the Counter property.
/// Changes to that property's value raise the PropertyChanged event.
/// &lt;/summary&gt;
public string Counter
{
    get
    {
        return _counter;
    }
    set
    {
        Set(() => Counter, ref _counter, value);
    }
}
</code></pre>
                    <figcaption>Fig06-036</figcaption>
                </figure>
                <p>
                    So this is a simple string property, which raises a PropertyChanged event when it changes. Then I'm going to
                    add a Command. This Command will be used to increment the Counter. I will use the mvvmrelay snippet that we
                    saw before, so here we go:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-037.png"/>
                    <figcaption>Fig 06-037</figcaption>
                </figure>
                <p>
                    Tab. And then I'm going to call that _incrementCommand, and the name of the property itself, IncrementCommand,
                    too:
                </p>
                <figure>
<pre><code class="csharp">private RelayCommand _incrementCounterCommand;

/// &lt;summary&gt;
/// Gets the IncrementCounterCommand.
/// &lt;/summary&gt;
public RelayCommand IncrementCounterCommand
{
    get
    {
        return _incrementCounterCommand
            ?? (_incrementCounterCommand = new RelayCommand(
                () =&gt;
                {
                    Counter = string.Format(
                        "Counter is now {0}",
                        _counterValue++);
                }));
    }
}</code></pre>
                    <figcaption>Fig06-038</figcaption>
                </figure>
                <p>
                    The implementation is going to be very simple; I'm simply going to take this value here and increment it, and
                    then format the string:

                </p>
                <figure>
<pre><code class="csharp">Counter = string.Format(
    "Counter is now {0}",
    _counterValue++);</code></pre>
                    <figcaption>Fig06-039</figcaption>
                </figure>
                <p>
                    So far, this is just standard MVVM code. However, because the MainViewModel will be set as the PlugIn's
                    DataContext when it is loaded, it means that the PlugIn has access to the Counter property and even to the
                    IncrementCommand through Databinding. Here, in the MainWindow, I added a button to increment the Counter:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-040.png"/>
                    <figcaption>Fig 06-040</figcaption>
                </figure>
                <p>
                    So let's use a Binding Editor to bind the button's Command:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-041.png"/>
                    <figcaption>Fig 06-041</figcaption>
                </figure>
                <p>
                    to the IncrementCommand that we just added before:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-042.png"/>
                    <figcaption>Fig 06-042</figcaption>
                </figure>
                <p>
                    Now it is time to work on the PlugIn itself. I have the project defined in another instance of Visual Studio.:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-043.png"/>
                    <figcaption>Fig 06-043</figcaption>
                </figure>
                <p>
                    This is to show that we can work on the PlugIns in a totally separate manner. In the References folder, we
                    will see a reference to the Contracts assembly that was precompiled before:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-044.png"/>
                    <figcaption>Fig 06-044</figcaption>
                </figure>
                <p>
                    We also added the MvvmLight assemblies:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-045.png"/>
                    <figcaption>Fig 06-045</figcaption>
                </figure>
                <p>
                    Here is the implementation of the IPlugIn interface.
                </p>
                <figure>
<pre><code class="csharp">using System.Windows;
using PlugIn1.ViewModel;
using PlugInSample.Contracts;

namespace PlugIn1
{
    public class PlugInManager : IPlugIn
    {
        public string Name
        {
            get
            {
                return "Plug-in # 1";
            }
        }

        public FrameworkElement GetElement()
        {
            return new PlugInControl1();
        }
    }
}</code></pre>
                    <figcaption>Fig06-046</figcaption>
                </figure>
                <p>
                    This is a PlugInManager, which is going to handle loading the PlugIn UserControl. The name is defined here:
                </p>
                <figure>
<pre><code class="csharp">public string Name
{
    get
    {
        return "Plug-in # 1";
    }
}</code></pre>
                    <figcaption>Fig06-047</figcaption>
                </figure>
                <p>
                    we simple return a string, and then we have the GetElement method:
                </p>
                <figure>
<pre><code class="csharp">public FrameworkElement GetElement()
{
    return new PlugInControl1();
}</code></pre>
                    <figcaption>Fig06-048</figcaption>
                </figure>
                <p>
                    This creates a new instance of the PlugInControl, again in a very simple manner. In the UserControl.xaml, we
                    see that the DataContext is not explicitly set:
                </p>
                <figure>
<pre><code class="xml">&lt;UserControl xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:ignore="http://www.ignore.com"
             xmlns:viewModel="clr-namespace:PlugIn1.ViewModel"
             x:Class="PlugIn1.PlugInControl1"
             mc:Ignorable="d ignore"
             d:DesignHeight="300"
             d:DesignWidth="300"&gt;

    &lt;Grid Background="Red"&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition /&gt;
            &lt;RowDefinition /&gt;
            &lt;RowDefinition /&gt;
        &lt;/Grid.RowDefinitions&gt;

        &lt;StackPanel Orientation="Vertical"
                    VerticalAlignment="Center"
                    HorizontalAlignment="Center"&gt;
            &lt;TextBlock Text="Counter"
                       Foreground="White"
                       Margin="0,0,0,5"
                       HorizontalAlignment="Center" /&gt;

            &lt;TextBlock Text="{Binding Counter}"
                       HorizontalAlignment="Center"
                       VerticalAlignment="Center"
                       Foreground="White"
                       FontSize="24" /&gt;
        &lt;/StackPanel&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;</code></pre>
                    <figcaption>Fig06-049</figcaption>
                </figure>
                <p>
                    This will be the task of the Bootstrapper in the MainApplication. Remember that the MainViewModel will be used
                    as a PlugIn's ViewModel as well, so in the real-life application, we would probably use another class.
                </p>
                <p>
                    Here, we rely on some knowledge of the ViewModel, notably that there is a Counter property, which is used here
                    in the Databinding:
                </p>
                <figure>
                    <pre><code class="xml">&lt;TextBlock Text="{Binding Counter}"</code></pre>
                    <figcaption>Fig06-050</figcaption>
                </figure>
                <p>
                    If we open this UserControl in Blend, we see that there is no design time data:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-051.png"/>
                    <figcaption>Fig 06-051</figcaption>
                </figure>
                <p>
                    however, this can be easily changed. Remember that we saw in earlier modules how we can use a design-time
                    DataContext attribute to create design time data. In the real-life project, the design time data can be
                    created by the team who is in charge of the MainViewModel and sent to all the PlugIn developers. This is also
                    a contract between the MainApplication and the PlugIns, just like the IPlugIn interface.
                </p>
                <p>
                    Let's add the design-time ViewModel class here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-052.png"/>
                    <figcaption>Fig 06-052</figcaption>
                </figure>
                <p>
                    and of course we can do that either in Visual Studio or in Blend. And here, the DesignMainViewModel was sent
                    to the PlugIn Team by the MainApplication's Team, so let's just add it.
                </p>
                <p>
                    If we take a look at the code, we see the two properties that we decided to expose to the PlugIns. There is a
                    Counter property:
                </p>
                <figure>
<pre><code class="csharp">public string Counter
{
	get
	{
		return "Counter value goes here";
	}
}</code></pre>
                    <figcaption>Fig06-053</figcaption>
                </figure>
                <p>which in the real-life MainViewModel is an observable property, but here it just returns a string purely for
                    design time purpose.
                </p>
                <p>There is also the IncrementCommand, which is defined here as an ICommand:</p>
                <figure>
<pre><code class="csharp">public ICommand IncrementCommand
{
	get;
	set;
}</code></pre>
                    <figcaption>Fig06-054</figcaption>
                </figure>
                <p>
                    Note that in this case, the Command is never even created, it doesn't matter because it is purely for design
                    time purpose.
                </p>
                <p>
                    So now we can instruct Blend to use this object at design time. First, let's build the application. And then
                    I'm going to change into Expression Blend and go here to the Data panel:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-055.png"/>
                    <figcaption>Fig 06-055</figcaption>
                </figure>
                <p>
                    I'm going to set the design-time DataContext:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-056.png"/>
                    <figcaption>Fig 06-056</figcaption>
                </figure>
                <p>
                    and here I can select DesignInstance:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-057.png"/>
                    <figcaption>Fig 06-057</figcaption>
                </figure>
                <p>
                    This is going to show me all the objects in the application and, for example, I can look for
                    DesignMainViewModel, which is here. We will also set the IsDesignTimeCreatable property to true, as we saw in
                    earlier modules. Let's click OK, and immediately we saw that design time data appears on the screen:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-058.png"/>
                    <figcaption>Fig 06-058</figcaption>
                </figure>
                <p>
                    and if needed, we can easily make changes in Blend, for example, change the FontSize, change the Foreground,
                    etc.
                </p>
                <p>
                    In XAML, here is how the design-time DataContext looks like:
                </p>
                <figure>
<pre><code class="xml">d:DataContext="{d:DesignInstance {x:Type Design:DesignMainViewModel},
    IsDesignTimeCreatable=True}"&gt;</code></pre>
                    <figcaption>Fig06-059</figcaption>
                </figure>
                <p>
                    Again, this is just like we demonstrated in earlier modules as one of the ways to set design time data in
                    Blend.
                </p>
                <p>
                    Then we are going to take advantage of the IncrementCommand. So I'm going to take a Button, add it here, and
                    let's do just a little bit of design, Reset the Layout, and maybe add a little bit of margin.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-060.png"/>
                    <figcaption>Fig 06-060</figcaption>
                </figure>
                <p>
                    Now I'm going to bind the Button's Command property to the IncrementCommand itself. And again, I'm going to
                    use a Binding Editor:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-061.png"/>
                    <figcaption>Fig 06-061</figcaption>
                </figure>
                <p>
                    And here, too, because we have design time data, we can simple select IncrementCommand and click OK.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-062.png"/>
                    <figcaption>Fig 06-062</figcaption>
                </figure>
                <p>
                    Now we are going to use this PlugIn in the application. So first I'm going to build the PlugIn assembly, and
                    then I'm going to go into the Debug folder. Let's copy this DLL:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-063.png"/>
                    <figcaption>Fig 06-063</figcaption>
                </figure>
                <p>and I'm going to place it in the PlugIns folder, which is located here:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-064.png"/>
                    <figcaption>Fig 06-064</figcaption>
                </figure>
                <p>
                    Now remember that the location of this PlugIns folder is set in the application Settings. So I can change the
                    location of the folder at any time and then simply restart the application without recompiling.
                </p>
                <p>
                    Now I can run the application, and let's reload the plug-ins. And here we go, we see that one plug-in was
                    found in the Plug-ins folder and was successfully loaded.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-065.png"/>
                    <figcaption>Fig 06-065</figcaption>
                </figure>
                <p>
                    Now I can increment the Counter directly from the application, and here we see that the plug-in, through the
                    Databinding, reacts to the PropertyChanged event:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-066.png"/>
                    <figcaption>Fig 06-066</figcaption>
                </figure>
                <p>
                    And finally, we can also invoke the Command directly from the Plug-in and we see that the Counter is also
                    incremented.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-067.png"/>
                    <figcaption>Fig 06-067</figcaption>
                </figure>
                <h3>Plug-Ins: Sending a Message to the Plug-Ins</h3>
                <p>The PlugIns can also define their own ViewModels. For example, here I added a PartialViewModel inside the
                    PlugIn1.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-068.png"/>
                    <figcaption>Fig 06-068</figcaption>
                </figure>
                <p>
                    When the PartialViewModel is constructed, I'm going to register to the MVVM Light's Messenger:
                </p>
                <figure>
<pre><code class="csharp">public PartialViewModel()
{
	Messenger.Default.Register&lt;NotificationMessage&gt;(
		this,
		HandleNotification);
}</code></pre>
                    <figcaption>Fig06-069</figcaption>
                </figure>
                <p>
                    Remember earlier, we saw that when the PlugIns are unloaded by the PlugInHost, a NotificationMessage is sent
                    through the Messenger. So here in the PlugIn's PartialViewModel, we can listen to that message. Then I can add
                    the method that is going to handle the NotificationMessage.
                </p>
                <figure>
<pre><code class="csharp">private void HandleNotification(NotificationMessage message)
{
    if (message.Notification == Notifications.CleanupNotification)
    {
        Messenger.Default.Unregister(this);
    }
}</code></pre>
                    <figcaption>Fig06-070</figcaption>
                </figure>
                <p>
                    And here, if this is a CleanupNotification, we are going to Unregister this PlugIn from the Messenger in order
                    to avoid memory leaks.
                </p>
                <p>
                    Of course, in a real-life scenario, it is very useful for the PlugIn to be notified so, for example, files can
                    be closed or database connections, maybe some logs can be recorded, etc.
                </p>
                <p>
                    The Messenger can obviously be used for other purposes as well, such as sending a value to the PlugIns. The
                    advantage of the Messenger is quite obvious here, since the sender does not have to know how many PlugIns, if
                    any, are loaded.
                </p>
                <p>The Messenger can also be used to send values and objects; for example, a SelectedUser, etc. Let's add this
                    feature to the MainViewModel and to the MainWindow, and then we will communicate this information to the
                    interested PlugIns.
                </p>
                <p>
                    Now I am back into the MainApplication's Window, into the Host, and we will use a Messenger in order to send
                    an object to all the PlugIns. We will call that object, the User. So let's add this object into the Contracts
                    assembly:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-071.png"/>
                    <figcaption>Fig 06-071</figcaption>
                </figure>
                <p>
                    Of course, this is important to add it to the contract, because everybody in the application must know about
                    this user.
                </p>
                <p>
                    Let's open the User class, and we see that it is quite simple; it just has two Observable properties, the
                    FirstName and the LastName:
                </p>
                <figure>
<pre><code class="csharp">namespace PlugInSample.Contracts
{
    public class User : ObservableObject
    {
        public const string FirstNamePropertyName = "FirstName";
        public const string LastNamePropertyName = "LastName";

        private string _firstName = "First name";
        private string _lastName = "Last name";

        public string FirstName
        {
            get
            {
                return _firstName;
            }
            set
            {
                Set(() =&gt; FirstName, ref _firstName, value);
            }
        }

        public string LastName
        {
            get
            {
                return _lastName;
            }
            set
            {
                Set(() =&gt; LastName, ref _lastName, value);
            }
        }
    }
}</code></pre>
                    <figcaption>Fig06-072</figcaption>
                </figure>
                <p>
                    Then I will use this object into the MainViewModel inside the MainApplication. First, I'm going to add an
                    Observable property called CurrentUser and, of course, here, we could use the mvvminpc snippet that we saw
                    before:
                </p>
                <figure>
<pre><code class="csharp">public const string CurrentUserPropertyName = "CurrentUser";

        private User _currentUser = new User();

        public User CurrentUser
        {
            get
            {
                return _currentUser;
            }
            set
            {
                Set(() =&gt; CurrentUser, ref _currentUser, value);
            }
        }</code></pre>
                    <figcaption>Fig06-073</figcaption>
                </figure>
                <p>
                    Then a little bit further down, I'm going to add a Command, which is going to be used to send the CurrentUser
                    to all the interested PlugIns:
                </p>
                <figure>
<pre><code class="csharp"> private RelayCommand _sendUserCommand;

public RelayCommand SendUserCommand
{
    get
    {
        return _sendUserCommand
               ?? (_sendUserCommand = new RelayCommand(
                   () =&gt; Messenger.Default.Send(
                       new NotificationMessage&lt;User&gt;(
                           this,
                           CurrentUser,
                           Notifications.NewUserNotification))));
    }
}</code></pre>
                    <figcaption>Fig06-074</figcaption>
                </figure>
                <p>
                    So let's check the code. What I'm going to do is send a new NotificationMessage of user:
                </p>
<figure>
<pre><code class="csharp">() =&gt; Messenger.Default.Send(
   new NotificationMessage&lt;User&gt;(</code></pre>
<figcaption>Fig06-075</figcaption>
</figure>
                <p>
                    so this is a special message type, which carries a notification and also a payload:
                </p>
<figure>
<pre><code class="csharp">CurrentUser,
Notifications.NewUserNotification))));</code></pre>
<figcaption>Fig06-076</figcaption>
</figure>
                <p>in this case the CurrentUser. For example, this could be a notification when a new user looks into the
                    application, etc. Now let's prepare the PlugIn to receive the message.
                </p>
                <p>
                    First, I add a property, which will display the UserFullName, according to a specific format:
                </p>
<figure>
<pre><code class="csharp">public const string UserFullNamePropertyName = "UserFullName";

private string _userFullName = "No user yet";

public string UserFullName
{
    get
    {
        return _userFullName;
    }
    set
    {
        Set(() =&gt; UserFullName, ref _userFullName, value);
    }
}</code></pre>
<figcaption>Fig06-077</figcaption>
</figure>
                <p>
                    Then, inside the constructor, I will add another registration to the MVVM Light Messenger:
                </p>
<figure>
<pre><code class="csharp">public PartialViewModel()
{
    Messenger.Default.Register&lt;NotificationMessage&gt;(
        this,
        HandleNotification);

    Messenger.Default.Register&lt;NotificationMessage&lt;User&gt;&gt;(
        this,
        message =&gt;
        {
            if (message.Notification == Notifications.NewUserNotification)
            {
                UserFullName = string.Format(
                    "{0}, {1}",
                    message.Content.LastName,
                    message.Content.FirstName);
            }
        });
}</code></pre>
<figcaption>Fig06-078</figcaption>
</figure>
                <p>
                    We will check if the Notification is a NewUserNotification:
                </p>
<figure>
<pre><code class="csharp">if (message.Notification == Notifications.NewUserNotification)</code></pre>
<figcaption>Fig06-079</figcaption>
</figure>
                <p>and if that is the case, we will use a message.Content to create the UserFullName according to a specific
                    format:
                </p>
<figure>
<pre><code class="csharp">UserFullName = string.Format(
    "{0}, {1}",
    message.Content.LastName,
    message.Content.FirstName);</code></pre>
<figcaption>Fig06-080</figcaption>
</figure>
                <p>
                    Now that the PartialViewModel is ready, let's use it in the XAML. I will add a snippet of XAML here, this is a
                    Grid containing a few elements:
                </p>
<figure>
<pre><code class="xml">&lt;Grid Grid.Row="1"
	  x:Name="PartialPanel"
	  d:DataContext="{d:DesignInstance IsDesignTimeCreatable=True, Type={x:Type viewModel:PartialViewModel}}"
	  Grid.RowSpan="2"&gt;
	&lt;Grid.RowDefinitions&gt;
		&lt;RowDefinition /&gt;
		&lt;RowDefinition /&gt;
	&lt;/Grid.RowDefinitions&gt;

	&lt;StackPanel Orientation="Vertical"
				HorizontalAlignment="Center"
				VerticalAlignment="Center"&gt;
		&lt;TextBlock Text="User"
				   Foreground="White"
				   HorizontalAlignment="Center" /&gt;

		&lt;TextBlock Text="{Binding UserFullName}"
				   HorizontalAlignment="Center"
				   VerticalAlignment="Center"
				   Foreground="White"
				   FontSize="24" /&gt;
	&lt;/StackPanel&gt;
&lt;/Grid&gt;</code></pre>
<figcaption>Fig06-081</figcaption>
</figure>
                <p>
                    There is a TextBlock here:
                </p>
<figure>
<pre><code class="xml">&lt;TextBlock Text="{Binding UserFullName}"
   HorizontalAlignment="Center"
   VerticalAlignment="Center"
   Foreground="White"
   FontSize="24" /&gt;</code></pre>
<figcaption>Fig06-082</figcaption>
</figure>
                <p>
                    which is data bound to the UserFullName property that we added to the PartialViewModel. So now we need to set
                    the DataContext of this Grid to the PartialViewModel, which we can do in code behind. In the
                    PlugInControl1.xaml.cs, I will use this line of code in the constructor to set the PartialPanel's DataContext
                    to a new PartialViewModel:
                </p>
<figure>
<pre><code class="csharp">public partial class PlugInControl1
{
    public PlugInControl1()
    {
        InitializeComponent();
        PartialPanel.DataContext = new PartialViewModel();
    }
}</code></pre>
<figcaption>Fig06-083</figcaption>
</figure>
                <p>
                    Of course, because the DataContext is set in the code behind, it means that we need a design-time DataContext
                    for the Visual Designer, in case we need it for design time data. This is easy to set up.
                </p>
                <p>
                    So here in the PartialViewModel, inside the constructor, I'm going to add some design time code, which is
                    going to detect the DesignMode, and in case the DesignMode is active, we are going to set the UserFullName to
                    a known value:
                </p>
<figure>
<pre><code class="csharp">#if DEBUG
    if (IsInDesignMode)
    {
        UserFullName = "Bugnion, Laurent";
    }
#endif</code></pre>
<figcaption>Fig06-084</figcaption>
</figure>
                <p>
                    Now I can build the application at this point. And if we take a quick look in Blend, we can see that the
                    design time data is working:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-085.png"/>
                    <figcaption>Fig 06-085</figcaption>
                </figure>
                <p>
                    and now we could use a Visual Designer to polish the design of this PlugIn.
                </p>
                <p>
                    Now I can test the feature in the MainApplication. I have copied the updated version of PlugIn1 into the
                    Plugins folder, so now I can reload the plug-ins, here we go:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-086.png"/>
                    <figcaption>Fig 06-086</figcaption>
                </figure>
                <p>and we see that the user has not been set yet. I also added this UI to the MainWindow:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-087.png"/>
                    <figcaption>Fig 06-087</figcaption>
                </figure>
                <p>
                    which is going to allow me to send a message to the plugins using the Messenger, just like we saw before. Here
                    I can go in and enter any name, for example Albert Einstein:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-088.png"/>
                    <figcaption>Fig 06-088</figcaption>
                </figure>
                <p>
                    And then I can send this name to the plugins, and here we see that the first plugin has actually received the
                    name.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-089.png"/>
                    <figcaption>Fig 06-089</figcaption>
                </figure>
                <h3>Plug-Ins: Using a Dataservice Inside the Plug-In</h3>
                <p>Now I would like to show how the PlugIns can get access to services, which are defined inside the Main
                    assembly, or any other assembly for this matter.
                </p>
                <p>
                    So first I'm going to add some objects to the Contracts assembly. Everything we want to share with the PlugIns
                    must be added inside the Contracts assembly, which is referenced everywhere. And here I'm going to add an
                    IDataService interface and the TestObject:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-090.png"/>
                    <figcaption>Fig 06-090</figcaption>
                </figure>
                <p>
                    Let's take a look at IDataService. This is a very simple interface, which has just one method:
                </p>
<figure>
<pre><code class="csharp">Task&lt;TestObject&gt; GetTestObject();
</code></pre>
<figcaption>Fig06-091</figcaption>
</figure>
                <p>
                    and this method is going to be used asynchronously to retrieve a TestObject.
                </p>
                <p>
                    The TestObject itself has two properties:
                </p>
<figure>
<pre><code class="csharp">namespace PlugInSample.Contracts
{
    public class TestObject
    {
        public string Property1
        {
            get;
            set;
        }

        public int Property2
        {
            get;
            set;
        }
    }
}</code></pre>
<figcaption>Fig06-092</figcaption>
</figure>
                <p>We already saw something like that in the previous module, when we were demonstrating NuGet and the Json.NET
                    assemblies. Now we are going to implement the DataService inside the Main assembly, so let's add a New Class:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-093.png"/>
                    <figcaption>Fig 06-093</figcaption>
                </figure>
                <p>I'm going to name that DataService. Let's make it public. And I'm going to implement IDataService, which is
                    defined inside the Contracts assembly:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-094.png"/>
                    <figcaption>Fig 06-094</figcaption>
                </figure>
                <p>And now I can add the implementation of the GetTestObject method, which is going to retrieve the json file from
                    the web server and use Json.NET to deserialize this into a TestObject:
                </p>
<figure>
<pre><code class="csharp">public async Task&lt;TestObject&gt; GetTestObject()
{
    var client = new HttpClient();

    var json = await client.GetStringAsync(
        new Uri("http://www.galasoft.ch/labs/pluralsight/nugetintro/jsonsample.txt"));

    var instance = JsonConvert.DeserializeObject&lt;TestObject&gt;(json);
    return instance;
}</code></pre>
<figcaption>Fig06-095</figcaption>
</figure>
                <p>
                    Now I can register the DataService inside the ViewModelLocator, like we did multiple times during this course.
                    And I'm going to do this, here, inside the constructor:
                </p>
<figure>
<pre><code class="csharp">static ViewModelLocator()
{
    ServiceLocator.SetLocatorProvider(() =&gt; SimpleIoc.Default);

    if(ViewModelBase.IsInDesignModeStatic)
    {
        //SimpleIoc.Default.Register&lt;IDataService, DesignDataService&gt;();
    }
    else
    {
        SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
    }

    SimpleIoc.Default.Register&lt;Bootstrapper&gt;();
    SimpleIoc.Default.Register&lt;MainViewModel&gt;();
}</code></pre>
<figcaption>Fig06-096</figcaption>
</figure>
                <p>
                    And, of course, just like before, I could also go ahead and define a DesignDataService used at design time,
                    but here for the purpose of the demo, I'm not going to do that.
                </p>
                <p>
                    Now let's go back to the PlugIn assembly. Here, I'm going to start by adding a property to retrieve the
                    DataService from the IOC container:
                </p>
<figure>
<pre><code class="csharp">public class PartialViewModel : ViewModelBase
{
	public IDataService DataService
        {
            get
            {
                return ServiceLocator.Current.GetInstance&lt;IDataService&gt;();
            }
        }
}</code></pre>
<figcaption>Fig06-097</figcaption>
</figure>
                <p>
                    This is the same DataService that we just registered into the MainApplication's ViewModelLocator. Of course,
                    because we are using the IDataService abstraction, it could be any implementation; we don't need to know about
                    it.
                </p>
                <p>
                    Now I can go ahead and add a RelayCommand here, so I'm going to use mvvmr, like before, and I will call this,
                    _callServiceCommand, here we go. And here, too, CallServiceCommand:
                </p>
<figure>
<pre><code class="csharp">private RelayCommand _callServiceCommand;

/// &lt;summary&gt;
/// Gets the CallServiceCommand.
/// &lt;/summary&gt;
public RelayCommand CallServiceCommand
{
    get
    {
        return _callServiceCommand
            ?? (_callServiceCommand = new RelayCommand(
                () =&gt;
                {

                }));
    }
}</code></pre>
<figcaption>Fig06-098</figcaption>
</figure>
                <p>
                    Let's implement this command now, so I'm going to drag the code here:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// Gets the CallDataServiceCommand.
/// &lt;/summary&gt;
public RelayCommand CallDataServiceCommand
{
    get
    {
        return _callDataServiceCommand
            ?? (_callDataServiceCommand = new RelayCommand(
                async () =&gt;
                {
                       try
                       {
                           var instance = await DataService.GetTestObject();

                           MessageBox.Show(
                               string.Format(
                                   "{0} : {1}",
                                   instance.Property1,
                                   instance.Property2));
                       }
                       catch (Exception ex)
                       {
                           MessageBox.Show(ex.Message);
                       }

                }));
    }
}</code></pre>
<figcaption>Fig06-099</figcaption>
</figure>
                <p>
                    And what we will do here is call the DataService in order to get the TestObject:
                </p>
<figure>
<pre><code class="csharp">var instance = await DataService.GetTestObject();</code></pre>
<figcaption>Fig06-100</figcaption>
</figure>
                <p>
                    Of course, this is an asynchronous method so we need to await that, and because this is awaited, I need to set
                    this lambda expression to async:
                </p>
<figure>
<pre><code class="csharp">async () =&gt;
{
       try
       {
           var instance = await DataService.GetTestObject();

           MessageBox.Show(
               string.Format(
                   "{0} : {1}",
                   instance.Property1,
                   instance.Property2));
       }
       catch (Exception ex)
       {
           MessageBox.Show(ex.Message);
       }

}));</code></pre>
<figcaption>Fig06-101</figcaption>
</figure>
                <p>
                    Once a TestObject is retrieved, we are simply going to show a MessageBox for the demo, but of course in a
                    production application, we would actually use those values.
                </p>
                <p>
                    In the user interface, I added a Button, which is data bound to the Command that we just added:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-102.png"/>
                    <figcaption>Fig 06-102</figcaption>
                </figure>
                <p>
                    Now we are ready to test again. What I did before is that I built the plugin and then I made sure to copy the
                    latest version from the Bin, Debug folder inside the Plugins folder so that the application can find the
                    latest version.
                </p>
                <p>
                    Now I'm going to reload the plug-in. Here we see the new UI that we just created, and if I go ahead and call
                    the DataService, this will call the GetObject method and trigger the MessageBox to be shown:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-103.png"/>
                    <figcaption>Fig 06-103</figcaption>
                </figure>
                <p>
                    So even though the DataService was implemented in the Main assembly, our plugin was able to use it thanks to
                    the IDataService interface, and of course through the IOC container.
                </p>
                <h3>Plug-Ins: Building a Second Plug-In</h3>
                <p>In this whole demo so far, we have used only one PlugIn, but of course it is very easy to build a second one.
                </p>
                <p>
                    So here is a new class library, in which I added a new user control:
                </p>
<figure>
<pre><code class="csharp">public class PlugInManager : IPlugIn
{
    public string Name
    {
        get
        {
            return "Plug-in # 2";
        }
    }

    public FrameworkElement GetElement()
    {
        return new AnotherPlugInControl();
    }
}</code></pre>
<figcaption>Fig06-104</figcaption>
</figure>
                <p>
                    In the References folder, I added a reference to the Contracts assembly, like just before:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-105.png"/>
                    <figcaption>Fig 06-105</figcaption>
                </figure>
                <p>
                    And here, I also implemented the PlugInManager with a Name and, of course, a GetElement method:
                </p>
<figure>
<pre><code class="csharp">public string Name
{
    get
    {
        return "Plug-in # 2";
    }
}

public FrameworkElement GetElement()
{
    return new AnotherPlugInControl();
}</code></pre>
<figcaption>Fig06-106</figcaption>
</figure>
                <p>
                    And I also added the DesignMainViewModel, just like before. So let's go in Blend and do a little bit of
                    design. First of all, I'm going to set the design-time DataContext, just like before, let's select here
                    DesignInstance. I'm going to look for DesignMainViewModel, and set IsDesignTimeCreatable to true:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-107.png"/>
                    <figcaption>Fig 06-107</figcaption>
                </figure>
                <p>
                    Then I'm going to take this Grid, and let's make it another color, for example green. I'm going to take a
                    TextBlock and then I'm going to put it in the middle. And, of course, we can do a little bit of design here.
                    First of all, let's do that quite a lot bigger and maybe white is nicer:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-108.png"/>
                    <figcaption>Fig 06-108</figcaption>
                </figure>
                <p>
                    Then I'm going to do some Databinding, so let's take here, the Data Binding Editor:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-109.png"/>
                    <figcaption>Fig 06-109</figcaption>
                </figure>
                <p>
                    and I'm going to bind this to the Counter property on the MainViewModel:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-110.png"/>
                    <figcaption>Fig 06-110</figcaption>
                </figure>
                <p>
                    Finally, we can be a little bit creative; this is the beauty of Blend. Let's create, here, a new Storyboard:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-111.png"/>
                    <figcaption>Fig 06-111</figcaption>
                </figure>
                <p>and what I'm going to say is that after 1 second</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-112.png"/>
                    <figcaption>Fig 06-112</figcaption>
                </figure>
                <p>I want this element here to be rotated by 360 degrees:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-113.png"/>
                    <figcaption>Fig 06-113</figcaption>
                </figure>
                <p>
                    I'm going to select to stop here and choose an Easing function; for example, Cubic:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-114.png"/>
                    <figcaption>Fig 06-114</figcaption>
                </figure>
                <p>
                    We can go ahead and test that directly to Blend. Ok. And then finally, what I'm going to do is, select here
                    the Storyboard, and set AutoReverse to true, and set the RepeatBehavior to Forever, which means that the
                    animation will go and then come back:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-115.png"/>
                    <figcaption>Fig 06-115</figcaption>
                </figure>
                <p>
                    And this will continue forever during the lifetime of the application. So now we have our PlugIn ready. I can
                    build it, and now I'm going to copy the DLL into the Plugins folder. So let's go here into the Explorer, bin,
                    Debug. I'm going to take here just the PlugIn2 DLL:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-116.png"/>
                    <figcaption>Fig 06-116</figcaption>
                </figure>
                <p>
                    let's copy that. And then I'm going to go into the Plugins folder, where I already have the PlugIn1, Paste
                    this:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-117.png"/>
                    <figcaption>Fig 06-117</figcaption>
                </figure>
                <p>
                    And now if we run the application without any modification to the Host, we can reload the plugin and we see
                    that now we have two plugins:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-118.png"/>
                    <figcaption>Fig 06-118</figcaption>
                </figure>
                <p>
                    and the functionality is still there. For example, if I increment the Counter, we see that all the values
                    change, just like it was expected:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-119.png"/>
                    <figcaption>Fig 06-119</figcaption>
                </figure>
                <p>
                    This complex demo shows the power of the Model-View-ViewModel Pattern and, of course, of the MVVM Light
                    Toolkit in the context of a very, very decoupled application using Plug-ins.
                </p>
                <p>
                    Now to be clear, not all applications need Plug-ins and, in fact, in the context of WPF, this is probably best
                    for relatively large applications, but even for smaller apps, Plug-ins can be useful; for example, think about
                    a Windows Phone Application where you can have in-application purchase of new functionality implemented as
                    Plug-ins.
                </p>
                <p>
                    Because of the high level of abstraction between the application's components, MVVM Light's elements are very
                    well suited to help you build the functionalities that you need in a much easier manner.
                </p>
                <h3>Expandable List: Preparing the Infrastructure</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex06-003" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 6\before\SelectableList\SelectableList.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex06-003">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex06-004" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 6\after\SelectableList\SelectableList.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex06-004">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>In this second sample, we will see an application of the Messenger component of MVVM Light. This is especially
                    useful when you don't know in advance how many recipients will subscribe to a message, from 0 to a large
                    number.
                </p>
                <p>
                    This can also be useful in the user interface layer, as we will see here.
                </p>
                <p>
                    In Windows Phone, there is a well-known user experience pattern, where List elements can be expanded by
                    tapping on the left-most side of the screen. They will slide to reveal a checkbox, which can be used to select
                    the items on which certain operations must be performed; for example, we see that behavior in the Email
                    Application in the Emulator.
                </p>
                <p>Here, we see the messages.</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-120.png"/>
                    <figcaption>Fig 06-120</figcaption>
                </figure>
                <p>
                    In order to select them, for example, for deletion, we can tap on the side of the screen here. Notice that the
                    item that we tapped is immediately selected:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-121.png"/>
                    <figcaption>Fig 06-121</figcaption>
                </figure>
                <p>
                    Also, we see that the sliding is done with an animation. We can select multiple items like that. And now if I
                    deselect them, we notice that when we deselect the last item, the list will collapse back into place.
                </p>
                <p>
                    In our application, we want to use MVVM, and so the List is actually representing an ItemViewModel. So
                    ViewModel will expose an IsSelected Boolean property, as well as an IsExpanded property, which is also a
                    Boolean.
                </p>
                <p>
                    In order to manage these properties and all the interaction, we can create a BaseViewModel that these items
                    will _____; we will name that the SelectableViewModel. Let's check the SelectableViewModel's code.
                </p>
                <p>
                    First we see the two properties that I just mentioned, IsExpanded and IsSelected.
                </p>
<figure>
<pre><code class="csharp">public bool IsExpanded
{
    get
    {
        return _isExpanded;
    }
    set
    {
        Set(() => IsExpanded, ref _isExpanded, value);
    }
}

public const string IsSelectedPropertyName = "IsSelected";

private bool _isSelected;

public bool IsSelected</code></pre>
<figcaption>Fig06-122</figcaption>
</figure>
                <p>IsExpanded is a standard observable property, which works because a SelectableViewModel inherits the MVVM Light
                    ViewModelBase:
                </p>
<figure>
<pre><code class="csharp">public class SelectableViewModel : ViewModelBase</code></pre>
<figcaption>Fig06-123</figcaption>
</figure>
                <p>
                    The IsSelected property is a little bit more complex; we'll come to that in a moment. Let's scroll down for
                    now. Here, we expose a Command, which is called ExpandCommand:
                </p>
<figure>
<pre><code class="csharp">public RelayCommand ExpandCommand</code></pre>
<figcaption>Fig06-124</figcaption>
</figure>
                <p>
                    This is what will be actuated by the small button on the far left of the screen. What happened when this
                    command is actuated is this; first, the IsExpanded property is set to true:
                </p>
<figure>
<pre><code class="csharp">IsExpanded = true;</code></pre>
<figcaption>Fig06-125</figcaption>
</figure>
                <p>
                    then the IsSelected value is also set to true:
                </p>
<figure>
<pre><code class="csharp">IsSelected=true;</code></pre>
<figcaption>Fig06-126</figcaption>
</figure>
                <p>
                    because when the button is tapped, we want the corresponding item to be selected, just like we saw in the
                    Email Application. Then comes the important part, we use a Messenger to send an ExpandMessage:
                </p>
<figure>
<pre><code class="csharp">Messenger.Default.Send(new ExpandMessage(this, IsExpanded));</code></pre>
<figcaption>Fig06-127</figcaption>
</figure>
                <p>
                    This is because the other items in the list must also expand when one item gets expanded.
                </p>
                <p>
                    The ExpandMessage is here:
                </p>
<figure>
<pre><code class="csharp">public class ExpandMessage : GenericMessage&lt;bool&gt;</code></pre>
<figcaption>Fig06-128</figcaption>
</figure>
                <p>
                    and we see that it is a simple GenericMessage of bool. It means that it is sent carrying a simple Boolean
                    value as payload. Because it has a specific type, however, there can be no confusion as of the intent of the
                    message.
                </p>
                <p>
                    Back to SelectableViewModel, the next interesting method is a constructor. Here, we register each item for two
                    different message types. The first one is the ExpandMessage that we just saw:
                </p>
<figure>
<pre><code class="csharp"> Messenger.Default.Register&lt;ExpandMessage&gt;(
    this,
    msg =&gt;
    {
        if (msg.Sender != this)
        {
            IsExpanded = msg.Content;
        }
    });</code></pre>
<figcaption>Fig06-129</figcaption>
</figure>
                <p>
                    First, we will check if the Sender is the item itself:
                </p>
<figure>
<pre><code class="csharp"> if (msg.Sender != this)
{
    IsExpanded = msg.Content;
}</code></pre>
<figcaption>Fig06-130</figcaption>
</figure>
                <p>
                    This is necessary, because the item can both send and receive ExpandMessages. In order to avoid unwanted
                    effects, we need to prevent the item from doing anything if the Message received was sent by the item itself.
                </p>
                <p>
                    The next message type that we'll register for is a little bit more tricky. We use that to gather some
                    information from all the items. What we want to know is if an item is currently selected or not. If all items
                    are unselected, we want the whole list to collapse.
                </p>
<figure>
<pre><code class="csharp">public SelectableViewModel()
{
    Messenger.Default.Register&lt;ExpandMessage&gt;(
        this,
        msg =&gt;
        {
            if (msg.Sender != this)
            {
                IsExpanded = msg.Content;
            }
        });

    Messenger.Default.Register&lt;IsItemSelectedMessage&gt;(
        this,
        msg =&gt; msg.Execute(IsSelected));
}</code></pre>
<figcaption>Fig06-131</figcaption>
</figure>
                <p>
                    In order to do this, we will use a different type of message, called IsItemSelectedMessage. Let's take a look
                    at the code. Here is a code of IsItemSelectedMessage:
                </p>
<figure>
<pre><code class="csharp">using System;
using GalaSoft.MvvmLight.Messaging;

namespace SelectableList.ViewModel
{
    public class IsItemSelectedMessage : MessageBase
    {
        private readonly Action&lt;bool&gt; _callback;

        public IsItemSelectedMessage(object sender, Action&lt;bool&gt; callback)
            : base(sender)
        {
            _callback = callback;
        }

        public void Execute(bool result)
        {
            if (_callback != null)
            {
                _callback(result);
            }
        }
    }
}</code></pre>
<figcaption>Fig06-132</figcaption>
</figure>
                <p>
                    This message has an Action as payload, which is a _callback:
                </p>
<figure>
<pre><code class="csharp">private readonly Action&lt;bool&gt; _callback;</code></pre>
<figcaption>Fig06-133</figcaption>
</figure>
                <p>
                    The _callback should immediately be executed when the message is received, in order to inform the sender about
                    the state of the item. To allow this, the message has an Execute method:
                </p>
<figure>
<pre><code class="csharp">public void Execute(bool result)
{
    if (_callback != null)
    {
        _callback(result);
    }
}</code></pre>
<figcaption>Fig06-134</figcaption>
</figure>
                <p>
                    which is just a friendly way to execute the _callback.
                </p>
                <p>
                    So here, back into the SelectableViewModel, how do we use this message? First, in the item constructor, we
                    register for this message type:
                </p>
<figure>
<pre><code class="csharp">Messenger.Default.Register&lt;IsItemSelectedMessage&gt;(
    this,
    msg =&gt; msg.Execute(IsSelected));</code></pre>
<figcaption>Fig06-135</figcaption>
</figure>
                <p>
                    When it is received, the Execute method is called on the message:
                </p>
<figure>
<pre><code class="csharp">msg =&gt; msg.Execute(IsSelected));</code></pre>
<figcaption>Fig06-136</figcaption>
</figure>
                <p>
                    What it does is very simple; it just returns a value of the IsSelected property to the sender. This way, the
                    sender will know the state of all the items in the list.
                </p>
                <p>
                    Let's see who sent the IsSelected message. This happened here, all the way up into the IsSelected property:
                </p>
<figure>
<pre><code class="csharp">public bool IsSelected
{
    get
    {
        return _isSelected;
    }
    set
    {
        if (Set(() => IsSelected, ref _isSelected, value))
        {
            if (!_isSelected)
            {
                var allItemsAreUnselected = true;

                Messenger.Default.Send(
                    new IsItemSelectedMessage(
                        this,
                        result =>
                        {
                            allItemsAreUnselected &= !result;
                        }));

                if (allItemsAreUnselected)
                {
                    IsExpanded = false;
                    Messenger.Default.Send(new ExpandMessage(this, false));
                }
            }
        }
    }
}</code></pre>
<figcaption>Fig06-137</figcaption>
</figure>
                <p>
                    Because this property will be data bound to the item's checkbox in the user interface, we know when the user
                    deselects one item. If the value is false:
                </p>
<figure>
<pre><code class="csharp">if (!_isSelected)</code></pre>
<figcaption>Fig06-138</figcaption>
</figure>
                <p>
                    we need to check all the other items, in order to know if the list should be collapsed. So we will ask all the
                    items by sending the IsItemSelectedMessage here:
                </p>
<figure>
<pre><code class="csharp">Messenger.Default.Send(
    new IsItemSelectedMessage(
        this,
        result =&gt;
        {
            allItemsAreUnselected &= !result;
        }));</code></pre>
<figcaption>Fig06-139</figcaption>
</figure>

                <p>
                    When an item executes a callback, we check the result and we use this to compute the global value of all the
                    items.
                </p>
<figure>
<pre><code class="csharp">allItemsAreUnselected &= !result;</code></pre>
<figcaption>Fig06-140</figcaption>
</figure>
                <p>
                    Then, if all the items replied that they are already unselected, we can collapse the list by sending an
                    ExpandMessage with the value of false:
                </p>
<figure>
<pre><code class="csharp">if (allItemsAreUnselected)
{
    IsExpanded = false;
    Messenger.Default.Send(new ExpandMessage(this, false));
}</code></pre>
<figcaption>Fig06-141</figcaption>
</figure>
                <p>
                    Now let's see how we can use this SelectableViewModel inside an application. So here I create an
                    ItemViewModel, which derives from SelectableViewModel:
                </p>
<figure>
<pre><code class="csharp"> public class ItemViewModel : SelectableViewModel
{
    public string Title
    {
        get;
        set;
    }
}</code></pre>
<figcaption>Fig06-142</figcaption>
</figure>
                <p>
                    For the demo, it is very simple and has just one Text property. Inside the MainViewModel here, I added an
                    ObservableCollection of ItemViewModel:
                </p>
<figure>
<pre><code class="csharp">public ObservableCollection&lt;ItemViewModel&gt; Items
{
    get;
    set;
}</code></pre>
<figcaption>Fig06-143</figcaption>
</figure>
                <p>
                    and here inside the constructor, I create two initial items, which I add to the collection. I also added a
                    RelayCommand here:
                </p>
<figure>
<pre><code class="csharp">public RelayCommand AddItemCommand
{
    get
    {
        return _addItemCommand
               ?? (_addItemCommand = new RelayCommand(
                   () =&gt;
                   {
                       var expanded = Items.Any(i =&gt; i.IsExpanded);
                       var item = new ItemViewModel
                       {
                           Title = "Item # " + (Items.Count + 1),
                           IsExpanded = expanded
                       };

                       Items.Add(item);
                   }));
    }
}</code></pre>
<figcaption>Fig06-144</figcaption>
</figure>
                <p>
                    which is going to be used to add new items to the list on the go.
                </p>
                <p>
                    When an item is created and added to the list, I set the IsExpanded property according to the state of the
                    other items:
                </p>
<figure>
<pre><code class="csharp">var expanded = Items.Any(i =&gt; i.IsExpanded);
var item = new ItemViewModel
{
   Title = "Item # " + (Items.Count + 1),
   IsExpanded = expanded
};

Items.Add(item);</code></pre>
<figcaption>Fig06-145</figcaption>
</figure>
                <p>
                    Know that I could also use the IsItemSelectedMessage here if I wanted to, but it is easy enough to use a query
                    against the items in the Observable Collection instead.
                </p>
<figure>
<pre><code class="csharp">var expanded = Items.Any(i =&gt; i.IsExpanded);</code></pre>
<figcaption>Fig06-146</figcaption>
</figure>
                <h3>Expandable List: Creating the UI and TestingX</h3>
                <p>
                    Let's look at the User Interface in Blend now. Right now it is not really what we want. We have a Button, a
                    checkbox, and the item's title:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-147.png"/>
                    <figcaption>Fig 06-147</figcaption>
                </figure>
                <p>
                    We see the two items created and available as design time data. We already saw how to create design time data
                    for an MVVM Light Application, so I don't go further for now.
                </p>
                <p>
                    Let's Edit the Template for the first item:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-148.png"/>
                    <figcaption>Fig 06-148</figcaption>
                </figure>
                <p>
                    Let's hide everything except the Expand button for now:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-149.png"/>
                    <figcaption>Fig 06-149</figcaption>
                </figure>
                <p>
                    We want this button to look very narrow and to be placed at the far left of the screen. To do that, I created
                    a Styling Blend that I'm going to apply to the button:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-150.png"/>
                    <figcaption>Fig 06-150</figcaption>
                </figure>
                <p>
                    In the normal state, the button is invisible, but let's see what happens in the Template:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-151.png"/>
                    <figcaption>Fig 06-151</figcaption>
                </figure>
                <p>
                    Here I have the States, and if I go to the Pressed State, we set the background color to the phone's accent
                    brush:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-152.png"/>
                    <figcaption>Fig 06-152</figcaption>
                </figure>
                <p>
                    In the Emulator it is set to red by default, but depending on your User Settings, it can be a different color.
                    Let's go back to the ItemTemplate now. The next element we want to handle is a SelectionCheckBox. In the
                    default state of the item, it should be collapsed:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-153.png"/>
                    <figcaption>Fig 06-153</figcaption>
                </figure>
                <p>
                    which means that the width should be set to 0 pixels. Note that by default it is set to 68 pixels:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-154.png"/>
                    <figcaption>Fig 06-154</figcaption>
                </figure>
                <p>
                    remember this value because we will use it later. For now, let's set that to 0 pixels, and in order to get a
                    nicer transition, I will also set the Opacity to 0%.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-155.png"/>
                    <figcaption>Fig 06-155</figcaption>
                </figure>
                <p>
                    Now I will define the transition, and for this I will need the State Panel, which is selected here, and I'm
                    going to define two states. So, here, let's create a StateGroup and I'm going to call that ExpandStates. Then
                    I create a new state, which I'm going to call Expanded, and then another state, which I'm going to call
                    Collapsed:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-156.png"/>
                    <figcaption>Fig 06-156</figcaption>
                </figure>
                <p>
                    The Collapsed state is a default state for this item, so here I don't need to do anything. Let's record the
                    Expanded state. Notice that Blend is in recording mode, so everything I do now will be valid just for the
                    Expanded state.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-157.png"/>
                    <figcaption>Fig 06-157</figcaption>
                </figure>
                <p>
                    What we want to do is set the Opacity to 100%:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-158.png"/>
                    <figcaption>Fig 06-158</figcaption>
                </figure>
                <p>
                    and then I'm going to restore the Width of the item to 68 pixels, like we had before:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-159.png"/>
                    <figcaption>Fig 06-159</figcaption>
                </figure>
                <p>
                    Of course, we want this transition to be animated, so I'm going to set the transition time here to 0.3
                    seconds:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-160.png"/>
                    <figcaption>Fig 06-160</figcaption>
                </figure>
                <p>
                    and I'm also going to set the acceleration here to a nice Cubic Transition, like so:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-161.png"/>
                    <figcaption>Fig 06-161</figcaption>
                </figure>
                <p>
                    Now we need to trigger the transition to happen. Because we use MVVM, we can do that using a DataTrigger
                    behavior, and a GoToStateAction. So first of all, let's stop the recording.
                </p>
                <p>
                    Then I'm going to go to the Assets Library inside the Behaviors and I'm going to take a GoToStateAction and
                    drag it on the Grid here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-162.png"/>
                    <figcaption>Fig 06-162</figcaption>
                </figure>
                <p>
                    Actually, I need two GoToStateActions, one for the Expanded State and one for the Collapsed State. Let's take
                    the first one here. I'm going to change the TriggerType:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-163.png"/>
                    <figcaption>Fig 06-163</figcaption>
                </figure>
                <p>
                    to a DataTrigger:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-164.png"/>
                    <figcaption>Fig 06-164</figcaption>
                </figure>
                <p>
                    And then I'm going to do a Databinding using the Data Binding Editor here. And I'm going to trigger the
                    GoToStateAction when the value of IsExpanded changes:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-165.png"/>
                    <figcaption>Fig 06-165</figcaption>
                </figure>
                <p>
                    When the value is false, I want to go into the Collapsed State:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-166.png"/>
                    <figcaption>Fig 06-166</figcaption>
                </figure>
                <p>
                    And for the other GoToStateAction, I will do the same; replace the EventTrigger by a DataTrigger:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-167.png"/>
                    <figcaption>Fig 06-167</figcaption>
                </figure>
                <p>
                    and here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-168.png"/>
                    <figcaption>Fig 06-168</figcaption>
                </figure>
                <p>
                    the Binding to the IsExpanded property:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-169.png"/>
                    <figcaption>Fig 06-169</figcaption>
                </figure>
                <p>
                    When the value is true, I want to go into the Expanded State:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-170.png"/>
                    <figcaption>Fig 06-170</figcaption>
                </figure>
                <p>
                    I need a third GoToStateAction for the initial value of the item:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-171.png"/>
                    <figcaption>Fig 06-171</figcaption>
                </figure>
                <p>
                    When a new item is added, it needs to go to the correct state depending on the value of its IsExpanded
                    property. This time, instead of using a DataTrigger, I will use a default EventTrigger:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-172.png"/>
                    <figcaption>Fig 06-172</figcaption>
                </figure>
                <p>
                    I will handle the Loaded Event of the item:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-173.png"/>
                    <figcaption>Fig 06-173</figcaption>
                </figure>
                <p>
                    and here I will add a Condition:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-174.png"/>
                    <figcaption>Fig 06-174</figcaption>
                </figure>
                <p>
                    What I will do here is Create a new Data Binding to the IsExpanded property:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-175.png"/>
                    <figcaption>Fig 06-175</figcaption>
                </figure>
                <p>
                    and I will say that if the Condition is true, then I want to go into the Expanded State without any
                    transition:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-176.png"/>
                    <figcaption>Fig 06-176</figcaption>
                </figure>
                <p>
                    because this is an initial value, so I don't want the animation to happen.
                </p>
                <p>
                    Now that the States and Animations are defined, I just have to bind the UI elements to the ItemViewModel's
                    property. We already took care of the Title. For the checkbox, I'm going to bind the IsChecked property to the
                    IsSelected (Boolean) property here, with a TwoWay DataBinding:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-177.png"/>
                    <figcaption>Fig 06-177</figcaption>
                </figure>
                <p>
                    And for the Button here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-178.png"/>
                    <figcaption>Fig 06-178</figcaption>
                </figure>
                <p>I will go and find the Command property:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-179.png"/>
                    <figcaption>Fig 06-179</figcaption>
                </figure>
                <p>
                    and I will data bind this to the ExpandCommand:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-180.png"/>
                    <figcaption>Fig 06-180</figcaption>
                </figure>
                <p>
                    in the ItemViewModel.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-181.png"/>
                    <figcaption>Fig 06-181</figcaption>
                </figure>
                <p>

                    Now we can test the application, so here are the two initial items. I can expand them by selecting the first
                    one. Let's select the second item, unselect the first one, and unselect the second one. And now if I expand
                    the items and add a new item, we see that it shows up in the correct state already.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-182.png"/>
                    <figcaption>Fig 06-182</figcaption>
                </figure>
                <p>
                    If I collapse everything, all three items are collapsing, and I can expand all three items again. This user
                    experience is very common in Windows Phone and it can be tricky to realize if we don't use a decoupled tool,
                    like the MVVM Light Messenger. In that case, however, the Messenger makes it easy to get an undefined number
                    of ViewModels to communicate with each other.
                </p>
                <h3>Unit Test: Testing the SelectableViewModel's Expansion</h3>
                <p>For the next sample, we will see how we can unit test a ViewModelLayer of an MVVM Application. The MVVM Light
                    components can easily be used in Unit Test Scenarios, which allows the ViewModels to be thoroughly tested
                    automatically.
                </p>
                <p>
                    There are multiple unit test frameworks available for .NET, each with a crowd of followers. It is not the
                    purpose here to show which unit test framework is the best or the worst, but just to show some techniques used
                    to unit test ViewModels with MVVM Light.
                </p>
                <p>
                    For the purpose of this course, we will use a unit test framework, which is integrated in Visual Studio. For a
                    starter, let's see how we can test the behavior of the SelectableViewModel that we implemented in the previous
                    sample.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-183.png"/>
                    <figcaption>Fig 06-183</figcaption>
                </figure>
                <p>
                    We can verify the following features. The first feature is that when one item gets expanded, it must be
                    selected too. In addition, all the items must be expanded.
                </p>
                <p>
                    The second feature of the ViewModel is that if the last item of the list gets unselected, then all the items
                    should collapse. To do this, we will create a new UnitTest Application in Windows Phone. Let's do Add, New
                    Project, and here on the Windows Phone, I will select a UnitTest Application:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-184.png"/>
                    <figcaption>Fig 06-184</figcaption>
                </figure>
                <p>
                    This creates a special type of Windows Phone Application that gets integrated in the unit test framework that
                    Visual Studio offers. Now I can click OK.
                </p>
                <p>
                    And now I know that to test our SelectableViewModel, we need to add two references. The first one is a
                    reference to MVVM Light, because SelectableViewModel is a ViewModelBase. So we can do that using NuGet, like
                    before. Here we go, and I'm going to select here the â€˜libraries only':
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-185.png"/>
                    <figcaption>Fig 06-185</figcaption>
                </figure>
                <p>
                    Then, of course, I need to reference from TestApp1 to SelectableList, because this is the assembly in which
                    the ViewModel that we want to test is included. So let's do References, Add Reference. And then I'm going to
                    take Solution, SelectableList, and OK:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-186.png"/>
                    <figcaption>Fig 06-186</figcaption>
                </figure>
                <p>Now let's see what was created in the project. When we created this unit test project, the first test class was
                    added automatically. In fact, it is a totally standard class, which is decorated with a test class attribute.
                    We also have one TestMethod also decorated with an attribute, this time called TestMethod:
                </p>
<figure>
<pre><code class="csharp">namespace TestApp1
{
	[TestClass]
	public class UnitTest1
	{
		[TestMethod]
		public void TestMethod1()
		{
		}
	}
}</code></pre>
<figcaption>Fig06-187</figcaption>
</figure>
                <p>
                    You can have as many test classes and TestMethods as you need. Let's just rename this one to TestExpansion.
                    Then we can write the code for this method.
                </p>
                <p>
                    First, we will create a List of 5 SelectableViewModels:
                </p>
<figure>
<pre><code class="csharp">var list = new List&lt;SelectableViewModel&gt;();

for (var index = 0; index &lt; 5; index++)
{
    list.Add(new SelectableViewModel());
}</code></pre>
<figcaption>Fig06-188</figcaption>
</figure>
                <p>
                    Then we will call the ExpandCommand on the first item of the list:
                </p>
<figure>
<pre><code class="csharp">list[0].ExpandCollapseCommand.Execute(null);</code></pre>
<figcaption>Fig06-189</figcaption>
</figure>
                <p>
                    This simulates the interactions that the user has when he taps the small Expand button on the far-left of the
                    screen. Then we can Assert the result of the test. First, we know that each item in the list should be
                    expanded:
                </p>
<figure>
<pre><code class="csharp">foreach (var item in list)
{
    Assert.IsTrue(item.IsExpanded);
}</code></pre>
<figcaption>Fig06-190</figcaption>
</figure>
                <p>
                    Then, we also test that the first item, the one that was tapped, IsSelected:
                </p>
<figure>
<pre><code class="csharp">Assert.IsTrue(list[0].IsSelected);</code></pre>
<figcaption>Fig06-191</figcaption>
</figure>
                <p>
                    Let's run that test using the Test Explorer. First I need to build the application, and then I can click on
                    Run All. And here we go, the test passed.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-192.png"/>
                    <figcaption>Fig 06-192</figcaption>
                </figure>
                <h3>Unit Test: Testing the SelectableViewModel's Collapsing</h3>
                <p>The second test I want to write is to test what happens when all the items get unselected. Let's call it
                    TestCollapse. Here I will get the code, and here again, we create a list of 5 SelectableViewModels:
                </p>
<figure>
<pre><code class="csharp">var list = new List&lt;SelectableViewModel&gt;();

for (var index = 0; index < 5; index++)
{
    list.Add(new SelectableViewModel());
}</code></pre>
<figcaption>Fig06-193</figcaption>
</figure>
                <p>
                    Then I'm going to expand the list using the first item, just like before:
                </p>
<figure>
<pre><code class="csharp">list[0].ExpandCollapseCommand.Execute(null);
list[1].IsSelected = true;</code></pre>
<figcaption>Fig06-194</figcaption>
</figure>
                <p>
                    After that, though, we also select the second item in the list. So now we have two items, which are selected.
                    Now, let's unselect the first item:
                </p>
<figure>
<pre><code class="csharp">list[0].IsSelected = false;</code></pre>
<figcaption>Fig06-195</figcaption>
</figure>
                <p>
                    We can now Assert that all the items should still be expanded because the second item is still selected and so
                    the list may not collapse yet:
                </p>
<figure>
<pre><code class="csharp"> foreach (var item in list)
{
    Assert.IsTrue(item.IsExpanded);
}</code></pre>
<figcaption>Fig06-196</figcaption>
</figure>
                <p>
                    Then I unselect the second item in the list:
                </p>
<figure>
<pre><code class="csharp">list[1].IsSelected = false;</code></pre>
<figcaption>Fig06-197</figcaption>
</figure>
                <p>
                    and now I can Assert that all the items in the list should collapse:
                </p>
<figure>
<pre><code class="csharp">foreach (var item in list)
{
    Assert.IsFalse(item.IsExpanded);
}</code></pre>
<figcaption>Fig06-198</figcaption>
</figure>
                <p>
                    After I build the application, let's run the second test. Here we see that the second test passed as well,
                    which is great:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-199.png"/>
                    <figcaption>Fig 06-199</figcaption>
                </figure>
                <p>
                    Now, however, let's write something else. If I run both tests together, we see that the first one passes, but
                    the second one fails. This is weird, because we know that the second test passes when it is executed
                    individually. So what happened here?
                </p>
                <p>
                    Well the problem is that the Messenger object is used in the implementation, and it has a state, it has kept
                    track of the previous operation. We had the list of SelectableViewModels created in the first test and this
                    had registered with the Messenger.
                </p>
                <p>
                    When we register the second list too, in the second test, the first list is still there, it is still
                    registered, and it will respond to the query to know if some items are still selected. This can be a little
                    bit confusing, and this is why you should always reset the Messenger before you create a unit test using it.
                </p>

                <p>
                    To do this, we have a static method called Messenger.Reset, that we should call in the beginning of each
                    TestMethod. Let's do that:
                </p>
<figure>
<pre><code class="csharp">[TestMethod]
public void TestCollapse()
{
    Messenger.Reset();</code></pre>
<figcaption>Fig06-200</figcaption>
</figure>
                <p>
                    And I'm going to add the same thing here in the first method as well. Now I can go back, build the
                    application, and run all the tests again. And this time, both tests pass, which is correct.
                </p>
                <p>
                    What we learned here are two things; first, we learned that when we use a Messenger, it is better to
                    unregister once you are done with an object. We saw earlier that the Messenger attempts to keep only a weak
                    reference to all the objects that register with it. This is a good protection, but it is not totally
                    foolproof. In case of doubt, you should always unregister the objects to avoid unwanted behavior.
                </p>
                <p>
                    In the case of the SelectableList, when the user navigates away from the Windows Phone page, the developer
                    should really unregister the items on the list in the OnNavigatingFrom method.
                </p>
                <p>
                    The second thing we learned is that when the unit test is using the Messenger, even behind the cover, you
                    should preventatively call the ResetMethod beforehand.
                </p>
                <p>
                    Note that there is also a ResetMethod available on the SimpleIoc component and the same rule applies. Make
                    sure that you call the ResetMethod before you test a piece of code that uses this component.
                </p>
                <h3>Unit Test: Creating and Using Test Services</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex06-005" type="text" value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 6\before\UnitTestSample\UnitTestSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex06-006">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex06-006" type="text" value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 6\after\UnitTestSample\UnitTestSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex06-006">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>For this next sample, we will see how we can use a SimpleIoc component of MVVM Light to mock a DataService and
                    to simulate a web service access in a unit test.
                </p>
                <p>
                    Here I am starting with an MVVM Light Application for Windows 8.1. The exact same thing can be done for WPF,
                    Silverlight, Windows 8, or Windows Phone, so it doesn't really matter which framework you use. The exact same
                    principles will work just fine.
                </p>
                <p>
                    Let's review the application. I just created a new MVVM Light Windows Store Application and then I changed a
                    few things. First, I modified the DataItem and I added those two properties, called Property1 and Property2:
                </p>
<figure>
<pre><code class="csharp">public class DataItem
{
    public string Property1
    {
        get;
        set;
    }

    public int Property2
    {
        get;
        set;
    }
}</code></pre>
<figcaption>Fig06-201</figcaption>
</figure>
                <p>
                    Then, in the DataService implementation, I added code that we already saw before:
                </p>
<figure>
<pre><code class="csharp">public class DataService : IDataService
{
    public async Task&lt;DataItem&gt; GetData()
    {
        var client = new HttpClient();
        var json = await client.GetStringAsync("http://www.galasoft.ch/labs/pluralsight/nugetintro/jsonsample.txt");

        var myInstance = JsonConvert.DeserializeObject&lt;DataItem&gt;(json);
        return myInstance;
    }
}</code></pre>
<figcaption>Fig06-202</figcaption>
</figure>
                <p>
                    It is getting the json file from my web server, deserializes it into a DataItem, and returns it. Note that
                    this code is asynchronous, like every web service code in Windows Store, Windows Phone, etc.
                </p>
                <p>
                    Let's open the MainViewModel now. Here in the MainViewModel, I barely modified the default code that we
                    studied in the previous module. So here we have the NavigateCommand:
                </p>
<figure>
<pre><code class="csharp">public RelayCommand NavigateCommand
{
    get
    {
        return _navigateCommand
               ?? (_navigateCommand = new RelayCommand(
                   () =&gt; _navigationService.Navigate(typeof(SecondPage))));
    }
}</code></pre>
<figcaption>Fig06-203</figcaption>
</figure>
                <p>
                    which is going to navigate to the second page, and down here we have the WelcomeTitle property:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// Gets the WelcomeTitle property.
/// Changes to that property's value raise the PropertyChanged event.
/// &lt;/summary&gt;
public string WelcomeTitle
{
    get
    {
        return _welcomeTitle;
    }

    set
    {
        Set(ref _welcomeTitle, value);
    }
}</code></pre>
<figcaption>Fig06-204</figcaption>
</figure>
                <p>
                    just like before. Here in the constructor, I call the Initialize method:
                </p>
<figure>
<pre><code class="csharp">Initialize();</code></pre>
<figcaption>Fig06-205</figcaption>
</figure>
                <p>
                    which is defined further below, and here I modify the default Initialize method slightly in order to get the
                    DataItem from the DataService, and then to set the WelcomeTitle based on this value:
                </p>
<figure>
<pre><code class="csharp">private async Task Initialize()
{
    try
    {
        var item = await _dataService.GetData();
        WelcomeTitle = item.Property1 + " / " + item.Property2;
    }
    catch (Exception ex)
    {
        // Report error here
    }
}</code></pre>
<figcaption>Fig06-206</figcaption>
</figure>
                <p>
                    If we want to test this MainViewModel with a unit test, we have a couple of challenges.
                </p>
                <p>
                    First, the asynchronous operation, which fetches a json file and turns it into an object, is hard to test.
                    When we test the MainViewModel, we don't really need to test the service operation itself. That can be left to
                    the team who implements a DataService class. For us, we can use a simulation of the DataService, since the
                    focus of our test is really on the ViewModel itself.
                </p>
                <p>
                    The second challenge is testing the navigation. The application's NavigationService will perform an actual
                    navigation to a different page, which we cannot, of course, use in a unit test. So here, too, we will need to
                    use a simulation. This will allow us to test this thing, which is critical to us, which is that the
                    RelayCommand is correctly implemented and does indeed call the NavigationService with the correct arguments.
                    So how do we do that?
                </p>
                <p>
                    Well first I created a new UnitTest Application up here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-207.png"/>
                    <figcaption>Fig 06-207</figcaption>
                </figure>
                <p>
                    Like before, I added a reference to MVVM Light, which I did using NuGet. Then I also added another reference,
                    this time to the application that we want to test. This will give us access to the MainViewModel, which is a
                    TestObject.
                </p>
                <p>
                    Let's open the UnitTest class here, and I'm going to implement the first TestMethod. In order to create a new
                    MainViewModel, if we check the constructor here:
                </p>
<figure>
<pre><code class="csharp">public MainViewModel(
    IDataService dataService,
    INavigationService navigationService)</code></pre>
<figcaption>Fig06-208</figcaption>
</figure>
                <p>
                    we see that the MainViewModel requires an instance of IDataService and also an instance of INavigationService,
                    but we said we want to simulate those objects, so let's create two Test classes here. Let's create the first
                    class, the TestNavigationService:
                </p>
<figure>
<pre><code class="csharp">[TestClass]
public class UnitTest1
{
	[TestMethod]
	public void TestMethod1()
	{
	}
}

public class TestNavigationService : INavigationService
{
	public bool CanGoBack
	{
		get;
		private set;
	}

	public Type CurrentPageType
	{
		get;
		private set;
	}

	public void GoBack()
	{
	}</code></pre>
<figcaption>Fig06-209</figcaption>
</figure>
                <p>
                    Here, I will implement the INavigationService interface using ReSharper. Notice that I have, here, the
                    CurrentPageType, which exposes a property.
                </p>
                <p>
                    And if I go down here, I have the Navigate method:
                </p>
<figure>
<pre><code class="csharp">public void Navigate(Type sourcePageType)
{
}</code></pre>
<figcaption>Fig06-210</figcaption>
</figure>
                <p>
                    I can test that the Navigate method has been called correctly, by saving the new page type inside the
                    CurrentPageType
                </p>
                <figure>
<pre><code class="csharp">public void Navigate(Type sourcePageType)
{
    CurrentPageType = sourcePageType;
}</code></pre>
                    <figcaption>Fig06-211</figcaption>
                </figure>
                <p>
                    Now I can create the second test service class, which is a TestDataService. Here, too, I need to implement the
                    methods. There is only one method here:
                </p>
<figure>
<pre><code class="csharp"> public class TestDataService : IDataService
    {
        public Task&lt;DataItem&gt; GetData()
        {
            return null;
        }
    }</code></pre>
<figcaption>Fig06-212</figcaption>
</figure>
                <p>
                    This TestDataService needs a little bit of infrastructure, let's add this:
                </p>
<figure>
<pre><code class="csharp">public class TestDataService : IDataService
{
	private string _prop1;
	private int _prop2;

	public void Initialize(string prop1, int prop2)
	{
		_prop1 = prop1;
		_prop2 = prop2;
	}

	public Task&lt;DataItem&gt; GetData()
	{
		return null;
	}
}</code></pre>
<figcaption>Fig06-213</figcaption>
</figure>
                <p>
                    And then I can easily implement the GetData method, like this:
                </p>
<figure>
<pre><code class="csharp">public Task&lt;DataItem&gt; GetData()
{
    var item = new DataItem
    {
        Property1 = _prop1,
        Property2 = _prop2
    };

    return Task.FromResult(item);
}</code></pre>
<figcaption>Fig06-214</figcaption>
</figure>
                <p>
                    So what is happening here? Well first I will call the Initialize method:
                </p>
<figure>
<pre><code class="csharp">public void Initialize(string prop1, int prop2)
{
    _prop1 = prop1;
    _prop2 = prop2;
}</code></pre>
<figcaption>Fig06-215</figcaption>
</figure>
                <p>
                    which is going to allow me to Save the value of Property1 and Property2.
                </p>

                <p>
                    And then when I call GetData, I'm going to return a new DataItem with those well-known properties:
                </p>
<figure>
<pre><code class="csharp">var item = new DataItem
{
    Property1 = _prop1,
    Property2 = _prop2
};</code></pre>
<figcaption>Fig06-216</figcaption>
</figure>
                <p>
                    and then I'm going to be able to Assert that the correct values are passed back to me.
                </p>
                <p>
                    Now with those two Test services, I can implement my TestMethod, so let's go back to the UnitTest class and
                    I'm going to implement the TestMethod1 here. First, I'm going to create a TestNavigationService and a
                    TestDataService:
                </p>
<figure>
<pre><code class="csharp">[TestMethod]
public void TestMethod1()
{
    var nav = new TestNavigationService();
    var data = new TestDataService();
}</code></pre>
<figcaption>Fig06-217</figcaption>
</figure>
                <p>
                    Then I'm going to Initialize the TestDataService with some known values:
                </p>
<figure>
<pre><code class="csharp"> [TestMethod]
public void TestMethod1()
{
    var nav = new TestNavigationService();
    var data = new TestDataService();

    const string testProp1 = "this is a test";
    const int testProp2 = 1234;

    data.Initialize(testProp1, testProp2);
</code></pre>
<figcaption>Fig06-218</figcaption>
</figure>
                <p>
                    And finally, I'm going to create a new MainViewModel with those two well-known DataServices:
                </p>
<figure>
<pre><code class="csharp">[TestMethod]
public void TestMethod1()
{
    var nav = new TestNavigationService();
    var data = new TestDataService();

    const string testProp1 = "this is a test";
    const int testProp2 = 1234;

    data.Initialize(testProp1, testProp2);

    var vm = new MainViewModel(data, nav);

    Assert.AreEqual(
        string.Format("{0} / {1}", testProp1, testProp2),
        vm.WelcomeTitle);
}</code></pre>
<figcaption>Fig06-219</figcaption>
</figure>
                <p>
                    And then I'm going to Assert that the WelcomeTitle property has been set, according to the format that we want
                    to use:
                </p>
<figure>
<pre><code class="csharp">Assert.AreEqual(
    string.Format("{0} / {1}", testProp1, testProp2),
    vm.WelcomeTitle);</code></pre>
<figcaption>Fig06-220</figcaption>
</figure>
                <p>
                    So here this is quite a simple test, but nonetheless it is using the TestNavigationService and the
                    TestDataService, which are needed in order to build the MainViewModel.
                </p>
                <h3>Unit Test: Testing the Navigation and the PropertyChanged</h3>
                <p>Let's create a new UnitTest, this time to test a NavigateCommand. So first, just like before, I add a new
                    UnitTest method, and here I create a new TestNavigationService and a new TestDataService:
                </p>
<figure>
<pre><code class="csharp">[TestMethod]
public void TestNavigation()
{
    var nav = new TestNavigationService();
    var data = new TestDataService();

    var vm = new MainViewModel(data, nav);
}</code></pre>
<figcaption>Fig06-221</figcaption>
</figure>
                <p>
                    Then, using those two objects, I'm going to create a new MainViewModel, which is my TestObject. Now I'm going
                    to execute the NavigateCommand. Here, I call Execute with a null parameter:
                </p>
<figure>
<pre><code class="csharp">vm.NavigateCommand.Execute(null);</code></pre>
<figcaption>Fig06-222</figcaption>
</figure>
                <p>
                    And then I can Assert that inside the TestNavigationService, the CurrentPageType is now set to the type of
                    second page:
                </p>
<figure>
<pre><code class="csharp">Assert.AreEqual(typeof (SecondPage), nav.CurrentPageType);</code></pre>
<figcaption>Fig06-223</figcaption>
</figure>
                <p>
                    What we test here is that the NavigateCommand has been executed properly and that it calls the
                    NavigationService. Of course, the MainViewModel doesn't know that the Navigation has not actually been
                    executed; it doesn't matter, because the MainViewModel is just using an INavigationService.
                </p>
                <p>
                    The last test I will implement here is showing how you can test if an event was raised. For MVVM, we typically
                    want the PropertyChanged event to be raised when an observable property changes. So let's test that for the
                    WelcomeTitle property of the MainViewModel.
                </p>
                <p>
                    First I'm going to create the new TestMethod here; let's call that TestWelcomeTitle. Just like before, I
                    create a new TestNavigationService, a new TestDataService, and then I create the new MainViewModel, which is a
                    TestObject:
                </p>
<figure>
<pre><code class="csharp">[TestMethod]
public void TestWelcomeTitle()
{
    var nav = new TestNavigationService();
    var data = new TestDataService();

    var vm = new MainViewModel(data, nav);
}</code></pre>
<figcaption>Fig06-224</figcaption>
</figure>
                <p>
                    What we will do then is handle the PropertyChanged event of the TestObject. We can do that with a local event
                    handler here defined as a lambda expression:
                </p>
<figure>
<pre><code class="csharp">var propertyChangedWasRaised = false;

vm.PropertyChanged += (s, e) =&gt;
{
    propertyChangedWasRaised = true;
};</code></pre>
<figcaption>Fig06-225</figcaption>
</figure>
                <p>
                    When the event is raised, the code will be executed and set the local variable accordingly:
                </p>
<figure>
<pre><code class="csharp">propertyChangedWasRaised = true;</code></pre>
<figcaption>Fig06-226</figcaption>
</figure>
                <p>
                    Then we can test the values with Asserts. First, we Assert that the value is false, before the property is
                    changed:
                </p>
<figure>
<pre><code class="csharp">Assert.IsFalse(propertyChangedWasRaised);</code></pre>
<figcaption>Fig06-227</figcaption>
</figure>
                <p>
                    Then we assign a new string value to the WelcomeTitle property:
                </p>
<figure>
<pre><code class="csharp">vm.WelcomeTitle = "This is a new value";</code></pre>
<figcaption>Fig06-228</figcaption>
</figure>                
                <p>
                    And finally here, we test that the event has been raised properly by asserting that the local value is set to
                    true:
                </p>
<figure>
<pre><code class="csharp">Assert.IsTrue(propertyChangedWasRaised);</code></pre>
<figcaption>Fig06-229</figcaption>
</figure>
                <p>
                    Now we can run all the tests from the Test Explorer window. Like before, we need to build the application
                    first, and then let's select here â€˜Run All'. And after a short delay, we see that the three tests are
                    successful:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig06-230.png"/>
                    <figcaption>Fig 06-230</figcaption>
                </figure>
                <p>
                    If at a later time the team was to modify the MainViewModel and to break these features, the unit test would
                    immediately show this, which is very valuable for the team.
                </p>
                <p>
                    Unit tests are typically small and each TestMethod tests one specific aspect of the code. Here, we succeeded
                    in testing three separate features of the MainViewModel by creating some known test implementations of the
                    services. Because of the INavigation and IDataService interfaces, the MainViewModel does not know or care how
                    these services are implemented, but it only knows what they do.
                </p>
                <p>
                    Thanks to the Dependency Injection provided by SimpleIoc, the RelayCommand, the PropertyChanged
                    implementation, and all the decoupled techniques that we saw in this course, we can also quite easily improve
                    the testability of our application, and by the same process, we improve its stability and its maintainability
                    over time.
                </p>
                <h3>Summary and Conclusion</h3>
                <p>This last module of the MVVM Light reference course was rich in samples. We started by building a plug-in based
                    application in Windows Presentation Foundation. We saw how such an application is typically constructed, with
                    a Contracts assembly that has the interfaces needed for the plug-ins to be located and built, and a
                    Bootstrapper that loads the DLLs from a known folder and explores them to find the plug-ins that will be
                    placed in the UI.
                </p>
                <p>
                    Then we saw how various components of MVVM Light can be used to breach the decoupled elements. For example,
                    the Messenger can send messages to all the loaded plugins, whatever the number. The SimpleIoc can make
                    services accessible, even though they are not implemented in the same assembly. Databinding can be used from a
                    plugin to a MainViewModel for data and commands, etc.
                </p>
                <p>
                    Plugins are the most decoupled way to build an application. Many of the principles we saw in the
                    Model-View-ViewModel Pattern apply to plugin-based applications even more. And MVVM Light's components help to
                    build these application too.
                </p>
                <p>
                    In a second sample, we built a well-known user experience in Windows Phone, where a list's items get expanded
                    when they are tapped on the side. This allows multiple selection of these items with checkboxes. If all items
                    get unselected, the list collapses back into place. If the list is based on MVVM and made of ItemViewModels,
                    the experience can be a little bit tricky to realize in the UI layer, unless we take advantage of components,
                    such as the Messenger. In this sample, we saw how to build this experience from scratch.
                </p>
                <p>
                    Finally, we saw a few examples and tips on building unit tests for your ViewModels. We saw that some of the
                    MVVM Light's objects can have a state from previous unit tests, and that you should reset them. We also saw
                    techniques to create test services, such as a DataService or a NavigationService, with well-known behaviors
                    that can be asserted, or to attach to the PropertyChanged event to test if a property changes as expected.
                </p>
                <p>
                    Hopefully, these examples, combined with all the other samples that we saw throughout the course, will give
                    you a good idea of how you can take advantage of the MVVM Light Toolkit, to build applications of all sizes
                    and purposes. MVVM Light is relatively easy to get started with if you already know XAML, because it promotes
                    the core techniques that the XAML teams imagined.
                </p>
                <p>
                    I want to finish this course by giving you a few resources that can be useful as you continue your learning.
                    First, here is MVVM Light's homepage. This is a starting point for any exploration.
                </p>
                <p>
                    Here is a place where you can see the code, get new versions of the installers, see discussions and known
                    issues; it's all there on codeplex.
                </p>
                <p>
                    Then, my blog with the MVVM category, where I write articles and give news about the MVVM Light Toolkit's
                    development:
                </p>
                <p>
                    If you want to learn more about the specific components, this is probably a good place to check.
                </p>
                <p>
                    In case you are not totally up-to-date with the Model-View-ViewModel Pattern yet, or if you want a refresher,
                    these videos should help. They present MVVM techniques from the ground up. Also, make sure to check
                    Pluralsight's own videos talking about MVVM.
                </p>
                <p>
                    For technical support, I recommend checking Stackoverflow, where many questions have been answered already.
                    Make sure to tag your question with the mvvm-light's tag. There is a great team there, very eager to answer
                    more questions.
                </p>
                <p>
                    And finally, you are welcome to chat with me on Twitter. I am always happy to get messages from MVVM Light
                    users, and I try my best to answer questions if I can. The MVVM Light community is full of very constructive
                    people and it is a great, great pleasure to engage with all of you guys.
                </p>
                <p>
                    MVVM Light got an incredible success in the past few years, with more than 300,000 downloads. And I am
                    convinced that it is in great part because it is not too ambitious, but it tries to stick to the basics. It
                    actively promotes the same techniques and tools that the XAML teams have imagined, so you don't have to learn
                    everything from scratch again. It also allows you to use the same techniques and to reuse code between the
                    XAML platforms, which gives you a head start. This all contributes to its incredible success, with a large
                    number of applications based on it in WPF, Windows Phone, Windows Store, and even Xbox. And hopefully for you,
                    too, in the future.
                </p>
                <p>
                    I tried to show examples in all the popular XAML platforms, but in the end the techniques used are the same,
                    and if you get started in one of them, you will be able to pick up another platform very easily.
                </p>
                <p>
                    Because of its affinity with XAML, MVVM Light gives you a great design time experience, which is a huge
                    advantage in today's world, where the user experience is so important for your apps. And it also improves the
                    testability of your applications for more consistency and a better maintainability.
                </p>
                <p>
                    In conclusion, I hope that this course has been helpful for you all. It was a huge undertaking and I am proud
                    to finally have a great platform at Pluralsight to help all MVVM Light users to learn how to use this Toolkit.
                    I am also very eager to hear your feedback and to create more courses showing advanced techniques with the
                    MVVM Light Toolkit. Thank you, and happy coding!
                </p>
            </div>
        </div>
    </div>
</div>
