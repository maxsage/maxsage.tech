<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>The Core Components</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction: What is MVVM Light and What is it Not?</h3>
                <p>In the previous modules, we saw some of the advantages of the Model-View-ViewModel Pattern. And we also learned
                    how to refactor an existing application to MVVM. To do this, we didn't use any toolkit or framework. In this
                    module, we will introduce some of the components of the MVVM Light Toolkit and we will see how they can help
                    you to code faster.
                </p>
                <p>First, I would like to have a discussion on what MVVM Light is and what it is not. Often, people talk about
                    MVVM Light as a framework, but I prefer to call it a toolkit. This is a subtle difference, but it helps to
                    understand what MVVM Light actually does.
                </p>
                <p>Then we'll start studying the MVVM Light components with a foundational ObservableObject, and ViewModelBase
                    classes. The ViewModelBase was actually the very first item added to MVVM Light. These two classes help your
                    code to be cleaner and more efficient.
                </p>
                <p>We will continue with a study of the RelayCommand; a very convenient object that allows you to write less code,
                    to expose properties, implementing the ICommand Interface.
                </p>
                <p>After that, we will see what the Messenger does. This is a very powerful object, but with great power comes
                    great responsibility, and it is important to understand well how this component works and to take some
                    precautions.
                </p>
                <p>
                    We'll finish this study of the core MVVM Light components with a DispatcherHelper. This is a lesson on
                    components that provides a lot of help when dealing with asynchronous code and background threads.
                </p>
                <p>At the end of this module, you will have a good understanding of all the components in the code DLL of MVVM
                    Light and be able to use them in common scenarios in the XAML application. Before we talk about each
                    component, let's understand ‘What is MVVM Light?' and ‘What is it not?'
                </p>
                <p>MVVM Light is a toolkit, it is not a framework. With Toolkit, we understand that it is a suite of tools, some
                    helper classes containing two DLLs, project templates, item templates, and code snippets for Visual Studio.
                    Those are helpers to help you go faster into your code, to avoid the monotony of having to write the same code
                    over and over and over again, and of course those tools are not only useful for XAML-based applications, but
                    some of them, such as a Messenger or SimpleIoc, can be used for any type of decoupled application. MVVM Light,
                    however, is less intruding than the framework and lets you select which components you want to use and which
                    ones you want to leave aside.
                </p>
                <h3>The ObservableObject and the ViewModelBase</h3>
                <p>Talking about the components, let's start with two classes very useful for databinding; the ObservableObject
                    and the ViewModelBase. In a typical MVVM application, the ViewModel layer and the Model layer will have
                    multiple classes:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-001.png"/>
                    <figcaption>Fig 03-001</figcaption>
                </figure>
                <p>Let's start with the ViewModel. In this layer, the classes typically implement the INotifyPropertyChanged
                    interface. Until now we implemented INotifyPropertyChanged explicitly on each of the classes of the ViewModel.
                    Of course this is quite a lot of repetitive work and this can be simplified by adding a ViewModelBase class,
                    by having the ViewModel classes inherit this class and by implementing INotifyPropertyChanged directly in the
                    base class:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-002.png"/>
                    <figcaption>Fig 03-002</figcaption>
                </figure>

                <p>We can also have multiple flavors of the RaisePropertyChanged method, and some Helper's properties that we add
                    to the ViewModelBase class. In the Model layer, we can also have the classes implement INotifyPropertyChanged.
                    And here too, until now, we implemented INotifyPropertyChanged on each of the classes.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-003.png"/>
                    <figcaption>Fig 03-003</figcaption>
                </figure>
                <p>It is also interesting to have a base class, named ObservableObject, which is very similar to the
                    ViewModelBase. And in fact, ViewModelBase can easily inherit from ObservableObject in order to simplify the
                    implementation:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-004.png"/>
                    <figcaption>Fig 03-004</figcaption>
                </figure>
                <p>Classes deriving from ObservableObject and ViewModelBase can use a variety of methods to raise a
                    PropertyChanged event. Of course, the "Classic" one, raising the PropertyChanged event with a string for the
                    property name, and here typically we will use a constant for the property's name:
                </p>
                <figure>
<pre><code class="cs hljs">RaisePropertyChanged("MyProperty");
// "Classic" way.
// Typically used with a constant for the property's name.</code></pre>
                    <figcaption>Fig03-005</figcaption>
                </figure>
                <p>But there are also more comfortable ways; for example, the RaisePropertyChanged method, which takes an
                    expression as parameter. Using an expression to identify the properties that have changed is better than the
                    string, because it supports IntelliSense, and also if you change the name of the property, automatic
                    refactoring tools will help you to propagate the change everywhere in your code.
                </p>
                <figure>
<pre><code class="cs hljs">RaisePropertyChanged(() => MyProperty);
// Supports Intellisense and automatic refactoring
// Very, very small performance impact.</code></pre>
                    <figcaption>Fig03-006</figcaption>
                </figure>
                <p>
                    There is a very small performance impact because of the need to use some light Reflection to get the name of
                    the property.
                </p>
                <p>Another method, named Set, can help you to create even less code, like we will see in the sample.</p>
                <figure>
<pre><code class="csharp">Set("My Property", ref _myProperty, value);

Set()) => MyProperty, ref _myProperty, value);
// Set method takes care of checking if event must be raised.
// Returns true if event was raised.</code></pre>
                    <figcaption>Fig03-007</figcaption>
                </figure>
                <p>
                    For classes in the ViewModel layer, you can also broadcast the PropertyChanged event through the Messenger
                    class. Later in this module, we will learn how to use the Messenger to send messages from object to object.
                    This is a very decoupled manner of communicating. To do this, you use an overload of the RaisePropertyChanged
                    method, which in addition of the property name, takes the oldValue, the new value, and the parameter
                    specifying if you need to broadcast using the Messenger:
                </p>
                <figure>
                    <pre><code class="csharp">RaisePropertyChanged("MyProperty", oldValue, value, true);</code></pre>
                    <figcaption>Fig03-008</figcaption>
                </figure>
                <p>Of course, just like before, you also have the other variants of these methods:</p>
                <figure>
<pre><code class="csharp">RaisePropertyChanged(() => MyProperty, oldValue, value, true);

Set("MyProperty", ref _myProperty, value, true);

Set()) => MyProperty, ref _myProperty, value, true);</code></pre>
                    <figcaption>Fig03-009</figcaption>
                </figure>
                <p>and the message sent through the Messenger class is a PropertyChangedMessage, like we will see a little bit
                    later in the section about the Messenger.
                </p>
                <p>In addition to the PropertyChanged event, MVVM Light also supports a PropertyChanging event. This event is
                    raised just before the property changes, when the property still has the oldValue, which can be useful in
                    certain scenarios. ObservableObject and ViewModelBase support two overloads of the RaisePropertyChanging
                    method:
                </p>
                <figure>
<pre><code class="csharp">RaisePropertyChanging("MyProperty");
// "Classic" way.
// Typically used with a constant for the property's name.

RaisePropertyChanging(() = MyProperty);
// Supports Intellisense and automatic refactoring.
// Very, very small performance impact</code></pre>
                    <figcaption>Fig03-010</figcaption>
                </figure>
                <p>And the Set method that we saw before is also automatically raising the PropertyChanging event.</p>
                <p>
                    Classes deriving from ViewModelBase can use the IsInDesignMode property. This property is useful because XAML
                    frameworks have different ways to check if the code is running into a Visual Designer, such as Blend. For
                    example, this is a code that we would use in Silverlight and Windows Phone:
                </p>
                <figure>
                    <pre><code class="csharp">_isInDesignMode = DesignerProperties.IsInDesignTool;</code></pre>
                    <figcaption>Fig03-011</figcaption>
                </figure>
                <p>In Windows Store Application in Windows 8:</p>
                <figure>
<pre><code class="csharp">var prop = DesignerProperties.IsInDesignModeProperty;
_isInDesignMode = (bool)DependencyPropertyDescriptor
	.FromProperty(prop, typeof(FrameworkElement))
	.Metadata.DefaultValue;</code></pre>
                    <figcaption>Fig03-012</figcaption>
                </figure>
                <p>and in WPF. So MVVM Light proposes a way to unify all that, and has just one property, named IsInDesignMode.
                    For convenience, this value is also exposed in a static property on the ViewModelBase class.
                </p>
                <figure>
<pre><code class="csharp">public bool IsInDesignMode
public static bool IsInDesignModeStatic</code></pre>
                    <figcaption>Fig03-013</figcaption>
                </figure>
                <h3>The ObservableObject and the ViewModelBase (Demos)</h3>
                <p>Now we can refactor the small application that we built in the previous module to use MVVM Light:</p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-001" type="text" value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\before\viewmodelbase\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-001">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-002" type="text" value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\after\viewmodelbase\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-002">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>The first thing we will do is add a reference to the MVVM Light assemblies. To do this, I'm going to select
                    ‘Manage NuGet Packages', go online, and type mvvmlight in the Search box. I'm going to take the ‘libraries
                    only' and click Install:
                </p>

                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-014.png"/>
                    <figcaption>Fig 03-014</figcaption>
                </figure>
                <p>Once the libraries are installed. I can open the MainViewModel class and I'm going to change here the
                    INotifyPropertyChanged interface implementation:
                </p>
                <figure>
                    <pre><code class="csharp">public class MainViewModel : INotifyPropertyChanged</code></pre>
                    <figcaption>Fig03-015</figcaption>
                </figure>
                <p>by having the MainViewModel derive from ViewModelBase:</p>
                <figure>
                    <pre><code class="csharp">public class MainViewModel : ViewModelBase</code></pre>
                    <figcaption>Fig03-016</figcaption>
                </figure>
                <p>Now I can delete the INotifyPropertyChanged implementation, which I had at the end of this class:</p>
                <figure>
<pre><code class="csharp">public event PropertyChangedEventHandler PropertyChanged;

protected virtual void RaisePropertyChanged(string propertyName)
{
    var handler = PropertyChanged;
    if (handler != null)
    {
        handler(this, new PropertyChangedEventArgs(propertyName));
    }
}
}</code></pre>
                    <figcaption>Fig03-017</figcaption>
                </figure>
                <p>
                    And the ViewModelBase class is going to take care of that.
                </p>
                <p>Then we can simplify the observable properties; for example, the SelectedFriend property. I'm going to remove
                    this code here:
                </p>
                <figure>
<pre><code class="csharp">set
{
    if (_selectedFriend == value)
    {
        return;
    }

    _selectedFriend = value;
    RaisePropertyChanged("SelectedFriend");
}</code></pre>
                    <figcaption>Fig03-018</figcaption>
                </figure>

                <p>And instead, I'm going to use the Set method, taking an expression for the property name. Here you see that I
                    can use IntelliSense for that:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-019.png"/>
                    <figcaption>Fig 03-019</figcaption>
                </figure>
                <p>And passing the value:</p>
                <figure>
<pre><code class="csharp">set
{
    Set(() => SelectedFriend, ref _selectedFriend, value);
}</code></pre>
                    <figcaption>Fig03-020</figcaption>
                </figure>
                <p>Also, I can use the IsInDesignMode property to detect the design conditions. This is going to be useful,
                    especially if we want to share code; for example, with Windows 8, WPF, or Silverlight. So here I can use
                    IsInDesignMode directly:
                </p>
                <figure>
<pre><code class="csharp">#if DEBUG
    if (DesignerProperties.IsInDesignTool)
    {
        Refresh();
        SelectedFriend = Friends[0];
    }
#endif</code></pre>
                    <figcaption>Fig03-021</figcaption>
                </figure>
                <p>and in a static context, for example here in the constructor I can use IsInDesignMode static instead.
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel()
    : this(
        (DesignerProperties.IsInDesignTool
            ? (IFriendsService)new Design.DesignFriendsService()
            : new FriendsService()),
        new DialogService(),
        new NavigationService())</code></pre>
                    <figcaption>Fig03-022</figcaption>
                </figure>
                <p>
                    Now we can take care of the Model class. So let's open, here, the Friend class. And here:
                </p>
                <figure>
                    <pre><code class="csharp">public class Friend : INotifyPropertyChanged</code></pre>
                    <figcaption>Fig03-023</figcaption>
                </figure>
                <p>I'm going to derive from ObservableObject:</p>
                <figure>
                    <pre><code class="csharp">public class Friend : ObservableObject</code></pre>
                    <figcaption>Fig03-024</figcaption>
                </figure>
                <p>which is a little bit more lightweight than ViewModelBase, and for example doesn't have design mode detection.
                </p>
                <p>Let's enhance this class by adding an IsDirty property. This property is going to be set to true, if the class
                    needs to be saved to the web service:
                </p>
                <figure>
<pre><code class="csharp">private bool _isDirty;

        public bool IsDirty
        {
            get
            {
                return _isDirty;
            }
            set
            {
                Set(() => IsDirty, ref _isDirty, value);
            }
        }
</code></pre>
                    <figcaption>Fig03-025</figcaption>
                </figure>
                <p>And we can refactor the FirstName and the LastName properties to a simpler form using the Set method:
                </p>
                <figure>
<pre><code class="csharp">[JsonProperty("first_name")]
public string FirstName
{
    get
    {
        return _firstName;
    }

    set
    {
        if (Set(() => FirstName, ref _firstName, value))
        {
            IsDirty = true;
        }
    }
}</code></pre>
                    <figcaption>Fig03-026</figcaption>
                </figure>
                <p>and notice that here we use a written value of this method to detect if the property has changed and to set the
                    Dirty flag accordingly. And we can do the same here for the LastName property.
                </p>
                <figure>
<pre><code class="csharp">[JsonProperty("last_name")]
public string LastName
{
    get
    {
        return _lastName;
    }

    set
    {
        if (Set(() => LastName, ref _lastName, value))
        {
            IsDirty = true;
        }
    }
}</code></pre>
                    <figcaption>Fig03-027</figcaption>
                </figure>

                <p>Of course what I can do is get rid of the explicit implementation of INotifyPropertyChanged, since now this is
                    taken care of by the ObservableObject class:
                </p>
                <figure>
<pre><code class="csharp">public event PropertyChangedEventHandler PropertyChanged;

protected virtual void RaisePropertyChanged(string propertyName)
{
    var handler = PropertyChanged;
    if (handler != null)
    {
        handler(this, new PropertyChangedEventArgs(propertyName));
    }
}</code></pre>
                    <figcaption>Fig03-028</figcaption>
                </figure>
                <p>So here we are, this is a small step, but we have already refactored our application to take advantage of the
                    MVVM Light classes.
                </p>
                <p>Now we can verify that our changes didn't break anything, let's run the new application here in the Emulator. I
                    can Refresh. Just like before, the Friends list is being loaded and I can navigate to a Friend, do some
                    editing, etc.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-029.png"/>
                    <figcaption>Fig 03-029</figcaption>
                </figure>
                <p>So you see that everything's working just fine.
                </p>
                <h3>Introduction to ICommand and RelayCommand</h3>
                <p>After talking about ViewModelBase and ObservableObject, we can talk about the RelayCommand. RelayCommand is
                    another very important component in the MVVM Light Toolkit, because it's going to help you to expose some
                    functionality on the ViewModel in a very decoupled manner.
                </p>
                <p>The RelayCommand is an implementation of the ICommand Interface. This interface is not only useful for
                    XAML-based frameworks, but it has definitely been used a lot, and especially since the Model-View-ViewModel
                    Pattern got popular. The ICommand Interface defines three members:
                </p>
                <ul>
                    <li>The Execute method is going to be called when the command is actuated</li>
                    <li>Then there is the CanExecute method, which should return true or false depending on if the command can be
                        executed at that point, or not. </li>
                    <li>And there is a CanExecuteChanged event, which should be raised if the Status of CanExecute changes. </li>
                </ul>
                <p>So if anything in the context of the command changes and you want the CanExecute method to be called again, to
                    be reevaluated, then you should raise the CanExecuteChanged event.
                </p>
                <p>Of course, implementing the ICommand interface for every functionality that you want to expose on the ViewModel
                    is quite a lot of work. You will need to have a new class for each command. And this class should implement
                    ICommand and should provide an implementation for Execute, for CanExecute, and also a way to raise the
                    CanExecuteChanged event. This is obviously quite a lot of repetitive work, and here too, the MVVM Light
                    Toolkit is going to simplify the process of implementing such functionality. To do this, MVVM Light proposed
                    an implementation of ICommand, called the RelayCommand. Let's understand how this works.
                </p>
                <h3>Demonstrating the Commands</h3>
                <p>To better understand how RelayCommands work, we are going to start by understanding a standard ICommand
                    implementation. So here we have a Windows 8 application:
                </p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-003" type="text"
                               value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\before\viewmodelbase\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-003">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-004" type="text" value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\after\commanding\Commanding.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-004">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>we have a MainViewModel:</p>
                <figure>
<pre><code class="xml">&lt;UserControl.Resources&gt;
	&lt;vm:MainViewModel x:Name="MainViewModel" /&gt;
&lt;/UserControl.Resources&gt;</code></pre>
                    <figcaption>Fig03-030</figcaption>
                </figure>
                <p>
                    which is bound to the DataContext of the page, and we have here a TextBox:
                </p>
                <figure>
<pre><code class="xml">&lt;TextBox Text="Enter your name"
	x:Name="MyTextBox"
	Margin="10" /&gt;</code></pre>
                    <figcaption>Fig03-031</figcaption>
                </figure>

                <p>Here below, we have a button, and this button doesn't have a Click event, but instead it is using the command,
                    which is bound to something called SayHelloCommand
                </p>
                <figure>
<pre><code class="xml">&lt;Button Content="Say Hello"
	Command="{Binding SayHelloCommand}"
	CommandParameter="{Binding ElementName=MyTextBox, Path=Text}"
	Margin="10" /&gt;</code></pre>
                    <figcaption>Fig03-032</figcaption>
                </figure>
                <p>which will be on the MainViewModel And there is also a CommandParameter, which we bind to the TextBox that we
                    saw just before, and we are going to use the TextProperty.
                </p>
                <p>Now let's take a look to this SayHelloCommand. So the SayHelloCommand is going to be on the MainViewModel.
                    Let's open this class. And here we see that the SayHelloCommand is of type SayHello.
                </p>
                <figure>
<pre><code class="csharp"> public SayHello SayHelloCommand
{
    get;
    private set;
}</code></pre>
                    <figcaption>Fig03-033</figcaption>
                </figure>
                <p>
                    So somewhere in the application, we have a class and here we see that the properties initialized to a new
                    SayHello instance, which is using the current ViewModel as a parameter:
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
    SayHelloCommand = new SayHello(this);
}</code></pre>
                    <figcaption>Fig03-034</figcaption>
                </figure>
                <p>The SayHello class is here and we see that this is an implementation of the ICommand interface.</p>
                <figure>
<pre><code class="csharp">public class SayHello : ICommand
    {
        private readonly MainViewModel _owner;

        public SayHello(MainViewModel owner)
        {
            _owner = owner;

            _owner.PropertyChanged += (s, e) =>
            {
                if (CanExecuteChanged != null
                    && e.PropertyName == MainViewModel.CounterPropertyName)
                {
                    CanExecuteChanged(this, EventArgs.Empty);
                }
            };
        }

        public bool CanExecute(object parameter)
        {
            if (_owner != null
                && _owner.Counter % 2 == 0)
            {
                return true;
            }

            return false;
        }

        public event EventHandler CanExecuteChanged;

        public void Execute(object parameter)
        {
            var dialog = new MessageDialog("Hello, " + parameter);
            dialog.ShowAsync();
        }
    }
}</code></pre>
                    <figcaption>Fig03-035</figcaption>
                </figure>
                <p>So constructor, like we mentioned, is taking an instance of the MainViewModel, which we are going to Save as a
                    field:
                </p>
                <figure>
<pre><code class="csharp">private readonly MainViewModel _owner;

public SayHello(MainViewModel owner)
{
    _owner = owner;</code></pre>
                    <figcaption>Fig03-036</figcaption>
                </figure>
                <p>and then we have the ICommand implementation, the Execute method, which is going to be called when the command
                    is actuated, so in that case when the button is clicked. And here what we will do is show a MessageDialog
                    using the parameter that is passed to the command:
                </p>
                <figure>
<pre><code class="csharp">public void Execute(object parameter)
{
    var dialog = new MessageDialog("Hello, " + parameter);
    dialog.ShowAsync();
}</code></pre>
                    <figcaption>Fig03-037</figcaption>
                </figure>
                <p>Remember that in the XAML, we had a CommandParameter attribute, which is set.</p>
                <p>In addition to that, we implement the CanExecute method:</p>
                <figure>
<pre><code class="csharp"> public bool CanExecute(object parameter)
{
    if (_owner != null
        && _owner.Counter % 2 == 0)
    {
        return true;
    }

    return false;
}</code></pre>
                    <figcaption>Fig03-038</figcaption>
                </figure>
                <p>Remember that this method needs to return true if the command can be executed, and false if it cannot be
                    executed. And here we are going to rely on the _owner attribute. The _owner attribute is the MainViewModel
                    which owns the command and which we passed in the constructor. Of course this is a little bit annoying to have
                    a dependency like that from the command to the MainViewModel, but here this is, unfortunately, what we have to
                    do. On the _owner, we are going to check the Counter property, and if this property can be divided by 2, we
                    are going to return true, meaning that the command can be executed.
                </p>
                <p>The last member of the ICommand interface is the CanExecuteChanged event:</p>
                <figure>
                    <pre><code class="csharp">public event EventHandler CanExecuteChanged;</code></pre>
                    <figcaption>Fig03-039</figcaption>
                </figure>
                <p>And of course we need to raise this event if the context changed and if the CanExecute method needs to be
                    reevaluated. So how do we do that? Well because we are outside of the MainViewModel (we are in the SayHello
                    class) and we want to react to a change of the Counter property, we'll need to observe the PropertyChanged
                    event of the MainViewModel:
                </p>
                <figure>
<pre><code class="csharp">public SayHello(MainViewModel owner)
{
    _owner = owner;

    _owner.PropertyChanged += (s, e) =>
    {
        if (CanExecuteChanged != null
            && e.PropertyName == MainViewModel.CounterPropertyName)
        {
            CanExecuteChanged(this, EventArgs.Empty);
        }
    };
}</code></pre>
                    <figcaption>Fig03-040</figcaption>
                </figure>
                <p>and if the property that is changed is the Counter property:</p>
                <figure>
<pre><code class="csharp">if (CanExecuteChanged != null
    && e.PropertyName == MainViewModel.CounterPropertyName)</code></pre>
                    <figcaption>Fig03-041</figcaption>
                </figure>
                <p>then we are going to raise the CanExecuteChanged event and this will force the Binding to that command to call
                    CanExecute again:
                </p>
                <figure>
                    <pre><code class="csharp">CanExecuteChanged(this, EventArgs.Empty);</code></pre>
                    <figcaption>Fig03-042</figcaption>
                </figure>
                <p>So this is a basic way that the command works with a Binding, and because a Binding is to a control which can
                    be disabled, when CanExecute returns false, this button:
                </p>
                <figure>
<pre><code class="xml">&lt;Button Content="Say Hello"
    Command="{Binding SayHelloCommand}"
    CommandParameter="{Binding ElementName=MyTextBox, Path=Text}"
    FontSize="32"
    Margin="10" /&gt;</code></pre>
                    <figcaption>Fig03-034</figcaption>
                </figure>
                <p>is going to be disabled automatically.</p>
                <p>Let's take a look at a small application. I'm going to enter my name, and if I click the button, the command is
                    executed and the message dialog is shown:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-044.png"/>
                    <figcaption>Fig 03-044</figcaption>
                </figure>
                <p>Now if increment the Counter, for example going to 1, this forces a CanExecute method to be re-executed, and
                    this time it will return false because 1 cannot be divided by 2. So as a consequence, the button to which the
                    command is bound will be disabled:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-045.png"/>
                    <figcaption>Fig 03-045</figcaption>
                </figure>
                <p>If I increment again, this time the CanExecute method returns true and the button is enabled:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-046.png"/>
                    <figcaption>Fig 03-046</figcaption>
                </figure>
                <h3>RelayCommand Demo</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-006" type="text"
                               value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\after\relaycommanding\RelayCommanding.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-006">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>MVVM Light allows to simplify the small application by taking care of the ICommand implementation. Notice that
                    we don't have the SayHello class anymore. Instead, the SayHelloCommand is of type RelayCommand of string. And
                    of course the string is a type of the CommandParameter; in this case we passed a TextProperty of the TextBox
                    control:
                </p>
                <figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; SayHelloCommand
{
    get;
    private set;
}</code></pre>
                    <figcaption>Fig03-047</figcaption>
                </figure>
                <p>The RelayCommand is constructed here:</p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
    SayHelloCommand = new RelayCommand&lt;string&gt;(
        ShowMessage,
        m => _counter % 2 == 0);
}</code></pre>
                    <figcaption>Fig03-048</figcaption>
                </figure>
                <p>and it takes two parameters. The first parameter, which is compulsory, is the delegate to the Execute method.
                    In this case, we use a named method, called ShowMessage, and notice the parameter of type string:
                </p>
                <figure>
<pre><code class="csharp">private void ShowMessage(string parameter)
{
    var dialog = new MessageDialog("Hello, " + parameter);
    dialog.ShowAsync();
}</code></pre>
                    <figcaption>Fig03-049</figcaption>
                </figure>
                <p>This method does exactly the same as before; it simply shows a MessageDialog. The second parameter is optional.
                    In this case, we use an anonymous lambda expression, and this is a delegate to the CanExecute method:
                </p>
                <figure>
<pre><code class="csharp">SayHelloCommand = new RelayCommand&lt;string&gt;(
    ShowMessage,
    m => _counter % 2 == 0);</code></pre>
                    <figcaption>Fig03-050</figcaption>
                </figure>
                <p>Based on the written value of this method, the command will be enabled or disabled. In this case, we take the
                    Counter attribute and then we check if it can be divided by 2. If the result of this expression is true, this
                    is what we return, and the command will be enabled. Depending on your personal preferences, you can use named
                    methods or anonymous lambdas for those to delegate, or you can mix and match them. Of course the code is much
                    simpler, because a RelayCommand property has direct access to private members of the MainViewModel; for
                    example, here, the Counter attribute.
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
    SayHelloCommand = new RelayCommand&lt;string&gt;(
        ShowMessage,
        m => _counter % 2 == 0);</code></pre>
                    <figcaption>Fig03-051</figcaption>
                </figure>
                <p>In order for the CanExecuteChanged event to be raised, we use a built-in RaiseCanExecuteChanged method. Here:
                </p>
                <figure>
<pre><code class="csharp">public int Counter
{
    get
    {
        return _counter;
    }

    set
    {
        if (_counter == value)
        {
            return;
        }

        _counter = value;
        RaisePropertyChanged(CounterPropertyName);
        SayHelloCommand.RaiseCanExecuteChanged();
    }
}</code></pre>
                    <figcaption>Fig03-052</figcaption>
                </figure>
                <p>every time that the _counter property is set, we will raise the CanExecuteChanged event for the
                    SayHelloCommand. Running the application produces the exact same result. But even in this small application,
                    the advantage of using a packed implementation of ICommand is quite clear.
                </p>
                <h3>RelayCommand Slides</h3>
                <p>So let's review what we know about RelayCommands:</p>
                <ul>
                    <li>The RelayCommand is a packed implementation of the ICommand interface.</li>
                    <ul>
                        <li>It needs a delegate to the Execute method, which will be invoked when the command is actuated. </li>
                        <li>Optionally, you can also pass a delegate to the CanExecute method, which specifies if the command is
                            enabled or disabled. Note that if the control to which the command is bound allows it, the control
                            will be disabled if CanExecute returns false. </li>
                        <li>The RelayCommand has a method called RaiseCanExecuteChanged that will, well, raise a CanExecuteChanged
                            event. This will force the system to reevaluate the CanExecute method, and possibly change the state
                            of the control to which the command is bound. </li>
                    </ul>
                    <li>The advantage of the RelayCommand is that, since it is packed, it replaces an explicit implementation of
                        the ICommand interface, which saves quite a lot of work. </li>

                </ul>
                <p>
                    When you create a new instance of the RelayCommand here as a public property on the ViewModel:
                </p>
                <figure>
<pre><code class="csharp">public class MainViewModel : ViewModelBase
{
	public RelayCommand DoSomethingCommand
	{
		get;
		private set;
	}</code></pre>
                    <figcaption>Fig03-053</figcaption>
                </figure>
                <p>you pass a delegate to the constructor:</p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
	DoSomethingCommand = new RelayCommand(DoSomething);
}</code></pre>
                    <figcaption>Fig03-054</figcaption>
                </figure>
                <p>This is the Execute method, which can be declared explicitly a name, as shown here:</p>
                <figure>
<pre><code class="csharp">private void DoSomething()
{
	// This is the Execute delegate
}</code></pre>
                    <figcaption>Fig03-055</figcaption>
                </figure>
                <p>the DoSomething method. Optionally, it is possible to pass a second delegate:</p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
	DoSomethingCommand = new RelayCommand(DoSomething, CanDoSomething);
}</code></pre>
                    <figcaption>Fig03-056</figcaption>
                </figure>
                <p>which can also be a named method; in this case, the CanDoSomething method:</p>
                <figure>
<pre><code class="csharp">private bool CanDoSomething()
{
	// This is the CanExecute delegate
	return true; // true --> command is enabled
}</code></pre>
                    <figcaption>Fig03-057</figcaption>
                </figure>
                <p>This method returns a Boolean, true if the command is enabled, and false if the command should be disabled.
                    However, it is also possible to declare each of the delegate as anonymous lambda expression. For example, here
                    the Execute delegate is an anonymous lambda:
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
	DoSomethingCommand = new RelayCommand(
		() =>
		{
			// This is the Execute delegate
		});</code></pre>
                    <figcaption>Fig03-058</figcaption>
                </figure>
                <p> Or here:</p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
	DoSomethingCommand = new RelayCommand(
		() =>
		{
			// This is the Execute delegate
			return true; // true --> command is enabled
		});</code></pre>
                    <figcaption>Fig03-059</figcaption>
                </figure>
                <p>the CanExecute delegate, which returns true or false.</p>
                <p>Note that for simple expressions, another possible syntax for the CanExecute lambda is to avoid the returned
                    keyword, as shown here:
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
	DoSomethingCommand = new RelayCommand(
		DoSomething,
		() true);</code></pre>
                    <figcaption>Fig03-060</figcaption>
                </figure>
                <p>
                    Finally, there is also a generic implementation of RelayCommand, taking a type parameter:
                </p>
                <figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; DoSomethingCommand
{
	get;
	private set;
}</code></pre>
                    <figcaption>Fig03-061</figcaption>
                </figure>
                <p>This is a type of the command parameter, which the ICommand interface allows. There can be only one parameter
                    per command, which is a restriction of the ICommand interface itself.
                </p>
                <p>Generic RelayCommands are built in a similar manner, for example with a named method, and here note the
                    parameter of the DoSomething method:
                </p>
                <figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; DoSomethingCommand
{
	get;
	private set;
}

public MainViewModel()
{
	DoSomethingCommand = new RelayCommand&lt;string&gt;(DoSomething);
}</code></pre>
                    <figcaption>Fig03-062</figcaption>
                </figure>

                <p>Same thing for the CanExecute delegate, it also receives as a string parameter:</p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
    DoSomethingCommand = new RelayCommand&lt;string&gt;(DoSomething, CanDoSomething);
}

private void CanDoSomething(string parameter)
{
	// This is the CanExecute delegate
    return true; // true --> command is enabled
}</code></pre>
                    <figcaption>Fig03-063</figcaption>
                </figure>
                <p>And finally, each of the delegates can also be an anonymous lambda expression, just like before:</p>
                <figure>
<pre><code class="csharp">public MainViewModel()
{
	DoSomethingCommand = new RelayCommand&lt;string&gt;(
		parameter =>
		{
			// This is the Execute delegate
		});

	DoSomethingCommand = new RelayCommand&lt;string&gt;(
		DoSomething,
		parameter =>
		{
			// This is the CanExecute delegate
			return true; // true --> command is enabled
		});

	DoSomethingCommand = new RelayCommand&lt;string&gt;(
		DoSomething,
		parameter => true);
}</code></pre>
                    <figcaption>Fig03-064</figcaption>
                </figure>
                <p>
                    with a single difference that the lambda expression is declared with a parameter, in this case of type string.
                </p>
                <h3>The Messenger, Receiving and Sending Messages</h3>
                <p>I AM HERE Now I would like to talk about an important component of the MVVM Light Toolkit, a component which is easy to
                    love, but which can also be easy to overuse, the Messenger.
                </p>
                <p>First let's review how conventional event handling works in .NET:</p>
                <ul>
                    <li>One issue we have is that registering an event handler will often create a strong link between the
                        instance handling the event and the instance raising the event </li>
                    <ul>
                        <li>So if you forget, or cannot unregister the event, there is the risk of a potential memory leak. </li>
                    </ul>
                    <li>For reference, this is how you register an event handler in .NET: <code>button.Click +=
                        ButtonClick;</code> for example, the Click event of the button. </li>
                    <li>And this is how you unregister: <code>button.Click -= ButtonClick;</code> in order to remove any risk
                        to a potential memory leak. </li>
                    <li>
                        Of course there is also another difficulty, which is how to even find the instance raising the event that
                        we want to register to. Sometimes, this instance can be hidden, or it can be located in a part of the
                        application that is not easy to access.
                        <ul>
                            <li>Or, sometimes, the event subscriber doesn't even know if there will be such an instance at
                                runtime; for example, in a plugin scenario. </li>
                            <li>And of course this is especially a problem with decoupled application, when one part of the
                                application knows as little as possible about other parts. </li>
                        </ul>
                    </li>
                </ul>
                <p>So for all these scenarios, the Messenger can help. What is Messenger?</p>
                <p>Well sometimes it's called an "event bus".</p>
                <p>Simply said, it is a system that sends messages to a list of recipients (a message distribution system)
                </p>
                <p>
                    It is fully decoupled, so the center doesn't know if any recipient gets the message. And the recipient also
                    doesn't know who sends the message, so recipients register to receive the messages based on some criteria.
                </p>
                <p>Typically, we use a default instance of the Messenger but it is also possible to create new instances of the
                    Messenger, which will each operate on their own private channel.
                </p>
                <p>
                    In order to get a message the recipients inform the Messenger that it is interested in a specific message type
                    and the type can be anything, from a value type like int, bool, etc., to normal .NET classes.
                </p>
                <p>
                    Typically, messages are broadcast to all recipients that registered for that message type, but it is also
                    possible to open a "private channel" with a token, like we will see in a moment.
                </p>
                <p>In the typical case, the message recipient registers to the default Messenger instance using one of the
                    Register methods:
                    <figure>
<pre><code class="csharp">public MessageRecipient()
{
	Messenger.Default.Register&lt;MyMessageType&gt;(
		this, HandleMessage);
}

private void HandleMessage(MyMessageType message)
{
	// Do Something
}</code></pre>
                        <figcaption>Fig03-065</figcaption>
                    </figure>
                <p>
                    The important parameters are, the type of the message, the instance that registers in order to check the
                    lifetime, and a delegate to the message handling method.
                </p>
                <p>

                    There are multiple ways to register for a message. If you remember the section about RelayCommands, this is
                    quite similar:
                </p>
                <p>You can either pass a delegate to a named method:</p>
                <figure>
<pre><code class="csharp">public MessageReceiver()
{
	Messenger.Default.Register&lt;NotificationMessage&lt;Friend&gt;&gt;(
		this, HandleNotification);
}</code></pre>
                    <figcaption>Fig03-066</figcaption>
                </figure>
                <p>which will receive the message:</p>
                <figure>
<pre><code class="csharp">private void HandleNotification(NotificationMessage&lt;Friend&gt; message)
{
	// Do something
}</code></pre>
                    <figcaption>Fig03-067</figcaption>
                </figure>
                <p>Or, if you don't want to look for a name for this method, you can pass an anonymous lambda expression, as shown
                    here:
                </p>
                <figure>
<pre><code class="csharp">Messenger.Default.Register&lt;NotificationMessage&lt;Friend&gt;&gt;(
	this,
	message =>
	{
		// Do something
	});</code></pre>
                    <figcaption>Fig03-068</figcaption>
                </figure>
                <p>In both cases, notice the message parameter, which contains whatever was sent.</p>
                <p>Sending a message is even easier. Again, any kind of object, even simple values, can be sent. For example, here
                    is how you send an instance of MyMessageType:
                </p>
                <figure>
<pre><code class="csharp">var myInstance = new MyMessageType();
Messenger.Default.Send(myInstance);

public class MyMessageType
{
    // Can be anything
}
</code></pre>
                    <figcaption>Fig03-069</figcaption>
                </figure>
                <p>Like mentioned before, you could possibly send a Boolean value if really you wanted to:</p>
                <figure>
<pre><code class="csharp">Messenger.Default.Send(true);
// Dangerous!
</code></pre>
                    <figcaption>Fig03-070</figcaption>
                </figure>
                <p>Of course this is probably not a great idea, as there is absolutely no context and the recipient is unlikely to
                    know what to do with that message. In a simple Master Details app, we could just send a selected item; for
                    example, here's a selectedFriend:
                </p>
                <figure>
                    <pre><code class="csharp">Messenger.Default.Send(true);</code></pre>
                    <figcaption>Fig03-071</figcaption>
                </figure>
                <p>Of course, here too, some context is missing, and if the application grows more complex, it might be necessary
                    to refactor this part to add the missing information. The more realistic scenario is to send dedicated message
                    types. There are a number of built-in message types in MVVM Light; for example, the very useful
                    NotificationMessage:
                </p>
                <figure>
<pre><code class="csharp">var message1 = new NotificationMessage&lt;Friend&gt;(
	selectedFriend,
	FriendSelectedNotification);
Messenger.Default.Send(message1);</code></pre>
                    <figcaption>Fig03-072</figcaption>
                </figure>
                <p>This message type takes a string, an instruction for the receiver. It can also carry a payload, in this case a
                    selectedFriend. Optionally, these built-in message types can also carry a reference to the message sender:
                </p>
                <figure>
<pre><code class="csharp">var message2 = new NotificationMessage&lt;Friend&gt;(
	this,
	selectedFriend,
	FriendSelectedNotification);
Messenger.Default.Send(message2);</code></pre>
                    <figcaption>Fig03-073</figcaption>
                </figure>
                <p>A little bit like conventional events, often pass the event sender to the subscriber. This can be useful, but
                    of course we need to be careful not to store this reference and create, again, the memory leaks that we were
                    trying to avoid.
                </p>
                <h3>Messenger Advanced Options</h3>
                <p>Let's talk a little bit about memory here. When the recipient registers to the Messenger with a message
                    handling method, the Messenger keeps, of course, a reference to this method. Sometimes, it can be difficult to
                    unregister. We do our best to avoid that this causes a memory leak. Notably, whenever possible, the message
                    handling methods are kept as weak references, so that the object can be garbage collected, even if they didn't
                    unregister first, but sometimes this is not possible. The table here shows a summary:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-074.png"/>
                    <figcaption>Fig 03-074</figcaption>
                </figure>
                <p>
                    Message handling methods can be Static, Public, Internal or Private. They can also be anonymous Lambdas, which
                    is the same as a Private method.
                </p>
                <p>In WPF and in Windows 8, there are no problems. You can register a private method or a lambda expression as
                    message handler, and it will not create a strong leak. In Silverlight and in Windows Phone, unfortunately,
                    there are some additional security restrictions in place:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-075.png"/>
                    <figcaption>Fig 03-075</figcaption>
                </figure>
                <p>Because of this, it is not possible to create a weak reference to a Private, Internal or Anonymous method. Only
                    Static or Public methods are fully safe in these two frameworks. So if you use Silverlight or Windows Phone,
                    make sure to analyze your scenario carefully. If you see a risk for a memory leak, you should unregister the
                    message handling method.
                </p>
                <p>Unregistering is quite easy and is generally a good idea to keep things clean. You can easily register a
                    recipient altogether, for all the delegates that it registered:
                </p>
                <figure>
                    <pre><code class="csharp">Messenger.Default.Unregister(this);</code></pre>
                    <figcaption>Fig03-076</figcaption>
                </figure>
                <p>or you can unregister for a specific delegate:</p>
                <figure>
                    <pre><code class="csharp">Messenger.Default.Unregister&lt;IMessage&gt;(this, HandleMessage);</code></pre>
                    <figcaption>Fig03-077</figcaption>
                </figure>
                <p>If you are using Tokens to open private channels, like we will show in a moment, you can also unregister using
                    the same Token:
                </p>
                <figure>
<pre><code class="csharp">Messenger.Default.Unregister&lt;IMessage&gt;(this, Token);

Messenger.Default.Unregister&lt;IMessage&gt;(this, Token, HandleMessage);</code></pre>
                    <figcaption>Fig03-078</figcaption>
                </figure>
                <p>So let's talk about these tokens. This is a special case, but it can prove useful sometimes. In this scenario,
                    one or more recipients can register using a token in the Register method. So token can be anything, it just
                    has to be unique. When the Sender sends a message using the same token, the Messenger will filter who receives
                    the message. So even if Recip 2 registered for that message type, because it didn't use a token, it will not
                    receive the message at all.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-079.png"/>
                    <figcaption>Fig 03-079</figcaption>
                </figure>
                <p>This prevents a need to write filtering logic in every recipient. From a code standpoint, this is how it works.
                    Here we use a Guid as a unique Token:
                </p>
                <figure>
<pre><code class="csharp">public class MessageRecipient
{
	public static readonly Guid Token = Guid.NewGuid();</code></pre>
                    <figcaption>Fig03-080</figcaption>
                </figure>
                <p>but again it could be anything, such as a string or an instance of an object. Then we call the Register method
                    using the Token as parameter. And, of course, the same Token is used in the Send method of the Messenger
                </p>
                <figure>
<pre><code class="csharp">public class MessageRecipient
{
	public static readonly Guid Token = Guid.NewGuid();

	public MessageRecipient()
	{
		Messenger.Default.Register&lt;NotificationMessage&gt;(
			this, Token, HandleNotification);
	}

	private void HandleNotification(
		NotificationMessage message)
	{
		// Do something
	}
}

public class MessageSender
{
	public void SendMessage()
	{
		Messenger.Default.Send(
			new NotificationMessage("DoSomething"),
			MessageRecipient.Token);
	}
}			</code></pre>
                    <figcaption>Fig03-081</figcaption>
                </figure>
                <p>Another special case that can be very useful, is a possibility to register for an interface or a base class.
                    For example, let's imagine an IMessage interface, implemented by a class called ImplementMessage:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-082.png"/>
                    <figcaption>Fig 03-082</figcaption>
                </figure>
                <p>If a recipient registers for a message of type IMessage and sets this Boolean flag to true:</p>
                <figure>
<pre><code class="csharp">Messenger.Default.Register&lt;IMessage&gt;(
	this,
	true,
	HandleMessage);
with
private void HandleMessage(IMessage message)
{
}</code></pre>
                    <figcaption>Fig03-083</figcaption>
                </figure>
                <p>then the method will be called when any message implementing IMessage will be sent. This is true when you send
                    a message of type ImplementMessage:
                </p>
                <figure>
                    <pre><code class="csharp">Messenger.Default.Send(new ImplementMessage());</code></pre>
                    <figcaption>Fig03-084</figcaption>
                </figure>
                <p>but it is also convenient with Generic Message:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-085.png"/>
                    <figcaption>Fig 03-085</figcaption>
                </figure>
                <p>that can carry a payload of various types. In this case, the method will be called whatever the type of the
                    payload is. Then it is easy to handle the payload of the message.
                </p>
                <p>I guess that this presentation wouldn't be complete if we didn't mention a few dangers. It is very tempting to
                    overuse a component. If you overuse the Messenger, this can lead to confusing code, where it is not exactly
                    clear what is happening. If people with less experience have to maintain this code, this can cause difficult
                    situations.
                </p>
                <p>Be reasonable; for me the Messenger is a last resort, when I cannot or don't want to use conventional code,
                    like event handlers, and when for some reason I cannot use an IOC container with some services, like we did
                    with the DialogService or the NavigationService.
                </p>
                <p>Finally, be advised that it is always right. Test your code for memory leaks, make sure you cover everything
                    with test cases, and if you are in doubt, use the Unregister method.
                </p>
                <h3>Messenger Demos</h3>
                <p>In order to demonstrate the Messenger, I will use a Windows 8 application:</p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-007" type="text" value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\before\viewmodelbase\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-007">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-008" type="text" value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\after\messenger\MessengerSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-008">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>but these components work exactly the same in Windows Presentation Foundation, Silverlight, Windows Phone, and
                    Windows 8. We will let some user controls communicate in a decoupled manner and demonstrate a OneWay message,
                    as well as a message with feedback.
                </p>
                <p>Here we have an MVVM application with a receiver and a SenderViewModel.</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-086.png"/>
                    <figcaption>Fig 03-086</figcaption>
                </figure>
                <p>So Sender can send two kinds of messages; one message type is named LogMessage and carries a Text and a
                    Timestamp:
                </p>
                <figure>
<pre><code class="csharp">public class LogMessage
{
    public LogMessage(string text, DateTime timestamp)
    {
        Timestamp = timestamp;
        Text = text;
    }

    public string Text
    {
        get;
        private set;
    }

    public DateTime Timestamp
    {
        get;
        private set;
    }
}</code></pre>
                    <figcaption>Fig03-087</figcaption>
                </figure>
                <p>If we run the application, we notice this blue area, this is a SenderViewModel:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-088.png"/>
                    <figcaption>Fig 03-088</figcaption>
                </figure>
                <p>There is a Send button and a text field. Let's enter a message. And then we can press Send. Nothing happens
                    because there is no receiver registered to get this message. In the ApplicationBar, there is an add button:
                </p>

                <p>This adds a user control with a ReceiverViewModel as its data context. If I press the Send button now, the
                    message of type LogMessage is Sent:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-089.png"/>
                    <figcaption>Fig 03-089</figcaption>
                </figure>
                <p>because each of the ReceiverViewModel subscribed to this message type, we can see that those three user
                    controls are getting it. If we add a false user control and send the message again, we see that all four user
                    controls get the message, but for the sender it doesn't make any difference. In fact, if I remove all the
                    receivers, and send the message again, nothing happens. The sender doesn't know that no one got the message.
                </p>
                <p>Now let's look at another message type called LogMessageWithFeedback. It is based on the previous message type,
                    LogMessage:
                </p>
                <figure>
<pre><code class="csharp">namespace MessengerSample.Helpers
{
    public class LogMessageWithFeedback : LogMessage
    {
        public Action&lt;bool&gt; Feedback
        {
            get;
            private set;
        }

        public LogMessageWithFeedback(string text, DateTime timestamp, Action&lt;bool&gt; feedback)
            : base(text, timestamp)
        {
            Feedback = feedback;
        }
    }
}</code></pre>
                    <figcaption>Fig03-090</figcaption>
                </figure>
                <p>In addition, it has a Feedback property, which is an Action of bool. We will use this action to send Feedback
                    after the user has confirmed or cancelled the message. Let's register a mix of receivers.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-091.png"/>
                    <figcaption>Fig 03-091</figcaption>
                </figure>
                <p>Just like before, the red ones listen to a LogMessage. The orange ones, on the other hand, listen to a
                    LogMessageWithFeedback.
                </p>
                <p>So first, let's send a LogMessage. Here we see that only the red ones got it:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-092.png"/>
                    <figcaption>Fig 03-092</figcaption>
                </figure>
                <p>If I send a LogMessageWithFeedback, the orange ones got it, but not the red ones:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-093.png"/>
                    <figcaption>Fig 03-093</figcaption>
                </figure>
                <p>Using the LogMessageWithFeedback, the user can send some Feedback to the sender. This will execute the Action
                    of bool and the dialog is shown; for example, here OK:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-094.png"/>
                    <figcaption>Fig 03-094</figcaption>
                </figure>
                <p>or here Cancel:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-095.png"/>
                    <figcaption>Fig 03-095</figcaption>
                </figure>
                <p>Of course the parameter could be anything. Here I use the Boolean, but it could be a string or even a complex
                    object type. Let's take a look at the code. First, the two message types. This here is a LogMessage, and as
                    you can see, it's a plain old object with two properties; the Text and the Timestamp.
                </p>
                <figure>
<pre><code class="csharp">public class LogMessage
{
    public LogMessage(string text, DateTime timestamp)
    {
        Timestamp = timestamp;
        Text = text;
    }

    public string Text
    {
        get;
        private set;
    }

    public DateTime Timestamp
    {
        get;
        private set;
    }
}</code></pre>
                    <figcaption>Fig03-096</figcaption>
                </figure>
                <p>Here is now the LogMessageWithFeedback. Like we saw before, it is based on the LogMessage, so it also has the
                    two properties, Text and Timestamp, but in addition it has this Feedback property:
                </p>
                <figure>
<pre><code class="csharp">namespace MessengerSample.Helpers
{
    public class LogMessageWithFeedback : LogMessage
    {
        public Action&lt;bool&gt; Feedback
        {
            get;
            private set;
        }

        public LogMessageWithFeedback(string text, DateTime timestamp, Action&lt;bool&gt; feedback)
            : base(text, timestamp)
        {
            Feedback = feedback;
        }
    }
}</code></pre>
                    <figcaption>Fig03-097</figcaption>
                </figure>
                <p>
                    which is going to be used to send some Feedback back to the Message sender.
                </p>
                <p> Now let's go to the SenderViewModel. And here we see what happens when a message needs to be sent. First, the
                    message is constructed here:
                </p>
                <figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; SendCommand
{
    get
    {
        return _sendCommand
            ?? (_sendCommand = new RelayCommand&lt;string&gt;(
                text =>
                {
                    var message = new LogMessage(
                        text,
                        DateTime.Now);

                    Messenger.Default.Send(message);
                }));
    }
}</code></pre>
                    <figcaption>Fig03-098</figcaption>
                </figure>
                <p>we take a LogMessage, and then we use Messenger.Default to Send the message. If we need some Feedback, we will
                    go to the other command and here we build a Message with Feedback.
                </p>
                <figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; SendWithFeedbackCommand
{
    get
    {
        return _sendWithFeedbackCommand
            ?? (_sendWithFeedbackCommand = new RelayCommand&lt;string&gt;(
                text =>
                {
                    var message = new LogMessageWithFeedback(
                        text,
                        DateTime.Now,
                        result =>
                        {
                            var dialog = new MessageDialog(result ? "OK" : "Cancel");
                            dialog.ShowAsync();
                        });

                    Messenger.Default.Send(message);
                }));
    }
}</code></pre>
                    <figcaption>Fig03-099</figcaption>
                </figure>
                <p>which also takes a Text, a Timestamp, and the Action , which is going to be executed whenever the user wants to
                    give some Feedback. Here when the Action is executed, we will show a MessageDialog using the result to show
                    the string "OK" or "Cancel":
                </p>
                <figure>
<pre><code class="csharp">var dialog = new MessageDialog(result ? "OK" : "Cancel");
    dialog.ShowAsync();</code></pre>
                    <figcaption>Fig03-100</figcaption>
                </figure>
                <p>Now we can look at the ReceiverViewModel:</p>
                <figure>
<pre><code class="csharp">public ReceiverViewModel(bool useCallback)
{
    if (useCallback)
    {
        Messenger.Default.Register&lt;LogMessageWithFeedback&gt;(
            this,
            message =>
            {
                var display = string.Format(
                    "Message: {0} sent on {1:G}",
                    message.Text,
                    message.Timestamp);

                Display = display;
                _feedback = message.Feedback;
            });
    }
    else
    {
        Messenger.Default.Register&lt;LogMessage&gt;(
            this,
            message =>
            {
                var display = string.Format(
                    "Message: {0} sent on {1:G}",
                    message.Text,
                    message.Timestamp);

                Display = display;
            });
    }
}</code></pre>
                    <figcaption>Fig03-101</figcaption>
                </figure>
                <p>and this is where we will register for the type of message that we want to receiver, either for
                    LogMessageWithFeedback or with a simple LogMessage. Like we saw in the slide, the Receiver method needs a
                    reference to the receiver itself, in order to monitor the lifetime, and a delegate to the method which will be
                    executed, in this case we will build a string with the parameters from the message, Text and Timestamp, and
                    then we will assign this to the Display property, which is data bound in the XAML. In the case of the Feedback
                    message, we will also Save the _feedback property, which is an Action , so that we can execute it later.
                </p>

                <p>The execution of the Feedback is shown here:</p>
                <figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; SendFeedbackCommand
{
    get
    {
        return _sendFeedbackCommand
            ?? (_sendFeedbackCommand = new RelayCommand&lt;string&gt;(
                                  result =>
                                  {
                                      if (_feedback != null)
                                      {
                                          _feedback(result == "1");
                                      }
                                  }));
    }
}</code></pre>
                    <figcaption>Fig03-102</figcaption>
                </figure>
                <p>This is a command which is bound in the XAML to the OK and the Cancel button, and you can see that we will
                    simply execute the _feedback action and we will pass here a Boolean as a result parameter.
                </p>
                <p>
                    Finally, notice that we take care here of unregistering the two message types:
                </p>
                <figure>
<pre><code class="csharp">public void Unload()
        {
            Messenger.Default.Unregister&lt;LogMessage&gt;(this);
            Messenger.Default.Unregister&lt;LogMessageWithFeedback&gt;(this);
        }</code></pre>
                    <figcaption>Fig03-103</figcaption>
                </figure>
                <p>For simplicity, we simply unregister everything when the user control is unloaded. This is not strictly
                    necessary, because in Windows 8 even private methods can be saved with a weak reference, and the receiver can
                    be garbage collected, even if we didn't do that, but it is always a good policy to cleanly unregister whenever
                    possible.
                </p>
                <h3>Dispatching to the UI Thread With the DispatcherHelper</h3>
                <p>Now we will talk about the lesser known, but useful component of MVVM Light; the DispatcherHelper. In modern
                    applications, multithreading is more and more important. For example, Windows Presentation Foundation allows
                    doing synchronous web request to a server. However, in Silverlight, which came later, it is not possible
                    anymore. All web requests have to be asynchronous, which is to say that they are multithreaded.
                </p>
                <p>Similarly, in Windows 8, which is the most recent XAML-based framework, every file access has to be
                    asynchronous, as well as many other operations. So more and more, we see that we need to program in
                    multithreaded environments.
                </p>
                <p>However, this is not always easy. There are a few things that need to be taken care of. In this section, we
                    will talk about an issue that may very well crash your application if you don't pay attention. So let's review
                    how threading works in .NET.
                </p>
                <p>All XAML applications start with a Main Thread. This thread is like a queue, where all operations are executed
                    one after the other:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-104.png"/>
                    <figcaption>Fig 03-104</figcaption>
                </figure>
                <p>
                    From the Main Thread, it is possible to start one or more Background Threads. This can be explicit, for
                    example by calling the ThreadPool class, or by using a BackgroundWorker, etc:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-105.png"/>
                    <figcaption>Fig 03-105</figcaption>
                </figure>
                <p>In a more complex manner, however, some operations can also operate on a Background Thread, without the
                    developer being always aware of it. For example in a Phone application, some senses can raise events on the
                    Background Thread; for example, the Compass Sensor or the accelerometer, etc. Another example is the
                    HttpWebRequest class, which is used to send complex web requests to a server. Even if the request is sent from
                    an application's Main Thread, the response is always received on the Background Thread.
                </p>
                <p>One issue in that case is that we sometimes need to get back on the Main Thread from the Background Thread.
                    This is necessary, because the Main Thread owns all the UI elements. So, if an operation running on the
                    Background Thread attempts to modify an object owned by the Main Thread, an Exception is thrown because of
                    Invalid Cross Thread Access:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-106.png"/>
                    <figcaption>Fig 03-106</figcaption>
                </figure>
                <p>Here we see an example of code that can crush the application, because the StatusTextBlock is a UI element, but
                    it is accessed from the Background Thread:
                </p>
                <figure>
<pre><code class="csharp">ThreadPool.QueueUserWorkItem(
    o =>
    {
        // Do something...

        StatusTextBlock.Text = "Done"; // CRASH
});</code></pre>
                    <figcaption>Fig03-107</figcaption>
                </figure>
                <p>the Exception is thrown.</p>
                <p>In order to clean this up, we need to take some precautions. The Background Thread will contact the Main
                    Thread's Dispatcher and request that the operation accessing the UI element is executed on the Main Thread
                    directly:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-108.png"/>
                    <figcaption>Fig 03-108</figcaption>
                </figure>
                <p>The Dispatcher is a kind of controller for the thread and there is exactly one Dispatcher per thread. In code,
                    here is how we do things:
                </p>
                <figure>
<pre><code class="csharp">ThreadPool.QueueUserWorkItem(
	o =>
	{
		// Do something...

		Dispatcher.BeginInvoke(
			new Action&lt;string&gt;(UpdateStatus),
			"Done",
			DispatcherPriority.Normal);
	});
with
private void UpdateStatus(string message)
{
	StatusTextBlock.Text = message;
}</code></pre>
                    <figcaption>Fig03-109</figcaption>
                </figure>
                <p>Know that in Windows 8, things would be slightly different, but the main point remains the same. We have to use
                    a Dispatcher object to send the request to execute the operation. In this case, the UpdateStatus method on the
                    Main Thread. This method will then safely access the UI element.
                </p>
                <p>In theory, this is relatively easy, but there are a few difficulties. First, the Dispatcher property that we
                    used before is only available on the view; for example, in a page or a window.
                </p>
                <p>If we execute the method in a ViewModel, accessing the Dispatcher can be difficult. Also, the syntax is a
                    little bit complicated, and it is not the same in all the XAML frameworks. For instance, in Windows 8.1, the
                    Dispatcher API is not the same as in Windows Phone, WPF or Silverlight.
                </p>
                <p>In order to simplify all this, we can use the DispatcherHelper component of MVVM Light. So DispatcherHelper
                    stores an instance of the main Dispatcher and provides unified access to its API, whatever the framework is.
                </p>
                <p>First, the class must be initialized:</p>
                <figure>
                    <pre><code class="csharp">DispatcherHelper.Initialize();</code></pre>
                    <figcaption>Fig03-110</figcaption>
                </figure>
                <p>If possible, as soon as the application starts. It is important that the call to Initialize is executed on the
                    Main Thread, which is quite easy. Then, whenever some code is executed on a Background Thread like here:
                </p>
                <figure>
<pre><code class="csharp">ThreadPool.QueueUserWorkItem(
	o =>
	{
		// Do something...

		Dispatcher.CheckBeginInvokeOnUI(
                    () => StatusTextBlock.Text = "Done");
    });
</code></pre>
                    <figcaption>Fig03-111</figcaption>
                </figure>
                <p>the CheckBeginInvokeOnUI method can be used. This method receives a delegate, in this case a lambda expression.
                    This delegate will be executed on the Main Thread. The DispatcherHelper will check if direct access to the UI
                    element is possible. If yes, the method will be executed at once without waiting. On the other hand, if a
                    Cross Thread Access is needed, the DispatcherHelper will execute the dispatching properly.
                </p>
                <h3>DispatcherHelper Sensor Demo (Windows Phone)</h3>
                <p>We are going to see a few examples of scenarios where the DispatcherHelper becomes useful. First, we will study
                    a small Windows Phone application using the accelerometer sensor:
                </p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-010" type="text"
                               value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\before\viewmodelbase\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-010">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-011" type="text"
                               value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\after\dispatcherhelper\DispatcherHelperSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-011">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>
                    This is one of the sensors that works on the Background Thread. Not all of them do. The Geo Coordinate Watcher
                    component, for example, returns its values on the Main Thread directly. So when you read the location, you
                    don't need to dispatch the result to the UI Thread, but when you read the heading with a compass, or an
                    acceleration using the accelerometer, you need to do so to avoid a crash.
                </p>
                <p> So DispatcherHelper allows you to stop worrying about that, because it will automatically find out if
                    dispatching is needed or not.
                </p>
                <p>In this small application, I have a MainViewModel, which is going to subscribe to a service called
                    ISensorService:
                </p>
<figure>
<pre><code class="csharp">public class MainViewModel : ViewModelBase
{
    private readonly ISensorService _sensorService;

    private RelayCommand _startAccelerometerCommand;

    /// &lt;summary&gt;
    /// Gets the StartAccelerometerCommand.
    /// &lt;/summarygt;
    public RelayCommand StartAccelerometerCommand
    {
        get
        {
            return _startAccelerometerCommand
                ?? (_startAccelerometerCommand = new RelayCommand(
                                      () => _sensorService.RegisterForAcceleration(HandleHeading)));
        }
    }</code></pre>
<figcaption>Fig03-112</figcaption>
</figure>
                <p>This is an abstraction of the sensors. In this sample I only take care of the acceleration, but we could easily
                    add all the sensors, such as compass or location. The ISensorService is located in the Model. We have one
                    method called RegisterForAcceleration:
                </p>
<figure>
<pre><code class="csharp">namespace DispatcherHelperSample.Model
{
    public interface ISensorService
    {
        void RegisterForAcceleration(Action&lt;double&gt; callback);
    }
}
</code></pre>
<figcaption>Fig03-113</figcaption>
</figure>
                <p>and here is the implementation of the SensorService, and the RegisterForAcceleration method:</p>
<figure>
<pre><code class="csharp">public class SensorService : ISensorService
{
    private Action&ltdouble&gt; _callback;

    public void RegisterForAcceleration(Action&lt;double&gt; callback)
    {
        _callback = callback;

        var accelerometer = new Accelerometer();
        accelerometer.CurrentValueChanged += AccelerometerCurrentValueChanged;
        accelerometer.Start();
    }

    void AccelerometerCurrentValueChanged(object sender, SensorReadingEventArgs&lt;AccelerometerReading&gt; e)
    {
        ExecuteCallback(e.SensorReading.Acceleration);
    }</code></pre>
<figcaption>Fig03-114</figcaption>
</figure>
                <p>This method takes a callback and it will execute the callback everything that the value of the accelerometer
                    has changed. The callback is provided by the caller, in this case the MainViewModel. Let's run the application
                    in Debug mode and see what happens. If I press the Start button here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-115.png"/>
                    <figcaption>Fig 03-115</figcaption>
                </figure>
                <p>
                    the application will crash, with an invalid cross-thread access exception:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-116.png"/>
                    <figcaption>Fig 03-116</figcaption>
                </figure>
                <p>This is a symptom of what we explained earlier in the slides. The Sensor event is executed on the Background
                    Thread, which is also where the callback method is executed. However, if we inspect the MainViewModel code,
                    which provided the callback, we see that it is assigning the returned value to the StatusMessage property:
                </p>
<figure>
<pre><code class="csharp">private void HandleHeading(double heading)
{
    StatusMessage = string.Format(
        "({0:N2})",
        heading);
}</code></pre>
<figcaption>Fig03-117</figcaption>
</figure>
                <p>This wouldn't be an issue if the StatusMessage was not bound to a TextBlock in the XAML. We know that all UI
                    elements belong to the Main Thread, so the crash happens when the UI element, the TextBlock, is being touched
                    from the Background Thread through the StatusMessage property.
                </p>
                <p>To fix this, we are going to go back into the Service code and we are going to use a DispatcherHelper here:
                </p>
<figure>
<pre><code class="csharp">private void ExecuteCallback(Vector3 heading)
{
    _callback(heading.Z);
}</code></pre>
<figcaption>Fig03-118</figcaption>
</figure>
                <p>I'm going to use the CheckBeginInvokeOnUI method. This method takes an action as parameter, this is a delegate.
                    And now I can copy the code to the _callback method, which is going to be executed on the Main Thread, so this
                    is a safe zone:
                </p>
 <figure>
 <pre><code class="csharp">private void ExecuteCallback(Vector3 heading)
{
    DispatcherHelper.CheckBeginInvokeOnUI(
        () =>
        {
            _callback(heading.Z);

        });

}</code></pre>
 <figcaption>Fig03-119</figcaption>
 </figure>
                <p>Note that for this to work, we need to initialize a DispatcherHelper. It can be done anywhere in the code,
                    making sure that the Initialize method is called on the UI Thread. Typically, we do this in App.xaml.cs in one
                    of the Initializer method, so that the DispatcherHelper is initialized as early as possible. Here in the Phone
                    application, I do this in the InitializePhoneApplication method:
                </p>
<figure>
<pre><code class="csharp">private void InitializePhoneApplication()
{
    if (phoneApplicationInitialized)
        return;

    // Create the frame but don't set it as RootVisual yet; this allows the splash
    // screen to remain active until the application is ready to render.
    RootFrame = new PhoneApplicationFrame();
    RootFrame.Navigated += CompleteInitializePhoneApplication;

    DispatcherHelper.Initialize();

    // Handle navigation failures
    RootFrame.NavigationFailed += RootFrame_NavigationFailed;

    // Handle reset requests for clearing the backstack
    RootFrame.Navigated += CheckForResetNavigation;

    // Ensure we don't initialize again
    phoneApplicationInitialized = true;
}</code></pre>
<figcaption>Fig03-120</figcaption>
</figure>
                <p>Now we can run the application again and we will see that this time the application does not crash. And in fact
                    in the Simulator, we can simulate shaking the device, here, using the shake Recorded Data:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-121.png"/>
                    <figcaption>Fig 03-121</figcaption>
                </figure>
                <p>Again, not all sensors need to be dispatched to the Main Thread. The Location Sensor, for example, is
                    automatically returning on the Main Thread directly. However, if you use DispatcherHelper, you don't have to
                    worry about this.
                </p>
                <h3>DispatcherHelper WebRequest Samples (WPF and SL)</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-012" type="text"
                               value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\before\viewmodelbase\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-012">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex03-013" type="text"
                               value="Dropbox\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 3\after\dispatcherhelper\DispatcherHelperSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex03-013">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Another example is using a WPF application and a Silverlight 5 application using shared code. We are going to
                    execute web code using an HttpWebRequest. Of course this is a very simple example and we don't really need
                    this complex object; we could do the same using a web client. HttpWebRequest is useful when you need to do
                    more complex operations, but here for the purpose of the demo, we'll use that anyway, because of the fact that
                    it gets a response on a Background Thread.
                </p>
                <p>So here:</p>
<figure>
<pre><code class="csharp">private void BeginGetResponseCompleted(IAsyncResult ar)
{
    // We are on a background thread here!

    var request = ar.AsyncState as HttpWebRequest;
    if (request != null)
    {
        using (var stream = request.EndGetResponse(ar).GetResponseStream())
        {
            using (var reader = new StreamReader(stream))
            {
                var result = reader.ReadToEnd();

                // Do something with result
                DispatcherHelper.CheckBeginInvokeOnUI(
                    () =>
                    {
                        Status = "Web page was loaded";
                    });


            }
        }
    }
}</code></pre>
<figcaption>Fig03-122</figcaption>
</figure>
                <p>
                    everything inside the BeginGetResponseCompleted method is executed on this Background Thread. And as you see,
                    we are trying to set the Status property, which is data bound to a TextBlock in the XAML UI. If we run this
                    application in WPF, everything works fine:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-123.png"/>
                    <figcaption>Fig 03-123</figcaption>
                </figure>
                <p>Here I can load the web page, and after a short delay, we see that the Status was updated:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-124.png"/>
                    <figcaption>Fig 03-124</figcaption>
                </figure>
                <p>This is because WPF automatically dispatches a PropertyChanged event to the Main Thread. So here, everything
                    works fine.
                </p>
                <p>Now I'm going to stop the application, and then I'm going to move to Silverlight. Let's set this as a startup
                    project and I'm going to run the application again in Debug mode, and now if I press a Load button, we see
                    that we get an exception:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-125.png"/>
                    <figcaption>Fig 03-125</figcaption>
                </figure>
                <p>and if we check the det ails, we will see that there is an UnauthorizedAccessException:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig03-126.png"/>
                    <figcaption>Fig 03-126</figcaption>
                </figure>
                <p>so again this is an invalid cross-thread exception. So in order to get the application to work, I'm going to
                    have to use a DispatcherHelper again, and I'm going to do that in the BeginGetResponseCompleted method, just
                    when the Status property is set:
                </p>
<figure>
<pre><code class="csharp">private void BeginGetResponseCompleted(IAsyncResult ar)
{
    // We are on a background thread here!

    var request = ar.AsyncState as HttpWebRequest;
    if (request != null)
    {
        using (var stream = request.EndGetResponse(ar).GetResponseStream())
        {
            using (var reader = new StreamReader(stream))
            {
                var result = reader.ReadToEnd();

                // Do something with result
                DispatcherHelper.CheckBeginInvokeOnUI(
                    () =>
                    {
                        Status = "Web page was loaded";
                    });


            }
        }
    }
}</code></pre>
<figcaption>Fig03-127</figcaption>
</figure>
                <p>And now, again, I have created a delegate, which will be executed on the Main Thread, and so I can set the
                    Status in this safe zone.
                </p>
                <p>Now let's run the application again. And we will see that this time, the web page was loaded and the Status was
                    set properly. Because we are sharing the MainViewModel code between Silverlight and WPF, using
                    DispatcherHelper is very convenient, because in WPF nothing changes, so Status will be set directly on the
                    Main Thread without dispatching; however, in Silverlight, the dispatching will be executed, but there's a
                    developer, we don't have to worry about that; the DispatcherHelper component is taking care of this. This
                    small example shows a value of having a component, such as DispatcherHelper, in order to simplify
                    multithreaded code.
                </p>
                <h3>Summary</h3>
                <p>In this module, we discovered the core components of MVVM Light and we learned the features. We talked about
                    the base classes used to make observable properties easier to use; the ObservableObject and the ViewModelBase.
                </p>
                <p>Then we studied commanding in .NET and we understood how the RelayCommand component of MVVM Light simplifies
                    this task.
                </p>
                <p>We continued our tour with the Messenger component, a system allowing to send decoupled messages, even if the
                    sender and the receiver don't know each other.
                </p>
                <p>And finally we finished with a short explanation of multithreading and dispatching in .NET, and discovered the
                    DispatcherHelper component of MVVM Light.
                </p>
                <p>In the next module, we will continue to explore MVVM Light by discovering the Extras assembly and the
                    components that it contains.
                </p>
            </div>
        </div>
    </div>
</div>
