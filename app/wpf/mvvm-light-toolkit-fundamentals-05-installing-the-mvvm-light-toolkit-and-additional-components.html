<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Installing the MVVM Light Toolkit and Additional Components</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>Welcome to Module 5 of the MVVM Light Toolkit reference course. In previous modules, we saw what the
                    advantages are of an MVVM architecture over an event-based architecture for XAML-based applications.
                    We understood what steps were needed to refactor an event-based app to an MVVM app. And we saw that
                    some repetitive operations could benefit from some automation.
                </p>
                <p>
                    This is when we introduce the MVVM Light Toolkit's components, starting with the Code DLL and then
                    following up with the Extras DLL. This rounded up the presentation of the first-half of the
                    toolkit's elements.
                </p>
                <p>
                    In this module, we will introduce additional elements, such as project templates and code snippets.
                    These additional tools are the reason why we don't talk of MVVM Light as a framework. In fact, it is
                    a suite of tools, as well as a guidance to build applications, which is why the name toolkit is more
                    appropriate.
                </p>
                <p>First, we will see how you can install MVVM Light in your application using NuGet, or, on your PC
                    using an installer. We will understand the differences between these two approaches.
                </p>
                <p>
                    Then, after the whole toolkit is installed, we will learn more about the additional components,
                    starting with the code snippets. We will understand how they can help you to be more productive in
                    Visual Studio, especially when writing repetitive code.
                </p>
                <p>Then, we will review a typical application created with an MVVM Light project template and see how it
                    is structured and what are the advantages over a classic app. We will also talk about the item
                    templates used to create new Views, new ViewModels, or a new ViewModelLocator.
                </p>
                <h3>Using the Assemblies From Nuget</h3>
                <p>First, let's talk about NuGet, the package manager that has become very popular in recent years to
                    manage the dependencies of an application, notably of .NET applications. NuGet makes it convenient
                    for application developers to find the most recent version of a library, and to make sure that all
                    the dependencies are loaded correctly.
                </p>
                <p>
                    Instead of adding references to a single assembly, the developer manages references to packages of
                    assemblies, which in turn can reference other packages. When the package is referenced in the
                    project, the NuGet system will load the newest version of all necessary dependencies.
                </p>
                <p>
                    In addition, if later a newer version is found of the package itself or of a dependency, it is easy
                    to get notified and to load the newer version if desired.
                </p>
                <p>
                    NuGet is available as a command line tool, which makes it easy to integrate it with automated tools.
                    It is also available as a more human-friendly Visual Studio extension, which is what we will use in
                    this module.
                </p>
                <p>
                    There are quite a few advantages in using NuGet to manage your project dependencies. First, a
                    package can contain more than just binaries. When a package is installed, it is possible that it
                    also adds files to the project. It is even possible to run a PowerShell script to modify the target
                    project. In the case of MVVM Light, the user can optionally take advantage of this to create an
                    almost fully-functional MVVM Light application just by referencing the NuGet package that we will
                    see later in this module.
                </p>
                <p>
                    Before NuGet, .NET developers often had to manage the dependencies either by referencing a series of
                    single DLLs, which had to be committed to source control, or by installing an SDK on each developer
                    machine. If the SDK was missing on the new machine, it was not possible to build the application
                    after pulling it from source control.
                </p>
                <p>
                    With NuGet, however, the whole packages are saved and can be committed to source control, too. This
                    way, when the project is pulled on a new machine, it is immediately ready to be built. As we
                    mentioned, NuGet makes it easy to handle updates to a package or to its references.
                </p>
                <p>
                    Also, NuGet servers can be handled by a firm, a group of developers, etc. This makes it possible to
                    deploy packages that are not for the whole world to see, but only to a restricted group of
                    developers. In this module, we will use Microsoft's nuget.org server to load MVVM Light.
                </p>
                <p>
                    There is one main disadvantage to NuGet, however. If the PC is not online when the package is added
                    to the project, it cannot find the NuGet server and the process fails. Note that the PC must only be
                    online at the moment of the addition of the NuGet package. Once the package has been added, the
                    development can continue offline without problems. In the case of MVVM Light, we will see that an
                    offline mechanism is also available to create new applications, even when the target PC is not
                    online.
                </p>
                <p>
                    On Visual Studio 2012 and 2013, NuGet is already available by default. In Visual Studio 2010,
                    however, you need to install it manually. It is quite simple by using the integrated Extension
                    Manager. Here is Visual Studio 2010. Now I can open the Extension Manager from the Tools menu, and
                    here we see that NuGet is already installed. If that is not the case, I can search in the Online
                    Gallery and install NuGet from there.
                </p>
                <h3>A Quick Nuget Demo</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-001" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\before\NugetIntro\NugetIntro.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-001">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-002" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\after\NugetIntro\NugetIntro.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-002">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Let's see a quick demo about NuGet. Here we have a WPF application without any additional components.
                    This application needs to load and parse a JSON file from a web server when the Main button is
                    clicked.
                </p>
                <p>Here is the code, which is using the WebClient:</p>
<figure>
<pre><code class="csharp">var client = new WebClient();</code></pre>
<figcaption>Fig05-001</figcaption>
</figure>
                <p>
                    to connect to the web server and load the JSON file as text. And here is a small C# class, which
                    will be used to contain the data parsed from the JSON file:
                </p>
<figure>
<pre><code class="csharp">public class MyClass
    {
        public string Property1
        {
            get;
            set;
        }

        public int Property2
        {
            get;
            set;
        }
    }
</code></pre>
<figcaption>Fig05-002</figcaption>
</figure>
                <p>
                    Instead of writing the passing code ourselves, it is easier to use an existing package; for example,
                    the popular Json.NET. This great library is available on NuGet, so let's look for it. Here I will
                    right-click on the References folder and select â€˜Manage NuGet Packages'. Then, I make sure that the
                    nuget.org option is selected on the left, and I search for JSON. I make sure to select the correct
                    package and then I select Install.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-003.png"/>
                    <figcaption>Fig 05-003</figcaption>
                </figure>
                <p>
                    What just happened now is that Json.NET was downloaded from the NuGet servers and the assemblies
                    were referenced in our application. Then we can close this dialog, and go back to the code.
                </p>
                <p>
                    The last thing I need to do, is go back to my MainWindow.xaml and add the line which is going to
                    deserialize the JSON text into an instance of MyClass. Let's inspect this line, and here we see the
                    usage of the JsonConvert class, which comes from Json.NET.
                </p>
<figure>
<pre><code class="csharp">try
{
    var myInstance = JsonConvert.DeserializeObject&lt;MyClass&gt;(e.Result);

    MessageBox.Show(string.Format("String value: {0}", myInstance.Property1));
    MessageBox.Show(string.Format("Int value: {0}", myInstance.Property2));
}
catch
{

}</code></pre>
                    <figcaption>Fig05-004</figcaption>
                </figure>
                <p>
                    If I run the code now and click on the button, we see that the deserialization takes place and the
                    properties were passed properly.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-005.png"/>
                    <figcaption>Fig 05-005</figcaption>
                </figure>
                <h3>Libraries Only vs. Full</h3>
                <p>When you search for MVVM Light in NuGet, you will see that there are three versions of MVVM Light
                    there. Let's understand the differences. One of the packages is named libraries only. This is a
                    package most suited for people who have a certain experience with MVVM Light already. It adds only
                    the necessary DLLs, so that all the components we saw in previous modules can be used. But it
                    doesn't modify the target project at all. Similarly, if you add MVVM Light to a class library in
                    order to use its objects, you must select the libraries only. The library is loaded with Core and
                    Extras elements of MVVM Light, as well as the System.Windows.Interactivity DLL required by
                    EventToCommand. On platforms where it is available, it also adds a dependency to another NuGet
                    package, named CommonServiceLocator.
                </p>
                p
                <p>In addition to the libraries, the full version of MVVM Light available on NuGet also installs a
                    ViewModelLocator and a MainViewModel. This version of the package is most suited for new
                    applications that have just been created. It uses an Install script to add additional plumbing in
                    App.xaml, so that the ViewModelLocator is loaded as a global resource, as we saw in the previous
                    module.
                </p>
                <p>
                    Note that in this version of the package, the libraries are added as a dependency through the
                    "libraries only" NuGet Package. It makes it easier to handle the DLL. Notably, the application has a
                    main application and some satellite assemblies, which also need MVVM Light. In that case, the DLLs
                    are loaded only once from NuGet. Finally, there is also a portable class library version of MVVM
                    Light, which is handled as a separate package.
                </p>
                <h3>Adding MVVM Light to an App With Nuget (Demo)</h3>
                <p>For the demo, I created an empty WPF application here:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-006.png"/>
                    <figcaption>Fig 05-006</figcaption>
                </figure>
                <p>
                    Then, I will add the MVVM Light Libraries using NuGet. We do the same things as we did before with
                    Json.NET.
                </p>
                <p>
                    First, we right-click on the References folder and select â€˜Manage NuGet Packages'. Once a dialog is
                    loaded, we search online for MVVM Light. Here, I will add the libraries only package. Notice that
                    you can see all the details on the right, including the description, the tags, dependencies, and the
                    link to the license.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-007.png"/>
                    <figcaption>Fig 05-007</figcaption>
                </figure>
                <p>
                    Let's click on Install. After a short while, the MVVM Light libraries are installed. If I close the
                    dialog and expand the References folder, I can see the DLLs here and here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-008.png"/>
                    <figcaption>Fig 05-008</figcaption>
                </figure>
                <p>
                    From this moment on, I can use all the objects that we studied in the previous modules. For example,
                    this is the MainPage. And here I can use the Messenger to send an initialization message when the
                    MainPage has been loaded:
                </p>
<figure>
<pre><code class="csharp">public partial class MainWindow : Window
{
	public MainWindow()
	{
		InitializeComponent();

		Loaded += (s, e) =>
		{
			Messenger.Default.Send(new NotificationMessage.....
		};
	}
}</code></pre>
<figcaption>Fig05-009</figcaption>
</figure>
                <p>
                    Now let's see what happens when we pull the Full MVVM Light through NuGet. First, I created a new
                    empty Windows Phone application:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-010.png"/>
                    <figcaption>Fig 05-010</figcaption>
                </figure>
                <p>
                    I will, again, use NuGet, but this time I will select the Full MVVM Light package. Let's search here
                    for mvvmlight. And this time I click Install on the first package here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-011.png"/>
                    <figcaption>Fig 05-011</figcaption>
                </figure>
                <p>
                    And once installation is complete, we notice what we mentioned before; the Full MVVM Light package
                    also uses the libraries only:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-012.png"/>
                    <figcaption>Fig 05-012</figcaption>
                </figure>
                <p>
                    Now I can close this dialog. I see a new folder, named ViewModel:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-013.png"/>
                    <figcaption>Fig 05-013</figcaption>
                </figure>
                <p>
                    Inside it, we find the ViewModelLocator and the MainViewModel. Also, if I switch to App.xaml, I see
                    that the ViewModelLocator has been added to the application's global resources, like we explained in
                    the previous module:
                </p>
<figure>
<pre><code class="xml">&lt;Application.Resources&gt;
    &lt;ResourceDictionary&gt;
        &lt;vm:ViewModelLocator x:Key="Locator" d:IsDataSource="True" xmlns:vm="clr-namespace:Mvvmlight.ViewModel" /&gt;
    &lt;/ResourceDictionary&gt;
&lt;/Application.Resources&gt;</code></pre>
<figcaption>Fig05-014</figcaption>
</figure>
                <p>
                    So now we can do the following. First, I'm going to open the MainViewModel and I'm going to add a
                    property named Message:
                </p>
<figure>
<pre><code class="csharp">public string Message
        {
            get
            {
                return "Hello Nuget";
            }
        }</code></pre>
<figcaption>Fig05-015</figcaption>
</figure>
                <p>
                    This is a simple string property. Now let's build the application. Then I can open the application's
                    MainPage in Blend. If we switch to the Data pane and check the DataContext of the page, we see that
                    it is not set.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-016.png"/>
                    <figcaption>Fig 05-016</figcaption>
                </figure>
                <p>
                    The NuGet version of MVVM Light does not set the MainPage's DataContext, because it would be too
                    dangerous to tinker with an existing application's DataContext. But in Blend it is very easy to
                    correct. Notice that on the Project, we can see the ViewModelLocator in the Resources:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-017.png"/>
                    <figcaption>Fig 05-017</figcaption>
                </figure>
                <p>
                    This is the content of the App.xaml's resources. The ViewModelLocator is visible to Blend, because
                    the NuGet Install script took care of setting the IsDataSource attribute to true. So now it is
                    possible to expand the ViewModelLocator and to drag the Main property, which is the MainViewModel,
                    on the application page:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-018.png"/>
                    <figcaption>Fig 05-018</figcaption>
                </figure>
                <p>
                    Blend proposes to set the page's DataContext to the MainViewModel, which is what we want. And now
                    the DataContext has been set. Note that in WPF the experience is just a little bit different, but
                    the same steps can be followed and the end result is the same. Now that the DataContext has been
                    set, we can expand the MainViewModel here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-019.png"/>
                    <figcaption>Fig 05-019</figcaption>
                </figure>
                <p>
                    and drag the Message property on the MainPage, which is going to create a TextBlock with the
                    appropriate DataBinding.
                </p>
                <h3>Installing the Whole Package in Visual Studio</h3>
                <p>NuGet is great when you want to make sure that you have the latest version of the package, but it
                    also has limitations. As we mentioned earlier, it only works when you are online. If not, the
                    Package Explorer cannot connect to the server. Of course nowadays it is mostly not a problem, but I
                    sometimes encounter situations, for example on a plane, where I cannot use NuGet.
                </p>
                <p>
                    The other problem is that NuGet cannot install templates or snippets, at least not without some kind
                    of workaround. These additional tools are very convenient. The project and item templates are
                    creating projects, respectively items, which are already formatted to follow the MVVM Light
                    recommendations. We will check these items more in details later. As for the code snippets, they are
                    shortcuts adding code at the cursor location and allow easy replacement of certain tokens.
                </p>
                <p>
                    For example, you can use the MVVM Light code snippets to add a RelayCommand or an observable
                    property to your code easily, as we will see in just a moment.
                </p>
                <p>
                    Note that because the installation process changes in the latest versions of MVVM Light, you should
                    uninstall previous versions before you proceed with the installation of the most recent. To do this,
                    please follow the steps on the page listed here.
                </p>
                <p>
                    To add the full MVVM Light installation to your development environment, we are going to use another
                    installation medium, also directly from within Visual Studio, the Extensions Dialog. Here we have a
                    fresh new installation of Visual Studio without MVVM Light installed. We can see that, because if I
                    select File, New, Project, we don't see the MVVM Light Project Templates here under Visual C#:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-020.png"/>
                    <figcaption>Fig 05-020</figcaption>
                </figure>
                <p>
                    So now let's open the Extensions and Updates dialog from the Tools menu. I'm going to select Online
                    and then I'm going to type mvvmlight here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-021.png"/>
                    <figcaption>Fig 05-021</figcaption>
                </figure>
                <p>
                    Immediately we see the latest version of MVVM Light available, and we can install it by selecting
                    Download. Here we need to Accept the license. And after the installation is complete, we need to
                    restart Visual Studio, which can be done very easily.
                </p>
                <p>
                    Now if I reopen the File, New, Project dialog, I can see the MvvmLight Project Templates:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-022.png"/>
                    <figcaption>Fig 05-022</figcaption>
                </figure>
                <p>
                    For example, on the Windows Store, Windows, Silverlight, Windows Phone, etc. Also, the code snippets
                    have been installed. So, for example, if I create a new MvvmLight application for Silverlight 5
                    here, I can open the MainPage.xaml, here is a code behind:
                </p>
<figure>
<pre><code class="csharp">namespace MvvmLight1
{
	public partial class MainPage : UserControl
	{

		public MainPage()
		{
			InitializeComponent();
		}
	}
}</code></pre>
<figcaption>Fig05-023</figcaption>
</figure>
                <p>
                    and then I can type anywhere in the code, mvvm, and here we see the code snippets installed:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-024.png"/>
                    <figcaption>Fig 05-024</figcaption>
                </figure>
                <p>
                    We will talk much more about the code snippets in a moment, so don't worry if you don't see them yet
                    after you install MVVM Light on your machine
                </p>
                <p>
                    So to recapitulate, in order to install the full-blown MVVM Light installation, first uninstall
                    previous version. Then, from within Visual Studio, you can select Tools, Extensions and Updates,
                    Online, and then Search for "mvvmlight".
                </p>
                <p>
                    Or if you prefer, you can also navigate to mvvmlight.codeplex.com, and then download the Installer
                    package from the Downloads page. However, make sure that you select the correct version of the VSIX
                    Installer package; for example, there is a different one for Visual Studio 2012 and for Visual
                    Studio 2013.
                </p>
                <p>
                    If you are using Visual Studio Express, you cannot use a Visual Studio Gallery to install MVVM
                    Light, unfortunately. There are a few technical restrictions in place. So here, what you want to do,
                    after you install Visual Studio Express, is to navigate to mvvmlight.codeplex.com, and install the
                    VSIX Installer from the Downloads page. Here, too, make sure to select the right version.
                </p>
                <h3>Introducing the Code Snippets</h3>
                <p>All MVVM Light code snippets start with the letters "mvvm". So like we saw earlier, if you place your
                    cursor in the code and type "mvvm", you should see the list of all snippets shown in IntelliSense.
                    Then you can expand the snippet by using the "Tab" key. Once a snippet is expanded, you can navigate
                    from token to token in order to replace them by using the "Tab" key again
                </p>
                <p>
                    MVVM Light snippets are grouped by functions. For example, we have mvvminpc, which are all snippets
                    used to add an "observable property". inpc is the abbreviation for INotifyPropertyChanged. Or,
                    mvvmrelay are for RelayCommands, etc.
                </p>
                <p>
                    Then, you can select the snippet that is adapted to your needs. For example, the mvvmrelaygeneric
                    adds a RelayCommand with a generic parameter. In the demo later, we will review these snippets. Here
                    we see the IntelliSense window with all the MVVM Light snippets:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-025.png"/>
                    <figcaption>Fig 05-025</figcaption>
                </figure>
                <p>
                    Note that each snippet is documented, so if you select it without pressing Enter, you will see what
                    this particular snippet does.
                </p>
                <p>
                    One small known issue, if you are using ReSharper, this tool has its own snippets, which are not
                    compatible with the standard IntelliSense ones. This causes the MVVM Light code snippets to be
                    invisible, just like any other Visual Studio snippets. So if you want to restore the standard
                    IntelliSense, you need to change the ReSharper Settings, on the ReSharper, Options, IntelliSense,
                    and then General. And then you can switch here, from ReSharper to Visual Studio, and press Save.
                </p>
                <h3>The "INPC" Code Snippets Demo</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-003" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\before\NugetIntro\NugetIntro.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-003">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-004" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\after\SnippetsSample\SnippetsSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-004">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Now let's see a few code snippets more in details. We cannot review all of them, because there are
                    too many, but we will see the most important ones and then you can study the others on your own.
                    Here is the ViewModel class:
                </p>
<figure>
<pre><code class="csharp">using GalaSoft.MvvmLight;

namespace MvvmLight1.ViewModel
{
	public class MainViewModel : ViewModelBase
	{

	}
}</code></pre>
<figcaption>Fig05-026</figcaption>
</figure>
                <p>
                    and I will add some properties to it. Because the ViewModel inherits a ViewModelBase class, I have
                    access to some Utility methods like we saw in Module 3, but we also saw that adding an observable
                    property requires quite a bit of typing; what we call boilerplate code. Note that because this
                    snippet group uses methods defined in the ViewModelBase and ObservableObject classes, it will cause
                    a compilation error if you add an inpc snippet in a class that doesn't inherit from these base
                    classes.
                </p>
                <p>
                    To automate adding a property, let's just type mvvm. In the inpc section, we have a few choices.
                    Here, let's start with the basic mvvminpc:
                </p>
<figure>
<pre><code class="csharp">public class MainViewModel : ViewModelBase
{
	mvvminpc
}</code></pre>
<figcaption>Fig05-027</figcaption>
</figure>
                <p>
                    If I expand the snippet by typing Tab we can see the expanded code:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="MyProperty" /&gt; property's name.
/// &lt;/summary&gt;
public const string MyPropertyPropertyName = "MyProperty";

private bool _myProperty = false;

/// &lt;summary&gt;
/// Sets and gets the MyProperty property.
/// Changes to that property's value raise the PropertyChanged event.
/// &lt;/summary&gt;
public bool MyProperty
{
	get
	{
		return _myProperty;
	}

	set
	{
		if (_myProperty == value)
		{
			return;
		}

		_myProperty = value;
		RaisePropertyChanged(MyPropertyPropertyName);
	}
}
</code></pre>
<figcaption>Fig05-028</figcaption>
</figure>
                <p>
                    There are a few tokens that can be replaced. You can jump from token to token using the Tab key. The
                    first token is a property's name. Let's type the name "Status" here. The second token is a
                    property's type set to bool by default. Let's change that to a string. Then, we add the name of the
                    private field. Let's use _status too, but with the attribute conventions. Of course, you can use
                    anything you prefer. Finally, we type the initial value, in this case a _status message, such as
                    "Initializing":
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="Status" /&gt; property's name.
/// &lt;/summary&gt;
public const string StatusPropertyName = "Status";

private string _status = "Initializing";

/// &lt;summary&gt;
/// Sets and gets the Status property.
/// Changes to that property's value raise the PropertyChanged event. 
/// &lt;/summary&gt;
public string Status
{
	get
	{
		return _status;
	}

	set
	{
		if (_status == value)
		{
			return;
		}

		_status = value;
		RaisePropertyChanged(StatusPropertyName);
	}
}</code></pre>
<figcaption>Fig05-029</figcaption>
</figure>
                <p>
                    Once you are done, press Escape and the snippet is complete. Notice that this snippet had the
                    constant for the property's name:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="Status" /&gt; property's name.
/// &lt;/summary&gt;
public const string StatusPropertyName = "Status";</code></pre>
<figcaption>Fig05-030</figcaption>
</figure>
                <p>
                    which can be useful when you are outside of this class and need to handle the PropertyChanged event.
                    Here, there is a check of the new value:
                </p>
<figure>
<pre><code class="csharp">if (_status == value)
{
    return;
}</code></pre>
<figcaption>Fig05-031</figcaption>
</figure>
                <p>
                    and then we raise two events; PropertyChanging before the value is set, and PropertyChanged after
                    the value is saved:
                </p>
<figure>
<pre><code class="csharp">RaisePropertyChanging(StatusPropertyName);
_status = value;
RaisePropertyChanged(StatusPropertyName);</code></pre>
<figcaption>Fig05-032</figcaption>
</figure>
                <p>
                    Let's add another property for the user's first name. This time we will use another snippet; for
                    example, let's select the one called mvvminpclambda:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-033.png"/>
                    <figcaption>Fig 05-033</figcaption>
                </figure>
                <p>
                    This snippet uses a RaisePropertyChanged method overload, which takes an expression instead of a
                    string for the property's name. We mentioned some of the advantages of this approach, notably it
                    makes it easier to refactor a property's name.
                </p>
                <p>
                    Here, too, we can replace a token; FirstName for the name of the property, the type is a string, the
                    private attribute is also called _firstName, and the initial value will be empty. And then we can
                    see the result, which is almost the same as the previous example:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="FirstName" /&gt; property's name.
/// &lt;/summary&gt;
public const string FirstNamePropertyName = "FirstName";

private string _firstName;

/// &lt;summary&gt;
/// Sets and gets the FirstName property.
/// Changes to that property's value raise the PropertyChanged event.
/// &lt;/summary&gt;
public string FirstName
{
	get
	{
		return _firstName;
	}

	set
	{
		if (_firstName == value)
		{
			return;
		}

		RaisePropertyChanging(() =&gt; FirstName);
		_firstName = value;
		RaisePropertyChanged(() =&gt; FirstName);
	}
}</code></pre>
<figcaption>Fig05-034</figcaption>
</figure>
                <p>
                    but this time using Expressions instead of the string-based property name.
                </p>
                <p>
                    Now, let's add the last name too. This time we can use a Set method:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-035.png"/>
                    <figcaption>Fig 05-035</figcaption>
                </figure>
                <p>
                    If you'll remember, we saw in Module 3 how this method simplifies the status code a bit. Let's
                    replace a token; LastName for the name of the property, string for the type, _lastName for the
                    private attribute, and no initial value. After we replace the tokens, we see that the setter is only
                    one line of code, instead of seven like before:
                </p>
<figure>
<pre><code class="csharp">Set(LastNamePropertyName, ref _lastName, value);</code></pre>
<figcaption>Fig05-036</figcaption>
</figure>
                <p>
                    We saw the meaning of the Set method in Module 3 about the ViewModelBase and ObservableObject
                    classes. This convenient method simplifies ViewModel code. As a reminder, it also returns true, if
                    the event has been raised.
                </p>
                <p>
                    Finally, let's see a special case. Sometimes it can be interesting to not only raise a
                    PropertyChanged event, but also to send a message using the Messenger class that we studied earlier.
                    There is an overload of the RaisePropertyChanged method for this. Here is how we can use it with a
                    snippet. Add any of the mvvminpc snippets with a Name and with the letter msg. For example, here I
                    will use mvvminpcsetlambdamsg, which is quite a long name:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-037.png"/>
                    <figcaption>Fig 05-037</figcaption>
                </figure>
                <p>
                    When the snippet is expanded and after we replace all the tokens, this is the Age property:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="Age" /&gt; property's name.
/// &lt;/summary&gt;
public const string AgePropertyName = "Age";

private int _age = 42;

/// &lt;summary&gt;
/// Sets and gets the Age property.
/// Changes to that property's value raise the PropertyChanged event. 
/// This property's value is broadcasted by the MessengerInstance when it changes.
/// &lt;/summary&gt;
public int Age
{
	get
	{
		return _age;
	}

	set
	{
		Set(() =&gt; Age, ref _age, value, true);
	}
}</code></pre>
<figcaption>Fig05-038</figcaption>
</figure>
                <p>
                    Note that the Set method here takes a Boolean parameter set to true:
                </p>
<figure>
<pre><code class="csharp">Set(() =&gt; Age, ref _age, value, true);</code></pre>
<figcaption>Fig05-039</figcaption>
</figure>
                <p>
                    which will call the Messenger to send a PropertyChangedMessage. This is one of the built-in types in
                    MVVM Light.
                </p>
                <p>
                    To illustrate that, I built a small UI here in Blend with the FirstName, the LastName, and the Age:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-040.png"/>
                    <figcaption>Fig 05-040</figcaption>
                </figure>
                <p>
                    These fields are data bound to the corresponding properties on the MainViewModel. Now, in Visual
                    Studio, let's check this Emailer class that I added:
                </p>
                <figure>
<pre><code class="csharp">public class Emailer
{
    public Emailer()
    {
        Messenger.Default.Register&lt;PropertyChangedMessage&lt;int&gt;&gt;(
            this,
            message =&gt;
            {
                if (message.Sender is MainViewModel
                    && message.PropertyName == MainViewModel.AgePropertyName)
                {
                    // Send an email congratulating for the birthday

                    MessageBox.Show(string.Format("Your new age is {0}", message.NewValue));
                }
            });
    }
}</code></pre>
                    <figcaption>Fig05-041</figcaption>
                </figure>
                <p>
                    We see that when it is created, it registers a handler for a PropertyChangedMessage of int. First,
                    it will check the type of the Sender and the Name of the Property:
                </p>
<figure>
<pre><code class="csharp">if (message.Sender is MainViewModel
    && message.PropertyName == MainViewModel.AgePropertyName)</code></pre>
<figcaption>Fig05-042</figcaption>
</figure>
                <p>
                    If the Property is the Age, it sends an email here:
                </p>
<figure>
<pre><code class="csharp">// Send an email congratulating for the birthday

MessageBox.Show(string.Format("Your new age is {0}", message.NewValue));</code></pre>
<figcaption>Fig05-043</figcaption>
</figure>
                <p>
                    using the NewValue that it just received. In addition, just for test, it will show a MessageBox here
                    as well.
                </p>
                <p>
                    This example is a little bit silly, but it illustrates the youthfulness of the
                    PropertyChangedMessage, which extends the concept of the PropertyChanged event. And to show that it
                    works, after we run the application, we can change the Age here, and here is a MessageBox from the
                    Emailer class:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-044.png"/>
                    <figcaption>Fig 05-044</figcaption>
                </figure>
                <h3>The "RELAY" Code Snippets Demo</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-005" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\before\NugetIntro\NugetIntro.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-005">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-006" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\after\SnippetsSample\SnippetsSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-006">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>
                    Another useful group of snippets is used to add a RelayCommand to your code. This snippet can be
                    used in any class, though in general we use that in ViewModels too. Here, too, there are multiple
                    variations of the snippet. The default one is called mvvmrelay, which adds a RelayCommand without
                    any parameter.
                </p>
                <p>
                    So let's go back to the MainViewModel. And I'm going to extend it with a new RelayCommand used to
                    show the user's full name. First I'm going to Tab mvvmr and then I'm going to select the mvvmrelay
                    snippet:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-045.png"/>
                    <figcaption>Fig 05-045</figcaption>
                </figure>
                <p>
                    Let's expand it. And then I can Tab to replace the tokens. The first token is the name of the field
                    hosting the command. We are going to type _showFullNameCommand. And then Tab to the next one, which
                    is the name of the property itself, again, ShowFullNameCommand. And now we are done already:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// Gets the ShowFullName.
/// &lt;/summary&gt;
public RelayCommand ShowFullNameCommand
{
	get
	{
		return _showFullNameCommand
			?? (_showFullNameCommand = new RelayCommand(
								  () =>
								  {
									  MessageBox.Show(
										  string.Format("{0}, {1}", LastName, FirstName));
								  }));
	}
}
</code></pre>
<figcaption>Fig05-046</figcaption>
</figure>
                <p>
                    So I can go back to the first token and type Enter, which is going to automatically place a cursor
                    in the location where it makes the most sense to start typing code. Here I will cheat a little bit
                    and use some code that I prepared already. And here we go:
                </p>
                <figure>
<pre><code class="csharp">return _showFullNameCommand
    ?? (_showFullNameCommand = new RelayCommand(
          () =>
          {
              MessageBox.Show(
                  string.Format("{0}, {1}", LastName, FirstName));
          }));</code></pre>
    <figcaption>Fig05-047</figcaption>
</figure>
                <p>
                    this code is going to use a MessageBox to show the user's full name. Let's get ready to build the
                    application, here we are. Now I can build. Now I go back to Blend, where I added a button saying
                    â€˜Show full name':
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-048.png"/>
                    <figcaption>Fig 05-048</figcaption>
                </figure>
                <p>
                    And what I'm going to do is bind the Command property of the button:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-049.png"/>
                    <figcaption>Fig 05-049</figcaption>
                </figure>
                <p>
                    to the command that we just added in the ViewModel, here we are:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-050.png"/>
                    <figcaption>Fig 05-050</figcaption>
                </figure>
                <p>
                    Here, too, I can run the application directly from Blend. Let's Enter my name, and now I can click
                    on â€˜Show full name', which is going to show the full name as defined:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-051.png"/>
                    <figcaption>Fig 05-051</figcaption>
                </figure>
                <p>
                    This last snippet was a basic RelayCommand without the canexecute delegate and without a generic
                    parameter. We can, however, use a full-blown RelayCommand with all the options, using the snippet
                    called mvvmrelaygenericcanexecute.
                </p>
                <p>
                    Let's consider this UI here. We have a textbox and a button:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-052.png"/>
                    <figcaption>Fig 05-052</figcaption>
                </figure>
                <p>
                    Now let's extend the MainViewModel and add the RelayCommand with a generic parameter and the
                    canexecute method. So I'm typing mvvm and I'm going to select the mvvmrelaygenericcanexecute, here
                    we go:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-053.png"/>
                    <figcaption>Fig 05-053</figcaption>
                </figure>
                <p>
                    Then I will replace the token. The first token is a type of the Command parameter. Here, I want to
                    check the string entered by the user, so I set this parameter type to string, which is a default.
                    Then I Tab to the next token, which is a field name for the command. Let's call that
                    _sendEmailCommand. If I Tab again, I have the name of the property itself, SendEmailCommand, and
                    then another Tab is going to enter the name of the Execute method's parameter; this is the
                    emailInput.
                </p>
                <p>
                    Finally, we Tab once more to enter the canexecute expression. Here I will enter a simple expression,
                    just checking if the user entered some characters. Of course in production, you will want to
                    validate the email address against a regular expression, etc:
                </p>
                <figure>
<pre><code class="csharp">private RelayCommand&lt;string&gt; _sendEmailCommand;

/// &lt;summary&gt;
/// Gets the SendEmailCommand.
/// &lt;/summary&gt;
public RelayCommand&lt;string&gt; SendEmailCommand
{
    get
    {
        return _sendEmailCommand
            ?? (_sendEmailCommand = new RelayCommand&lt;string&gt;(
                                  emailInput =>
                                  {
                                      // Send email
                                  },
                                  emailInput => !string.IsNullOrEmpty(emailInput)));
    }
}</code></pre>
                    <figcaption>Fig05-054</figcaption>
                </figure>
                <p>
                    Let's build the application now to have everything up-to-date in Blend.
                </p>
                <p>
                    Now we can do some data binding. I can bind the Command property of the button to the new Command
                    that we just declared on the MainViewModel:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-055.png"/>
                    <figcaption>Fig 05-055</figcaption>
                </figure>
                <p>
                    Let's use a â€˜Create Data Binding' Editor, and here I can see the ShowEmailCommand:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-056.png"/>
                    <figcaption>Fig 05-056</figcaption>
                </figure>
                <p>
                    Then, I will bind the CommandParameter to the text value of the EmailTextBox:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-057.png"/>
                    <figcaption>Fig 05-057</figcaption>
                </figure>
                <p>
                    Let's go here and select ElementName, then EmailTextBox, and here I will choose the Text property,
                    which is down there:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-058.png"/>
                    <figcaption>Fig 05-058</figcaption>
                </figure>
                <p>
                    Whenever the parameter changes, the canexecute delegate will be reevaluated. If the returned value
                    is false, which is when the email field is empty, the button will be disabled, like we see now on
                    the screen:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-059.png"/>
                    <figcaption>Fig 05-059</figcaption>
                </figure>
                <p>
                    Let's run the application to test what we just did. And here if I go to the email field and enter
                    something, you see that the button is now enabled:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-060.png"/>
                    <figcaption>Fig 05-060</figcaption>
                </figure>
                <p>If, on the other hand, I delete everything, the button is now disabled.
                </p>
                <h3>'The "PROPDP" and "PROPA" Snippets Demo</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-007" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\before\NugetIntro\NugetIntro.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-007">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex05-008" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 5\after\SnippetsSample\SnippetsSample.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex05-008">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>The few snippets that we just saw are the ones that are the most useful when implementing the
                    ViewModel. There are a few other snippets that are less directly related to MVVM itself. In this
                    category, we find the Dependency Property and Attach Property snippets.
                </p>
                <p>
                    Dependency Properties are a specific feature of XAML-based frameworks, such as WPF, Silverlight,
                    Windows 8, Windows Phone, that enable a lot of interesting features, especially in controls. In
                    fact, if you use a default installation of Visual Studio, there are already two snippets available
                    by default that allow you to declare a new dependency property and a new attach property. Let's see
                    why MVVM Light also has such snippets, and how they are different.
                </p>
                <p>
                    First, let's add a dependency property in a WPF application. Note that you cannot declare a
                    dependency property in a ViewModel or in a plain old object. It needs to be a DependencyObject; for
                    example, here, the application's MainWindow:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// Interaction logic for MainWindow.xaml
/// &lt;/summary&gt;
public partial class MainWindow : Window
{
	/// &lt;summary&gt;
	/// Initializes a new instance of the MainWindow class.
	/// &lt;/summary&gt;
	public MainWindow()
	{
		InitializeComponent();
		Closing += (s, e) =&gt; ViewModelLocator.Cleanup();
	}
}</code></pre>
<figcaption>Fig05-061</figcaption>
</figure>
                <p>
                    I will use a default non-MVVM Light snippet. I simply type propdp and then I expand the snippet:
                </p>
<figure>
<pre><code class="csharp"> public int MyProperty
{
	get { return (int)GetValue(MyPropertyProperty); }
	set { SetValue(MyPropertyProperty, value); }
}

// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...
public static readonly DependencyProperty MyPropertyProperty =
	DependencyProperty.Register("MyProperty", typeof(int), typeof(ownerclass), new PropertyMetadata(0));</code></pre>
<figcaption>Fig05-062</figcaption>
</figure>
                <p>
                    We see the typical declaration of a DependencyProperty, including the type, the convenient getter
                    and setter for the value, and the registration itself, with the property's name declared as a
                    string, the property's type, the typeof the owner, which should be MainWindow, and the metadata
                    instance that declares some value, such as here the default value of the DependencyProperty.
                </p>
                <p>
                    This is quite complex, and I cannot go too deep into the details of the DependencyProperty System,
                    but I encourage those of you who are not familiar with this system to study a WPF or Silverlight
                    course.
                </p>
                <p>
                    Now let's declare a DependencyProperty using the MVVM Light snippet; it is called mvvmpropdp. If we
                    expand this snippet now, we see that there is one single difference:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="MyProperty" /&gt; dependency property's name.
/// &lt;/summary&gt;
public const string MyPropertyPropertyName = "MyProperty";

/// &lt;summary&gt;
/// Gets or sets the value of the &lt;see cref="MyProperty" /&gt;
/// property. This is a dependency property.
/// &lt;/summary&gt;
public int MyProperty
{
	get
	{
		return (int)GetValue(MyPropertyProperty);
	}
	set
	{
		SetValue(MyPropertyProperty, value);
	}
}

/// &lt;summary&gt;
/// Identifies the &lt;see cref="MyProperty" /&gt; dependency property.
/// &lt;/summary&gt;
public static readonly DependencyProperty MyPropertyProperty = DependencyProperty.Register(
	MyPropertyPropertyName,
	typeof(int),
	typeof(ownerclass),
	new UIPropertyMetadata(0));</code></pre>
<figcaption>Fig05-063</figcaption>
</figure>
                <p>
                    the property's name is declared as a constant, which is a much better practice. Notably, when an
                    external object is listening to the DependencyProperty for changes, it will need to know the name of
                    this property to analyze the change and verify that it is a correct property. Having this value
                    declared as a constant, is cleaner than the original version. Note that having a string-based id is
                    not a very clean situation anyway, but this is the basis of the DependencyProperty System and there
                    is not much that we can do about it.
                </p>
                <p>
                    Here is a recapitulation. First we have the mvvmpropdp, which we just saw and which declares a
                    dependency property in WPF, and there is also another snippet called mvvmpropa, which declares an
                    attached property in WPF.
                </p>
                <p>
                    Also, we have Silverlight versions of those two snippets, mvvmslpropdp, which you can use in
                    Silverlight, Windows Phone, and Windows 8, and of course there is also mvvmslpropa. The differences
                    to the built-in snippets are minor, but they can make the developer's life easier when you code a
                    lot.
                </p>
                <p>Also, they don't really have to do with MVVM directly. In fact, dependency properties are almost
                    never declared in ViewModels, but it is still a very common task for XAML developers to declare
                    dependency properties, and as such, these snippets can be useful.
                </p>
                <h3>Introduction and Demo of the Standard Project Template</h3>
                <p>Now let's talk about the Project Templates. Once you install the MVVM Light Toolkit, as shown
                    previously, you get a series of templates available in the File, New Project dialog. At this time,
                    the Project Templates are available for Visual Studio 2012 and Visual Studio 2013. For Visual Studio
                    2010, I do not provide Project Templates at this time. However, I am considering creating a VSIX
                    Installer for VS10 too. For now, if you use VS10, please use the NuGet method that I showed earlier
                    in this module.
                </p>
                <p>
                    The Project Templates are available for Silverlight 4, Silverlight 5, Windows Presentation
                    Foundation 3.5, 4.0, and 4.5, Windows Phone 7.1 and 8.0, and for Windows Store 8.0 and 8.1.
                </p>
                <p>
                    Note that depending on your development environment, you might see only some of these templates. For
                    example, Silverlight 4 is not supported in Visual Studio 2013, nor Windows Phone 7.1.
                </p>
                <p>
                    Let's see now what you get when you create a new MvvmLight application. For this demo, let's select
                    File, New, Project, and then on the Windows we will take a (WPF45) application. Let's click OK. Once
                    this application is created, let's run it:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-064.png"/>
                    <figcaption>Fig 05-064</figcaption>
                </figure>
                <p>
                    We see a new window with the text, "Welcome to MVVM Light". This is not earth-shattering, but let's
                    see what happens when we open the application in Blend.
                </p>
                <p>
                    Here, when we open the MainWindow, notice that the text is different. We already saw before the
                    power of design time data, and this is exactly what we witness here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-065.png"/>
                    <figcaption>Fig 05-065</figcaption>
                </figure>
                <p>
                    The application is architected in a way that triggers Blend to run some of the code. This, coupled
                    with the fact that we can know in the code if we are running in a Visual Designer, allows us to
                    tailor the data to allow the best visual design experience possible.
                </p>
                <p>
                    The most important point of a new MvvmLight application can be seen in the code. First, let's open
                    App.xaml, and here we see that the ViewModelLocator is defined in the global resource:
                </p>
<figure>
<pre><code class="xml">&lt;Application.Resources&gt;
	&lt;!--Global View Model Locator--&gt;
	&lt;vm:ViewModelLocator x:Key="Locator"
						 d:IsDataSource="True" /&gt;
&lt;/Application.Resources&gt;</code></pre>
<figcaption>Fig05-066</figcaption>
</figure>
                <p>
                    Then, in MainWindow.xaml, we see that the DataContext is set to the Main property of the
                    ViewModelLocator:
                </p>
<figure>
<pre><code class="csharp">DataContext="{Binding Main, Source={StaticResource Locator}}"&gt;</code></pre>
<figcaption>Fig05-067</figcaption>
</figure>
                <p>
                    Let's open the ViewModelLocator itself. Here, it is configuring the SimpleIoc with a DataService:
                </p>
<figure>
<pre><code class="csharp">public class ViewModelLocator
{
    static ViewModelLocator()
    {
        ServiceLocator.SetLocatorProvider(() =&gt; SimpleIoc.Default);

        if (ViewModelBase.IsInDesignModeStatic)
        {
            SimpleIoc.Default.Register&lt;IDataService, Design.DesignDataService&gt;();
        }
        else
        {
            SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
        }

        SimpleIoc.Default.Register&lt;MainViewModel&gt;();
    }</code></pre>
<figcaption>Fig05-068</figcaption>
</figure>
                <p>
                    Of course, this is just basic scaffolding and the DataService will be expanded or replaced in your
                    application, but this gives you a good starting point.
                </p>
                <p>
                    Let's take a look at the DataService, which is located in the Model folder:
                </p>
<figure>
<pre><code class="csharp">namespace MvvmLight1.Model
{
    public class DataService : IDataService
    {
        public void GetData(Action&lt;DataItem, Exception&gt; callback)
        {
            // Use this to connect to the actual data service

            var item = new DataItem("Welcome to MVVM Light");
            callback(item, null);
        }
    }
}</code></pre>
<figcaption>Fig05-069</figcaption>
</figure>
                <p>It is very simple and only creates a dummy DataItem and then returns it. This is where you will
                    connect to an actual data service, a database, a web service, etc. There is also a design time
                    implementation of the DesignDataService in the Design folder, and this is where the text that we saw
                    in Blend earlier is set:
                </p>
                <figure>
<pre><code class="csharp">var item = new DataItem("Welcome to MVVM Light [design]");
callback(item, null);</code></pre>
<figcaption>Fig05-070</figcaption>
</figure>
                <p>
                    Of course, in your application, you are going to do a lot of operations in the DataService, and some
                    of them will be asynchronous. Note that for now, I am not using the async and await keywords, mostly
                    for reasons of code compatibility, but it would be easy to modify the DataService to support these
                    keywords.
                </p>
                <p>
                    Finally, let's open the MainViewModel to look at the code. Here, we see the DataService being
                    injected inside the constructor and then we call it immediately:
                </p>
<figure>
<pre><code class="csharp">public class MainViewModel : ViewModelBase</code></pre>
<figcaption>Fig05-071</figcaption>
</figure>
                <p>
                    Here, too, in your production application, you will have some logic to handle user input and call
                    the service on demand, refresh the data, etc.
                </p>
                <p>
                    A few small details that are not critical, but interesting to note; here, in MainWindow.xaml.cs, we
                    call the Cleanup method on the ViewModelLocator when the MainWindow is closed:
                </p>
<figure>
<pre><code class="csharp">Closing += (s, e) =&gt; ViewModelLocator.Cleanup();</code></pre>
<figcaption>Fig05-072</figcaption>
</figure>
                <p>
                    This method is not doing anything at this point, but it would be a good place to put code to close
                    database connections, save the application states, etc.
                </p>
                <p>
                    Now let's open App.xaml.cs, and here we see that we Initialize the DispatcherHelper:
                </p>
                <figure>
<pre><code class="csharp">static App()
{
    DispatcherHelper.Initialize();
}</code></pre>
<figcaption>Fig05-073</figcaption>
</figure>
                <p>
                    The exact location of this line of code is different depending on the framework that you are using;
                    for example, Windows Phone, Silverlight, WPF, etc. But you can be assured that the DispatcherHelper
                    is initialized as soon as possible when the application starts, so this is one less thing to worry
                    about.
                </p>
                <p>
                    Using a Project Template to start a new MvvmLight Project is, of course, not compulsory, and the
                    NuGet option is quite popular. But if you want to get started fast and without having to worry about
                    the plumbing, File, New Project, MvvmLight is a great option.
                </p>
                <h3>The Windows 8.1 Project Template</h3>
                <p>For Windows Store 8.1, I tried a new concept for the Project Template and I added some meat, you
                    could say, to the original template in the form of additional files in the custom folder. This is a
                    little bit of an experiment and I am waiting for feedback from the community to know if it is
                    considered as a good idea or not.
                </p>
                <p>
                    When you create a Windows Store 8.1 application, here is what you get:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-074.png"/>
                    <figcaption>Fig 05-074</figcaption>
                </figure>
                <p>
                    Let's run the application in the Simulator first and see how it is built. The application starts
                    with the MainPage and a few elements. There is, here, a button that does navigation. I decided to
                    have a standard button in order to put the emphasis on the navigation service that it is using. If
                    you press the button, the application navigates to the second page, as expected.
                </p>
                <p>
                    Let's go back to the MainPage. Now you see that the label changed with the date of the last visit:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-075.png"/>
                    <figcaption>Fig 05-075</figcaption>
                </figure>
                <p>
                    This is done to demonstrate how you can save the state of a page, and you can find the corresponding
                    code in MainPage.xaml.cs. At the bottom, we notice a red area. This is a user control. The purpose
                    here is to show how you can handle the different page mode. For example, let's see what happens when
                    we move the Simulator to Portray mode. Here, we see that the User Control turned to green:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-076.png"/>
                    <figcaption>Fig 05-076</figcaption>
                </figure>
                <p>
                    Let's go back to Landscape mode. And now it is red again. Now I will place the page in Split mode.
                    At first nothing happens, but if we resize the slider here, after a stress hold, the page's layout
                    changes again. The User Control turns purple and its layout is different:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-077.png"/>
                    <figcaption>Fig 05-077</figcaption>
                </figure>
                <p>
                    The Navigation button goes from top-right to bottom-centered; also, the page's title is using a
                    smaller font now. Let's play the transition a few times to see what happens.
                </p>
                <p>
                    Most of the objects that make this happen are added here in the Common folder:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-078.png"/>
                    <figcaption>Fig 05-078</figcaption>
                </figure>
                <p>
                    The purpose is mostly educational, in order to show to MVVM Light users how certain operations are
                    done in Windows 8. We handle storing and restoring state for a page, navigation, showing dialogs,
                    handling Orientation and Split mode, etc.
                </p>
                <p>
                    Let's see how the Orientation and Split mode are handled. I am using a behavior to do this. Remember
                    that we already talked about behaviors earlier, when we learned about the EventToCommand component
                    of MVVM Light.
                </p>
                <p>
                    Here, we have the Behavior implementation for the User Control:
                </p>
<figure>
<pre><code class="csharp">    public class OrientationStateControlBehavior : DependencyObject, IBehavior
    {
        /// &lt;summary&gt;
        /// The &lt;see cref="LandscapeFlippedStateName" /&gt; dependency property's name.
        /// &lt;/summary&gt;
        public const string LandscapeFlippedStateNamePropertyName = "LandscapeFlippedStateName";

        /// &lt;summary&gt;
        /// The &lt;see cref="LandscapeStateName" /&gt; dependency property's name.
        /// &lt;/summary&gt;
        public const string LandscapeStateNamePropertyName = "LandscapeStateName";

        /// &lt;summary&gt;
        /// The &lt;see cref="PortraitFlippedStateName" /&gt; dependency property's name.
        /// &lt;/summary&gt;
        public const string PortraitFlippedStateNamePropertyName = "PortraitFlippedStateName";

        /// &lt;summary&gt;
        /// The &lt;see cref="PortraitStateName" /&gt; dependency property's name.
        /// &lt;/summary&gt;
        public const string PortraitStateNamePropertyName = "PortraitStateName";

        /// &lt;summary&gt;
        /// The &lt;see cref="SnapStateName" /&gt; dependency property's name.
        /// &lt;/summary&gt;
</code></pre>
<figcaption>Fig05-079</figcaption>
</figure>
                <p>
                    There are a few properties used to enter the name of the visual states defining the control's
                    appearance. Then we have the Attach method:
                </p>
<figure>
<pre><code class="csharp"> public virtual void Attach(DependencyObject associatedObject)
        {
            AssociatedObject = associatedObject;
            _associatedControl = AssociatedObject as UserControl;

            if (_associatedControl == null)
            {
                throw new InvalidOperationException(
                    "OrientationStateControlBehavior can only be attached to a UserControl.");
            }

            Messenger.Default.Register&lt;OrientationStateMessage&gt;(
                this,
                HandleOrientationMessage);
        }</code></pre>
<figcaption>Fig05-080</figcaption>
</figure>
                <p>
                    This method will be called automatically by the system when the page is loaded and the behavior is
                    attached. The key of the process here:
                </p>
<figure>
<pre><code class="csharp"> Messenger.Default.Register&lt;OrientationStateMessage&gt;(
    this,
    HandleOrientationMessage);</code></pre>
<figcaption>Fig05-081</figcaption>
</figure>

                <p>
                    is that the Behavior registers to the MVVM Light Messenger, for an OrientationStateMessage. When
                    this message is received, the HandleOrientation method is called. We use a VisualStateManager to go
                    to the correct state:
                </p>
<figure>
<pre><code class="csharp">case PageOrientations.Portrait:
    VisualStateManager.GoToState(control, PortraitStateName, true);
    SendMessage(PageOrientations.Portrait);
    break;</code></pre>
<figcaption>Fig05-082</figcaption>
</figure>
                <p>
                    This Behavior can be attached to a User Control. For a page we use a slightly different one, called
                    OrientationStateBehavior. Let's open this one. In fact, it is inheriting the one that we just saw:
                </p>
<figure>
<pre><code class="csharp">public class OrientationStateBehavior : OrientationStateControlBehavior</code></pre>
<figcaption>Fig05-083</figcaption>
</figure>
                <p>
                    The main difference is that this Behavior is an additional property, called SnapViewMaximumWidth:
                </p>
<figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// The &lt;see cref="SnapViewMaximumWidth" /&gt; dependency property's name.
/// &lt;/summary&gt;
public const string SnapViewMaximumWidthPropertyName = "SnapViewMaximumWidth";

/// &lt;summary&gt;
/// Identifies the &lt;see cref="SnapViewMaximumWidth" /&gt; dependency property.
/// &lt;/summary&gt;
public static readonly DependencyProperty SnapViewMaximumWidthProperty = DependencyProperty.Register(
    SnapViewMaximumWidthPropertyName,
    typeof(double),
    typeof(OrientationStateBehavior),
    new PropertyMetadata(500.0));</code></pre>
<figcaption>Fig05-084</figcaption>
</figure>
                <p>
                    This can be used to specify when the page should go from Landscape mode to Split mode.
                </p>
                <p>
                    Further below, this is where we attach to the OrientationChanged event and to the SizeChanged event
                    for the page:
                </p>
<figure>
<pre><code class="csharp">_associatedPage.SizeChanged += PageBaseSizeChanged;
DisplayInformation.GetForCurrentView().OrientationChanged += PageBaseOrientationChanged;</code></pre>
<figcaption>Fig05-085</figcaption>
</figure>
                <p>
                    Finally, here is where the Messenger is used to send the OrientationStateMessage:
                </p>
<figure>
<pre><code class="csharp">protected override void SendMessage(PageOrientations orientation)
{
    Messenger.Default.Send(new OrientationStateMessage(orientation));
}</code></pre>
<figcaption>Fig05-086</figcaption>
</figure>
                <p>
                    This will be received by the Behaviors attached to User Controls and they, in turn, will go to the
                    correct state. Let's open the second page in Blend and see how we can use this Behavior.
                </p>
                <p>
                    First, I will add a new User Control to the project:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-087.png"/>
                    <figcaption>Fig 05-087</figcaption>
                </figure>
                <p>Now I build the User Control with three columns, a big button on the right, three buttons in the
                    middle, and a blue rectangle on the left:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-088.png"/>
                    <figcaption>Fig 05-088</figcaption>
                </figure>
                <p>
                    Let's add the Behavior to the UserControl. In the Assets Library, I will select the
                    OrientationStateControlBehavior:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-089.png"/>
                    <figcaption>Fig 05-089</figcaption>
                </figure>
                <p> and drag it on the UserControl itself:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-090.png"/>
                    <figcaption>Fig 05-090</figcaption>
                </figure>
                <p>
                    On the right-hand side, notice the name of the visual state:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-091.png"/>
                    <figcaption>Fig 05-091</figcaption>
                </figure>
                <p>
                    Here, you could change these names if you want to, but here in the demo I'm going to leave them by
                    default. Now let's go and define the state. I have to do that in the States tab here:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-092.png"/>
                    <figcaption>Fig 05-092</figcaption>
                </figure>
                <p>
                    Let's add a StateGroup name, OrientationStates. And here, I will only handle two states, the
                    Landscape mode and the Snap mode:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-093.png"/>
                    <figcaption>Fig 05-093</figcaption>
                </figure>
                <p>
                    Now I am in recording mode; this is shown by the red border around the designer area:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-094.png"/>
                    <figcaption>Fig 05-094</figcaption>
                </figure>
                <p>
                    So here I can specify how the Snap mode is going to look like. For example, let's select this big
                    button, and I'm going to make it Invisible. I can also select Button #2 here and hide it as well.
                    And finally, let's take this blue rectangle here and turn it red:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-095.png"/>
                    <figcaption>Fig 05-095</figcaption>
                </figure>
                <p>
                    Now let's exit the state recording mode and go back to the page. After I build the application, I
                    can go to the Assets Library, and on the Project, I will see the UserControl that I just created:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-096.png"/>
                    <figcaption>Fig 05-096</figcaption>
                </figure>
                <p>
                    Let's add one to the page. When the page gets created, it already has an OrientationStateBehavior;
                    this is in the Project Template by default. Notice that this is the other behavior:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-097.png"/>
                    <figcaption>Fig 05-097</figcaption>
                </figure>
                <p>
                    the OrientationStateBehavior, in the contrary of the one we used in the UserControl, which is called
                    OrientationStateControlBehavior. And here on the right side, you can see, again, the Visual
                    StateNames:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-098.png"/>
                    <figcaption>Fig 05-098</figcaption>
                </figure>
                <p>
                    as well as a SnapViewMaximumWidth for the page, which is set to 500 pixels by default:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-099.png"/>
                    <figcaption>Fig 05-099</figcaption>
                </figure>
                <p>In the page, the states are already defined by the Project Template, so I don't need to redefine
                    them:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-100.png"/>
                    <figcaption>Fig 05-100</figcaption>
                </figure>
                <p>
                    Now let's go to Snap mode, and what I'm going to do is take this UserControl and move it down here
                    to this location:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-101.png"/>
                    <figcaption>Fig 05-101</figcaption>
                </figure>
                <p>
                    Let's run the code and navigate to the second page. If I resize the application in Snap mode, we
                    will see that after a certain stress hold, the application is going to toggle to Snap mode:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-102.png"/>
                    <figcaption>Fig 05-102</figcaption>
                </figure>
                <p>
                    as well as the UserControl here.
                </p>
                <h3>New View, New ViewModel and MVVMLOCATORPROPERTY Snippet</h3>
                <p>The last component that MVVM Light installs are the Item Templates. When you have an existing
                    project, like here a Windows Phone application:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-103.png"/>
                    <figcaption>Fig 05-103</figcaption>
                </figure>
                <p>
                    you can right-click the Project and select Add, New Item. In the dialog you will see a few MVVM
                    Light Item Templates. Unfortunately, there is a bug in the way that items are filtered by Visual
                    Studio, so you need to pay attention to the items that you add. Here, for Windows Phone, look for
                    the suffix:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-104.png"/>
                    <figcaption>Fig 05-104</figcaption>
                </figure>
                <p>
                    We can add a new View, a new ViewModel, and a new ViewModelLocator. In this case the application
                    already has a ViewModelLocator, so it doesn't really make sense to add a new one. Instead, let's add
                    an MvvmView and we can call that SettingsPage.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-105.png"/>
                    <figcaption>Fig 05-105</figcaption>
                </figure>
                <p>
                    This page has a few predefined attributes, notably the DataContext is set, by default, to the
                    MainViewModel:
                </p>
<figure>
<pre><code class="csharp">DataContext="{Binding Main, Source={StaticResource Locator}}"&gt;</code></pre>
<figcaption>Fig05-106</figcaption>
</figure>
                <p>
                    Let's change that to a new ViewModel called Settings that we will create in a moment. Let's add the
                    SettingsViewModel inside the ViewModel folder. Then I will select an MvvmViewModel and call that
                    SettingsViewModel. Let's add a new observable property, called DefaultEmailAddress:
                </p>
<figure>
<pre><code class="csharp">namespace MvvmLight3.ViewModel
{
    /// &lt;summary&gt;
    /// This class contains properties that a View can data bind to.
    /// &lt;para&gt;
    /// See http://www.galasoft.ch/mvvm
    /// &lt;/para&gt;
    /// &lt;/summary&gt;
    public class SettingsViewModel1 : ViewModelBase
    {
        /// &lt;summary&gt;
        /// The &lt;see cref="DefaultEmailAddress" /&gt; property's name.
        /// &lt;/summary&gt;
        public const string DefaultEmailAddressPropertyName = "DefaultEmailAddress";

        private string _defaultEmailAddress = "user@domain.com";

        /// &lt;summary&gt;
        /// Sets and gets the DefaultEmailAddress property.
        /// Changes to that property's value raise the PropertyChanged event.
        /// &lt;/summary&gt;
        public string DefaultEmailAddress
        {
            get
            {
                return _defaultEmailAddress;
            }

            set
            {
                Set(DefaultEmailAddressPropertyName, ref _defaultEmailAddress, value);
            }
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the SettingsViewModel1 class.
        /// &lt;/summary&gt;
        public SettingsViewModel1()
        {
        }
    }
}</code></pre>
<figcaption>Fig05-107</figcaption>
</figure>
                <p>
                    Then, inside the ViewModelLocator, I will add a property for this ViewModel. Let's open it. And for
                    this I can use a snippet that we didn't see yet, called mvvmlocatorproperty:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-108.png"/>
                    <figcaption>Fig 05-108</figcaption>
                </figure>

                <p>
                    Here we go. Let's replace a token, this is a SettingsViewModel, and the name for the property is
                    going to be Settings, just like we added in the SettingsPage a moment ago:
                </p>
                <figure>
<pre><code class="csharp">static ViewModelLocator()
{
    ServiceLocator.SetLocatorProvider(() => SimpleIoc.Default);
    SimpleIoc.Default.Register&lt;SettingsViewModel&gt;();
}</code></pre>
                    <figcaption>Fig05-109</figcaption>
                </figure>
                <p>
                    This snippet creates noncompilable code, because it adds a static constructor for the
                    ViewModelLocator, but in fact we have one already. This is done this way so the developer can simply
                    cut this line out:
                </p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;SettingsViewModel&gt;();</code></pre>
<figcaption>Fig05-110</figcaption>
</figure>
                <p>
                    then I'm going to remove the ViewModelLocator here, go to the actual constructor that we had before,
                    and here I can paste the line that I just cut:
                </p>
<figure>
<pre><code class="csharp">static ViewModelLocator()
{
	ServiceLocator.SetLocatorProvider(() =&gt; SimpleIoc.Default);

	if (ViewModelBase.IsInDesignModeStatic)
	{
		SimpleIoc.Default.Register&lt;IDataService, Design.DesignDataService&gt;();
	}
	else
	{
		SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
	}

	SimpleIoc.Default.Register&lt;SettingsViewModel1&gt;();
	SimpleIoc.Default.Register&lt;MainViewModel&gt;();

  }
</code></pre>
<figcaption>Fig05-111</figcaption>
</figure>
                <p>After I build the application and open the SettingsPage in Blend, we see that the DataContext is set
                    to the SettingsViewModel as expected:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-112.png"/>
                    <figcaption>Fig 05-112</figcaption>
                </figure>
                <p>
                    So, for example, I can add a TextBox to the page, and then if I take the DefaultEmailAddress
                    property and drag it:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-113.png"/>
                    <figcaption>Fig 05-113</figcaption>
                </figure>
                <p>
                    it's going to data bind the TextBox.Text property to this property in the ViewModel, and here we go,
                    we have the DefaultEmailAddress that we defined just before:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig05-114.png"/>
                    <figcaption>Fig 05-114</figcaption>
                </figure>
                <h3>Summary</h3>
                <p>In this module, we started by seeing how the MVVM Light Toolkit gets installed. There are two ways to
                    get access to the MVVM Light Libraries, either by using the NuGet Package Manager or by using an
                    Installer.
                </p>
                <p>
                    In the case of NuGet, you can choose between the libraries only, most suited when you are developing
                    a class library or when you have an application that is already in development. Or, you can select
                    the Full MVVM Light Package, which also installs a ViewModel, a ViewModelLocator, and adds some
                    markup to App.xaml in order to provide the basic plumbing for an MVVM application that is also
                    designer-friendly.
                </p>
                <p>
                    Then, we saw how the Full MVVM Light Toolkit can get installed using the VSIX Installer from within
                    Visual Studio, using the Extensions Gallery, or from the mvvmlight.codeplex website.
                </p>
                <p>
                    This led us to study the additional tools that get installed, in addition to the Components Library.
                    We started with the code snippets. These allow the developer to work faster by adding pieces of
                    boilerplate code and some tokens that can easily be replaced to create working code.
                </p>
                <p>
                    We talked about the inpc family of snippets, which add an observable property to a ViewModel, then
                    we saw the relay snippets, which add the RelayCommand with various options.
                </p>
                <p>
                    Finally, we saw a few more snippets less directly related to MVVM, but that the XAML developer will
                    find quite useful.
                </p>
                <p>
                    We finished the module by talking about the project and item templates. We saw how a typical
                    MvvmLight application created by one of those templates looks like. We also saw how the more complex
                    Windows 8.1 project template installs additional components that are useful to build decoupled
                    applications.
                </p>
                <p>
                    Finally, we took a quick look at the item templates for review in the ViewModel.
                </p>
                <p>
                    In the next and final module, we will see a lot of code examples and learn how MVVM Light can be
                    used in some specific situations. For example, we will talk about adding MVVM Light to a
                    plugin-based application, we will also see some practical usage for the Messenger and SimpleIoc, as
                    well as see how unit tests can be created for the ViewModel layer.
                </p>
            </div>
        </div>
    </div>
</div>
