<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Applied MVVM Part 1 – Hierarchies and Navigation</h2>
            </div>
            <div class="panel-body">
                <h2>Overview</h2>
                <p>
                    We will now start building out a few more fully functional use cases from start to finish. In doing so we will hit on a number of other
                    design considerations and things you will need to know how to tackle when using the MVVM pattern. We will start with a few concepts first
                    including:
                </p>
                <ul>
                    <li>Naming and Location of Components</li>
                    <li>Hierarchical MVVM/Navigation</li>
                    <li>MVVM App Building</li>
                </ul>
                <h2>Naming MVVM Components</h2>
                <p>
                    When it comes to naming components in software there are no correct names, only good or bad ones depending on who you talk to. What really
                    matters is having a pattern and using it consistently.
                </p>
                <p>Most often your View will be implemented as a UserControl that will be hosted or contained within some UI container or parent View.</p>
                <p>Some guidance when naming Views:</p>
                <p>
                    Views should generally be named with a suffix of View with their name indicating what they contain or something about the action or use case
                    that they support.
                </p>
                <p>
                    You might also have cases where you are constructing objects such as a Window, Dialog or Page and you want to name the View with those as a
                    suffix to indicate what kind of construct they are. This is absolutely fine.
                </p>
                <p>
                    One recommendation is that you should avoid naming something with a View suffix if it does not have a corresponding ViewModel. That way you
                    don’t have to dig into the internals of a View to figure out if it is part of a View/ViewModel pair.
                </p>
                <p>Some guidance when naming ViewModels:</p>
                <p>
                    If you are following the above guidance on View naming, then simply apply Model to the end of the View name to create the ViewModel name
                    (e.g. CustomerEditView/CustomerEditViewModel).
                </p>
                <p>If you have a View that’s name doesn't end in View, then append ViewModel to the end of the View name (e.g. MainWindow/MainWindowViewModel)
                </p>
                <p>
                    Model objects are usually just objects with properties to contain the data of the Model. These kind of objects are often called entities but
                    don’t let that term confuse you and make you think that they are necessarily associated with the Entity Framework in any way. Entity is just
                    a general term for a lightweight object that contains data and properties.
                </p>
                <p>
                    Name Model objects for the domain object that they represent. So your Model objects should have noun based names like Customer, Order,
                    Patient, Prescription etc.
                </p>
                <p>
                    Classes that are wrappers (e.g. OrderHistory composed of ProductName, OrderDate and Quantity which are all from different Models) allow you
                    to easily bind to from a Grid. Some people append ViewModel to the end of Wrapped Models but that should be avoided. Use some kind of entity
                    name for the object and keep it so ViewModel's always have a View they are associated with. To keep things clean and easy to understand
                    Wrapped Models should be kept in a different location to where the Models are defined – often side by side with the Views and ViewModels
                    they are servicing.
                </p>
                <h2>Locating MVVM Components</h2>
                <p>
                    When it comes to creating your MVVM components in your Solution structure there are no hard and fast rules here either. The two most common
                    approaches are to locate your View and ViewModel components either in folders by type or folders by feature. When using folder by type you
                    have subfolders by each type of construct one for Views and one for ViewModels. When using folder by feature you have Views and ViewModels
                    grouped into folders named for a feature area (e.g. Customers) or set of related use cases and the Views and ViewModels live side by side in
                    that common folder and namespace.
                </p>
                <p>
                    The problem with the folder by type approach for Views and ViewModels is that in a large complex app you could easily end up with dozens of
                    files in those single folders making it hard to locate the type you are looking for. On the other hand, using folder by feature there are
                    rarely more than half a dozen Views supporting any single feature area. This makes it a lot easier to find a particular View or ViewModel
                    type.
                </p>
                <p>
                    For your Model types and Client Services those types are often used across multiple features so using a folder by type for those typically
                    makes sense. In fact, in the majority of real applications out there the Model types were often in a separate library altogether because
                    they were objects produced either through data access calls to a database or service calls to a web service and putting them in a separate
                    class library makes it easier to share them with other parts of your architecture.
                </p>
                <h2>MVVM Hierarchies and Navigation</h2>
                <p>
                    One of the last concepts to discuss briefly before we dive into the code is hierarchical MVVM and Navigation. When building an MVVM app you
                    typically decompose complex screens of information into a set of Parent and Child Views where the Child Views are contained within the
                    Parent Views in Panels or ContainerControls and they form a hierarchy of Views themselves. When you do that not every piece of content that
                    you separate into its own XAML file necessarily needs to be its own View. If the chunk of content just provides the structure to render
                    something to the screen and does not support any input or manipulation by the user for that content it may not warrant defining a separate
                    ViewModel for it. However, if there is justification for having a ViewModel for a Child View then one way to structure things is to form a
                    ViewModel hierarchy that mimics the View hierarchy and use ViewModel-First construction with Data Templates as the way to setup that
                    hierarchy. We will implement this in the demos coming up shortly. Finally, if you have a hierarchy of Views and ViewModels the Parent
                    ViewModel can become a hub for communications so that each Child ViewModel can remain decoupled from the other Child ViewModels and from
                    their Parent as much as possible.
                </p>
                <h2>Demo Use Case Review</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-End</p>
                <p>
                    Now it's time to dive into a series of demos that will span the rest of this module and carry on into the next. For those demos we are going
                    to start with a set of end user use cases that form the requirements for what will be building out. Those use cases include:
                </p>
                <ul>
                    <li>The ability to List Customers so that we can take certain actions on a given Customer:</li>
                    <ul>
                        <li>Placing Orders for a Customer</li>
                        <li>Adding/Editing Customers</li>
                    </ul>
                    <li>Monitor Order Preparation:</li>
                    <ul>
                        <li>Queued</li>
                        <li>Prepared</li>
                        <li>Out for delivery</li>
                    </ul>
                </ul>
                <h2>Demo: Building Out an MVVM Hierarchy</h2>
                <p>
                    In this demo we are going to start building up our set of use cases from scratch starting from an essentially empty WPF application project.
                    We have already added the Zza.Data project which contains the DbContext that we are using for data access and the Model object definitions
                    for our Data Model. This is referenced already from our WPF project. We also have our Services Layer with our CustomerRepository and
                    OrderRepository that we have seen in previous demos. We also have our RelayCommand.cs class that we are using for our ICommand
                    implementation to delegate calls into our ViewModels when Commands fire. Finally add or modify the connection string in the App.config file
                    that points to our Zza Database.
                </p>
                <p>Firstly, we will define a set of Views and define the switching or navigation that can happen to navigate throughout the application as an
                    end user. To achieve this, we will create a series of feature folders.
                </p>
                <ul>
                    <li>Customers</li>
                    <li>Orders</li>
                    <li>OrderPrep</li>
                </ul>
                <p>Now we will add a View and ViewModel to each one of those feature folders where the Views are UserControls and the ViewModels are classes:
                </p>
                <ul>
                    <li>CustomerListView</li>
                    <li>CustomerListViewModel</li>
                    <li>OrderPrepView</li>
                    <li>OrderPrepViewModel</li>
                    <li>OrderView</li>
                    <li>OrderViewModel</li>
                </ul>
                <p>Next we will add a textbox to each View to differentiate between them before adding any actual functionality:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-01.png"/>
                    <figcaption>Fig 05-01</figcaption>
                </figure>
                <p>
                    Now we need somewhere to host these Views. A good place for that (since this is a simple app) is in the MainWindow View. We need a
                    ContainerControl that we can place our Views in and switch them in a navigation fashion. The perfect control for that is ContentControl.
                    What we will end up doing here is using its Content property and binding to a ViewModel reference. Similar to what we saw when we were
                    covering data templates in the third module here we are going to expose a CurrentViewModel property from this View's ViewModel (which
                    doesn't exist yet). By setting the CurrentViewModel property to an instance of a ViewModel and having a data template for it we can drive
                    the rendering of the View and its ViewModel.
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-02.png"/>
                    <figcaption>Fig 05-02</figcaption>
                </figure>
                <p>
                    Now we need to add data templates that match up to our Views and ViewModels. To define the data templates for each View we will need to
                    bring in their corresponding child namespaces:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-03.png"/>
                    <figcaption>Fig 05-03</figcaption>
                </figure>
                <p>
                    So we have a child namespace per sub folder and one for the root folder. Now we can define the DataTemplates in a ResourceDictionary for
                    this window. We will setup one DataTemplate per ViewModel mapping to its ViewType:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-04.png"/>
                    <figcaption>Fig 05-04</figcaption>
                </figure>
                <p>
                    Note how each DataTemplate maps a DataType (the ViewModel Type) to a corresponding View and the use of this DataTemplate will create this
                    View, set its DataContext to its ViewModel. So now anytime CurrentViewModel is set to instance of a CustomerListViewModel it will render out
                    a CustomerListView with the ViewModel hooked up.
                </p>
                <p>
                    So we just need a ViewModel that has a CurrentViewModel property and some logic and Commanding to switch the current reference of ViewModel
                    inside that property.
                </p>
                <p>Create a class called MainWindowViewModel. In MainWindow view we can use static hook-up in the XAML:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-05.png"/>
                    <figcaption>Fig 05-05</figcaption>
                </figure>
                <p>The above XAML just creates an instance of the ViewModel from XAML and use it to set the DataContext of that Window.</p>
                <p>
                    Now let's start fleshing out our MainWindowViewModel. The first property we know our ViewModel needs is a property called CurrentViewModel
                    which we will set to a type of object for now:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-06.png"/>
                    <figcaption>Fig 05-06</figcaption>
                </figure>
                <p>
                    To drive the navigation, the MainWindowViewModel is going to act as a Parent in a hierarchy of ViewModels where the Child ViewModels will be
                    managed by the parent ViewModel. We will declare an instance of each of the Child ViewModel types that we are going to be placing into that
                    CurrentViewModel property:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-07.png"/>
                    <figcaption>Fig 05-07</figcaption>
                </figure>
                <p>
                    We can see that just like the MainWindow ContentControl will act as a Container for the rendered Views our MainWindowViewModel can act as a
                    Container or Parent to the contained ViewModels. The next thing to consider is that we will be setting the CurrentViewModel property over
                    and over again as navigation occurs. Anytime that you are going to be setting a property that you are bound to after the initial XAML
                    parsing has happened you would need to support INotifyPropertyChanged. We could just implement INPC directly on MainWindowViewModel and then
                    later we would find we would need to do it on CustomerListViewModel, OrderViewModel and so on. The thing to recognise is that you pretty
                    much always need INPC support on your ViewModels. We also need to make sure that whatever type you make the CurrentViewModel property we are
                    able to put an instance of each of the child ViewModels into that property. Obviously using the object base class for all types of objects
                    in .Net will work but it is better to be a bit more specific.
                </p>
                <p>
                    So the combination of facts that each ViewModel will need to implement INPC and that we need some common base type for those ViewModels
                    leads us to creating something that encapsulates the INPC pattern, makes it so our ViewModels don’t have to be repetitive in declaring INPC
                    and makes it so our property definitions can be a little bit more trim as well.
                </p>
                <p>In our next demo we will create a base class to encapsulate that INPC implementation then have our ViewModels inherit from it.</p>
                <h2>Demo: Encapsulating INotifyPropertyChanged</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-End</p>
                <p>
                    So we need to create a base class to encapsulate the implementation of INPC for our ViewModels. To do that we are going to add a new class
                    to the project called BindableBase. The main idea behind BindableBase is to encapsulate the INotifyPropertyChanged implementation and
                    provide helper methods to the derived class so they can easily trigger the appropriate notifications. Firstly, this class needs to implement
                    INPC and then it needs to expose a way for the derived classes to trigger that PropertyChanged event at the appropriate time as well as
                    encapsulating the check to make sure that the value of any property that is being set is actually changing.
                </p>
                <p>
                    To do that we will define two methods on this class. One called SetProperty and one called OnPropertyChanged. The SetProperty method is
                    intended to be set from the set block of each property and encapsulates the check to see if the value actually changed and if so it sets the
                    member variable and triggers the PropertyChanged event.
                </p>
                <p>
                    The other method, OnPropertyChanged, is meant for places where maybe changing one property means you need to trigger an update on two
                    properties such as a computed property.
                </p>
                <p>
                    Now the above class is in place let’s see what it can do for us in our ViewModels. So back in our MainWindowViewModel we can change the way
                    we define our properties, we can’t do just auto implemented properties because we need to have a set block to trigger the change but we want
                    that to be as compact as possible.
                </p>
                <p>
                    We can use BindableBase as our property type and the property name is still CurrentViewModel. Make sure you set MainWindowViewModel to
                    inherit from BindableBase:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-08.png"/>
                    <figcaption>Fig 05-08</figcaption>
                </figure>
                <p>
                    The standard use of SetProperty is that you pass in the backing variable by ref into the SetProperty method on the base class. You will also
                    pass in the value that is currently being set for that property.
                </p>
                <p>
                    In the BindableBase implementation of SetProperty you can see how those members are coming in. The by ref member variable comes in in the
                    first argument, the value comes in second and the third one gets set with a nice feature of C# which is the CallerMemberName attribute. That
                    attribute makes it so it can automatically pick off the name of the thing that called in here – which in our case, since the SetProperty it
                    being called from the property is the property name itself – CurrentViewModel.
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-09.png"/>
                    <figcaption>Fig 05-09</figcaption>
                </figure>
                <p>
                    You can see it allows you to have a nice compact property definition with the get and set blocks but still do all the things that you need
                    to do for INPC like checking the value actually changed and firing the event. As a nice consequence it allows us to set the type of this
                    property to be BindableBase assuming that each of our ViewModels will inherit from that. So now let’s add BindableBase to each of our
                    ViewModels.
                </p>
                <h2>Demo: View Switching Navigation</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-End</p>
                <p>
                    So in this demo we will start doing some actual View switching using our CurrentViewModel property. We just need some way to drive the
                    setting of this property and we are going to make it so the end user can command going to the CustomerList or to the OrderPreparation View.
                    To get to the OrderView we are going to need to know what Customer that order is being placed for so that one is going to be driven in a
                    slightly different way.
                </p>
                <p>
                    So we need to setup some top level navigation to the CustomerListViewModel and the OrderPrepViewModel and the logic for that switching
                    should belong inside of this ViewModel. We will declare a method called OnNav that takes a string destination and then we will setup a
                    simple switch case to set the CurrentViewModel property to the appropriate child ViewModel when a certain identifier comes in:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-10.png"/>
                    <figcaption>Fig 05-10</figcaption>
                </figure>
                <p>
                    We need some way to call that when the user interacts with the View. We know from previous modules a good way to set that up is with
                    Commands. So let’s declare a Command that we can invoke the method with:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-11.png"/>
                    <figcaption>Fig 05-11</figcaption>
                </figure>
                <p>
                    Now we just need to construct that so we will add a Constructor to the class and set that Command pointing to the OnNav method:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-12.png"/>
                    <figcaption>Fig 05-12</figcaption>
                </figure>
                <p>
                    Now we just need to be able to trigger that Command from our View so keeping it simple we will use some Buttons. Add two rows to the Grid in
                    the MainWindow.xaml View:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-13.png"/>
                    <figcaption>Fig 05-13</figcaption>
                </figure>
                <p>
                    We add some Buttons to the top row, in the second row of the Grid we have our ContentControl as before. The Button on the left is used for
                    navigating to Customers whilst the Button on the right is used for navigating to Orders. You can see we are just pointing those at the
                    NavCommand property exposed by our ViewModel and using the CommandParameter to pass in the string to drive which navigation should take
                    place. With all that in place we should be able to go ahead and run the application. We can see the two Buttons and clicking on them takes
                    you to the relevant View:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-14.png"/>
                    <figcaption>Fig 05-14</figcaption>
                </figure>
                <p>
                    So we are getting top level navigation driven by the User, triggering Commands into the ViewModel, and the ViewModel encapsulates the
                    navigation logic. We are leveraging implicit DataTemplates to marry up the Views and ViewModels simply by setting a child ViewModel
                    property.
                </p>
                <h2>Demo: Data Loading into a ViewModel</h2>
                <p>Now that we have our basic top-level navigation working it is time to start fleshing out the CustomerListView. Replace the TextBox with a
                    DataGrid:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-15.png"/>
                    <figcaption>Fig 05-15</figcaption>
                </figure>
                <p>
                    We have added a DataGrid that is binding to Customers which means our ViewModel must now expose a Customers Collection. We have got a set of
                    two columns defined. The first one is bound to the FullName property of the Customer and will take up most of the row. The second one is a
                    templated column that contains a Button to place an order for a given Customer. That Button is going to pass the Customer by grabbing just
                    the current DataContext for the cell.
                </p>
                <p>
                    The Command itself will exist on our ViewModel. So to get to our ViewModel from inside of the row where the DataContext is not the ViewModel
                    we have to break out of the local DataContext using a RelativeSource binding. That let’s walk up the Visual Tree until we get to the
                    DataGrid at which point we are in the part of the XAML where our ViewModel is the current DataContext. Then we can set the path to the
                    DataContext of the DataGrid then dot down into PlaceOrderCommand which we will add to our ViewModel.
                </p>
                <p>In the CustomerListViewModel we will start by adding the Customers Collection:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-16.png"/>
                    <figcaption>Fig 05-16</figcaption>
                </figure>
                <p>
                    Now we need to be able to load Customers into that collection. For that we will need the repository. The ViewModel can new up an instance of
                    the repository as an initial crude attempt. In the next module we will cover dependency injection and how we can use that to pass the
                    repository in. For now, let’s just hard code it in:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-17.png"/>
                    <figcaption>Fig 05-17</figcaption>
                </figure>
                <p>
                    So we new up an instance of the Customers repository and hold it in a member variable of the interface type. Now we need to trigger where we
                    are going to load the Customers into the collection and because that is going to be an asynchronous load using the Loaded event of the View
                    is actually a good way to go. We just have to wire it up with the behavior as we did in the previous module. First let’s define the target
                    method that we want to invoke when the Loaded event fires:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-18.png"/>
                    <figcaption>Fig 05-18</figcaption>
                </figure>
                <p>
                    Here we can see that we are going to go out to our CustomerRepository and call GetCustomersAsync, await on the async method. When it returns
                    the value we are going to pass it into the constructor of ObservableCollection and populate our Customers property. Now we just need to call
                    that when the event fires.
                </p>
                <p>
                    The quickest way to get that hooked up is in Blend. Make sure the UserControl root element is selected in Objects and Timeline, go up to the
                    Assets tab, Behaviors and then double click CallMethodAction. That adds it as a child of the root element.
                </p>
                <p>
                    If you open the CustomerListView you will see that Blend has added two namespaces of the Blend SDK, it added the Triggers collection to the
                    Root element, and it added an EventTrigger which we want to change to the Loaded event and a CallMethodAction underneath that. We want to
                    set the TargetObject to just Binding to get to a reference of our ViewModel and the MethodName to LoadCustomers:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-19.png"/>
                    <figcaption>Fig 05-19</figcaption>
                </figure>
                <p>With that we should be able to run, click on the Customers Button and the Customers should be loaded asynchronously:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-20.png"/>
                    <figcaption>Fig 05-20</figcaption>
                </figure>
                <p>
                    Now we just have to get the Place Order Button wired up with a Command in the ViewModel. In the ViewModel define a Command property called
                    PlaceOrderCommand:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-21.png"/>
                    <figcaption>Fig 05-21</figcaption>
                </figure>
                <p>In the constructor for the ViewModel initialize the Command property and point it to a handling method:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-22.png"/>
                    <figcaption>Fig 05-22</figcaption>
                </figure>
                <p>Now add the handling method:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-23.png"/>
                    <figcaption>Fig 05-23</figcaption>
                </figure>
                <p>Next up we need to tackle navigating to an OrderView with that Customers context.</p>
                <h2>Demo: Navigation with Parameters</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-End</p>
                <p>
                    At this point we are all wired up to do top level navigation between the CustomerList and the OrderPrep area of the application. Now we need
                    to cause navigation from the Child ViewModel but that navigation is going to replace this ViewModels View as the Current View in the top
                    level navigation container. This means that the child ViewModel needs to be able to communicate up to its parent ViewModel which is the
                    MainWindowViewModel because that is where the navigation is being managed. There is a number of ways you can go about doing this but one
                    simple and straightforward way is to allow Child ViewModels to raise events that their Parent ViewModel can handle. Much like a human child
                    tries to get its parent to do something with events – sometimes polite and controlled, sometimes disastrous.
                </p>
                <p>
                    Basically we need to raise an event to our parent. To do that we can simply declare an event that is raised by this ViewModel. So we will
                    have an event that can pass a GUID (the CustomerId) that we want to start placing an Order for:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-24.png"/>
                    <figcaption>Fig 05-24</figcaption>
                </figure>
                <p>
                    Once we have the event defined we can raise it from inside of our PlaceOrder command handler passing the Customer Id of the Customer the
                    Command was raised for. In the MainWindowViewModel (the parent ViewModel) in the constructor subscribe to the PlaceOrderRequested event and
                    have some handling method that we will place here in the parent:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-25.png"/>
                    <figcaption>Fig 05-25</figcaption>
                </figure>
                <p>To implement the method, we will drop down to the bottom of the class and declare a method with the appropriate signature:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-26.png"/>
                    <figcaption>Fig 05-26</figcaption>
                </figure>
                <p>
                    Now before we go and set the CurrentViewModel to cause the navigation to occur to the OrderViewModel we need to pass some context. What we
                    can do is expose a property on the ViewModel that the parent can set as the context that drives the way it is going to behave when it is
                    presented. We take the Guid that was passed to us and just push it down to the child ViewModel:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-27.png"/>
                    <figcaption>Fig 05-27</figcaption>
                </figure>
                <p>In the OrderViewModel add an appropriate property:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-28.png"/>
                    <figcaption>Fig 05-28</figcaption>
                </figure>
                <p>In the OrderView add the following XAML:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-29.png"/>
                    <figcaption>Fig 05-29</figcaption>
                </figure>
                <p>
                    We have added a Horizontal StackPanel with two TextBlocks to present that we are placing an order for a given Customer Id. With that in
                    place we can go ahead and run the application, go to Customers, select a Customer, click Place Order and you will be taken to the Order page
                    showing the Customer Id:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-30.png"/>
                    <figcaption>Fig 05-30</figcaption>
                </figure>
                <h2>Demo: Add/Edit Navigation</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\5WPFMVVMInDepth\ZzaDesktop-End</p>
                <p>
                    So to finish up the navigation topics in this module we just need to add a new View and ViewModel to handle adding and editing. Since the
                    two will combine the same data entry fields we can combine them into a single View and ViewModel that has a mode to it that switches between
                    Add mode and Edit mode.
                </p>
                <p>
                    The first step is to define a new AddEditCustomerView and AddEditCustomerViewModel. Now we just need to put in place some way to navigate to
                    this View in Add mode or Edit mode. That will involve putting some Command buttons onto our CustomerListView:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-31.png"/>
                    <figcaption>Fig 05-31</figcaption>
                </figure>
                <p>
                    Our root Grid now has two rows, the top one will Autosize based on its content. We have added some content to that first row that is a
                    Button that invokes an AddCustomerCommand in our ViewModel. For our Edit we want to use the context of a given row within the Grid that is a
                    single Customer. We will just add another templated column similar to the PlaceOrderCommand:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-32.png"/>
                    <figcaption>Fig 05-32</figcaption>
                </figure>
                <p>
                    We use a RelativeSource Binding to get up to the DataGrid, uses the DataContext property of the DataGrid to get to the ViewModel, then dots
                    down to the EditCustomerCommand that we will be adding shortly.
                </p>
                <p>
                    Let’s add the EditCustomerCommand and AddCustomerCommand to the CustomerListViewModel. The pattern should be getting familiar now. First we
                    define the property on our ViewModel that exposes that Command:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-33.png"/>
                    <figcaption>Fig 05-33</figcaption>
                </figure>
                <p>
                    The AddCustomerCommand takes no arguments, the EditCustomerCommand takes the Customer object for the row the Button was clicked in. Next we
                    go to the constructor for our ViewModel and construct the command object, pointing it to a handling object:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-34.png"/>
                    <figcaption>Fig 05-34</figcaption>
                </figure>
                <p>Now stub out the handling methods:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-35.png"/>
                    <figcaption>Fig 05-35</figcaption>
                </figure>
                <p>
                    Now, just like PlaceOrder, we need to cause navigation to occur from down inside the child ViewModel so the pattern we established is to
                    raise an event to our Parent ViewModel. We will need two more events for that:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-36.png"/>
                    <figcaption>Fig 05-36</figcaption>
                </figure>
                <p>Each event will pass a Customer and now we just need to fire those from the Command handlers:</p>
                <p>
                    For AddCustomer we will just fire the event and pass in a new Customer object setting its Id to a new Guid. For EditCustomer we will just
                    fire the event passing in the Customer that was passed to us through the Command:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-37.png"/>
                    <figcaption>Fig 05-37</figcaption>
                </figure>
                <p>
                    So now we just need to go up to the Parent ViewModel level and do the event handling and navigation. So first we will need an instance of
                    the new child ViewModel that we are going to navigate to:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-38.png"/>
                    <figcaption>Fig 05-38</figcaption>
                </figure>
                <p>We can then subscribe to its events in the constructor of the ViewModel (as we did for PlaceOrder):</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-39.png"/>
                    <figcaption>Fig 05-39</figcaption>
                </figure>
                <p>Now we just need to implement the handling methods:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-40.png"/>
                    <figcaption>Fig 05-40</figcaption>
                </figure>
                <p>
                    Each takes in a Customer. What we expect to do here is set a flag on the AddEditViewModel to tell it whether it is in EditMode or not and
                    then we need some way to pass that Customer context down into the ViewModel. We are doing that with an imperative call to a method. Finally,
                    we set the CurrentViewModel property so that it becomes the current View in the root container.
                </p>
                <p>
                    Now for all of that to work we need to implement the property, the method, and make it so that AddEditViewModel is a BindableBase object
                    because that is the type of CurrentViewModel.
                </p>
                <p>So in AddEditCustomerViewModel add the following code:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-41.png"/>
                    <figcaption>Fig 05-41</figcaption>
                </figure>
                <p>
                    Firstly, we add the BindableBase base class, define our EditMode as a boolean property, define a SetCustomer method that takes in a Customer
                    and hold onto that Customer for the span of the editing context. Now if we were going to just bind to this Customer directly and let the
                    editing happen directly against it we could have just set a property. As we will see in the next module you may not always want to directly
                    edit your Model objects you may need to wrap them in some scenarios. In that case we can pass this Customer down in here and produce a
                    wrapped object. We will cover this in the next module.
                </p>
                <p>For now, we need to put something in the View so we can identify when it is on screen:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-42.png"/>
                    <figcaption>Fig 05-42</figcaption>
                </figure>
                <p>We then want to go to the MainWindow View and add another DataTemplate:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig05-43.png"/>
                    <figcaption>Fig 05-43</figcaption>
                </figure>
                <p>
                    This maps the AddEditCustomerViewModel to the AddEditCustomerView so it can be rendered out. With all that in place we can run the
                    application, go to Customers, click on the Edit Button for a selected Customer and see that we end up in the Add/Edit Customer View. Now
                    this might seem like a lot of ceremony: having to define a Command that gets despatched down into this ViewModel, the ViewModel raises an
                    event to the Parent ViewModel, the Parent ViewModel handles that event and causes the navigation. The point of all of this is to keep each
                    of these parts loosely coupled from the other ones. We have all the navigation logic centralized in the MainWindowViewModel, it just handles
                    its part of the interaction which is to manage the Customer List and events surrounding it.
                </p>
                <p>Now there are certainly other ways to go about this:</p>
                <ul>
                    <li>You could have a client service that manages navigation</li>
                    <li>You could use a framework like Prism and do region navigation</li>
                </ul>
                <p>However, this approach is simple and straightforward and it only takes moments to stub each navigation out.</p>
                <p>
                    In the next module we will finish fleshing out the AddEditCustomerView and in the process of doing so we will touch on a number of other
                    concepts including:
                </p>
                <ul>
                    <li>Wrapping model objects</li>
                    <li>Using the Visual Studio Designer to scaffold out data entry views</li>
                    <li>Doing validation on your editable objects</li>
                    <li>Doing dependency injection for your ViewModels</li>
                </ul>
                <h2>Summary</h2>
                <p>We saw a number of things:</p>
                <ul>
                    <li>Naming and location of components is important for maintainability</li>
                    <li>Hierarchical MVVM mirrors the way we normally compose complex screens</li>
                    <li>Building out an MVVM app is a progressive sequence of defining Views, ViewModels, navigation and communications to satisfy the
                        requirements
                    </li>
                </ul>
            </div>
        </div>
    </div>
</div>
<script src="bundle.js"></script>

