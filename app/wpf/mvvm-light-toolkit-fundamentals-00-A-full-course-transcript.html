<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Course Contents</h2>
            </div>
            <div class="panel-body">
                Introduction

                Hello and welcome to this course. My name is Laurent Bugnion, and I'm going to talk to you about the
                MVVM Light Toolkit. MVVM Light is an open-source toolkit, a suite of components which will help you to
                develop decoupled applications according to the Model-View-ViewModel Pattern. So Toolkit is available
                for all XAML-based frameworks; for example, Windows Presentation Foundation, Silverlight, Windows Phone,
                and Windows RT. The MVVM Pattern is very popular for XAML developers. For some of you, it is a very
                well-known pattern, but for others it is quite new, and this is why we are going to start with an
                introduction to MVVM. First, we are going to build a simple application and we are not going to use the
                Model-View-ViewModel Pattern here, but we are going to use a classic architecture and some events. We
                are going to see some of the disadvantages of this approach. And finally, we will have a small theory
                part about understanding MVVM, understanding which layers are playing together, and how they
                communicate. In the next module, we are going to refactor this application to a Model-View-ViewModel
                application, and this will help us to understand how the basic components of MVVM work and how they can
                be composed together to create a more maintainable and more testable application.

                Showing the Data Service Output

                Let's start the demo with an application that we are going to build without MVVM. And this is going to
                be a Windows Phone 8 Application connecting to a data service running on the web. Now this data service
                is delivering data in the form of JSON, and we are going to have one big object with a data property,
                which is an array of another type of object here with a unique id, a first_name, a last_name, a picture,
                a location, a message, etc. Now we are going to name this object here, the friend, and this is going to
                be the list of friends.

                Building the Model

                In Visual Studio, I created a Windows Phone 8 Application. This is an absolutely standard application, I
                just added a Model folder and a DetailsPage, to which we will navigate later to see the details of the
                friend. Inside the Model folder I have a Constants file, this is shared with the web service. And here
                I'm going to add an object, which we are going to use for the deserialization of the JSON. Let's call
                that object, ListOfFriends. I'm going to make that class public, and then I'm going to add some content.
                Here we are. We have one property called Data, which maps to the JsonProperty("data") with a small â€˜d',
                and this is a JsonProperty, so I'm going to use Json.NET to deserialize this. In order to use Json.NET,
                I will use NuGet. So let's go and look for Json.NET in the online NuGet package source. Here we are. And
                then I'm going to select here Json.NET Install. And now this is added. So I can use here the
                JsonPropertyAttribute. Now I need a friend class. So let's go into the Model, Add, New Class. I'm going
                to call that Friend, and let's make this public. The Friend class is very simple, it has a few
                JsonProperty's; the Id, the FirstName, the LastName, and an Update method that we are going to use later
                if we modify the Friend.

                Building the Client Data Service

                Then I'm going to add here an interface. And I'm going to call that, IFriendsService. And this is what I
                will use to connect to the data service, this is the definition of the service. I'm going to have two
                methods; one method Refresh, which is returning an IEnumerable of Friend, and then the other method,
                Save, which is going to take a modified Friend and then it's going to return a string, which is going to
                be the id of the Friend. If the Friend was a new Friend on the service, it's going to be the new id.
                Note that those two methods are returning Tasks of, which means that they are await table, so we are
                going to use a new await and async mechanism here to call Refresh and Save. Now I want to implement this
                interface, so I'm going to add a New Class, call that FriendsService. And then I'm going to make this
                public and implement IFriendsService. (Typing) Here we go. Now the first thing I'm going to add is a
                UrlBase; this is a base URL of the web service. I have a few parameters that I need to fill. And then
                here I have the Refresh method, so let's implement this. (Typing) And here the Refresh method is going
                to use an HttpClient. Now for those of you familiar with Windows 8, you may have already seen this
                class, HttpClient, but maybe you know that in Windows Phone we don't have HttpClient yet. So I'm going
                to use here something which is pretty new. Let's go to Manage NuGet Packages. And here I'm going to
                select Include Prerelease, and select here HttpClient. This is a new library released by Microsoft,
                which allows you to use the same HttpClient than in Windows 8, but to use that in Windows Phone as well.
                I'm going to install that. Now if you prefer to use the classic web client, of course you can do that as
                well. This is just to make it a little bit easier later to share code with Windows 8. Here we go.
                Everything was installed, and now I can use here the HttpClient. And what I'm going to do here is create
                a new HttpClient, create the uri with a few Constants, this is a Get, and then I'm going to await
                GetStringAsync, which is going to return to me the json. Because I have await, I need to make this
                method async, and finally I'm going to Deserialize the result here in the ListOfFriends and return the
                list of actual friend objects to the caller. I allotted to Save. What I'm going to do is also build an
                HttpClient. I'm going to build the uri, this time with Save. I'm going to take the updatedFriend and
                serialize it in json. And then, I'm going to build a StringContent with
                MediaTypeHeaderValue("application/json"), and then I'm going to post this JSON foul to this uri. Again,
                this is an awaitable method, so I need to make this method async. Finally I'm going to read the result,
                which as I'll remind you is the id of the Friend, and I'm going to return that.

                Creating the UI of the MainPage

                Now I'm ready to do some UI. So let's go into the XAML. And here, inside my page, I'm going to add to
                the ContentPanel, a LongListSelector, this is the list control, here we go, and I name that List. Now I
                also prepared a Refresh button, so let's go and add here, a Click event. (Typing) And then in the code
                behind, I'm going to add some code here. The first thing I'm going to do is create a new FriendsService.
                Then I'm going to call Refresh, which is an await table method, so I need to make this async. And then
                I'm going to assign the ListOfFriends to the ItemsSource property of the LongListSelector. Now the
                LongListSelector needs a DataTemplate, so here I name that FriendTemplate, and for this DataTemplate I'm
                going to keep things simple. I just created here two TextBlocks; the first one bound to FirstName and
                the second one bound to LastName. Now notice that I had to type this by hand, so I don't have any Visual
                help, any Visual Designer, and this is what we are going to improve later when we have the design time
                data.

                Navigation and DetailsPage

                Now we want to navigate to the DetailsPage when a Friend is Tapped. So the first thing I will do is add
                here a Tap event to the StackPanel. And then inside the Event Handler, I'm going to get the element that
                was Tapped, I'm going to get DataContext, which in the XAML-based framework is set to the element, which
                is currently represented by the item control. So now, okay, it is a Friend. And then I'm going to Save
                this Friend somewhere. But here in this application, this is not easy, because I don't have really an
                object which is persistent, I only have pages. And in order to Save the Friend, I'm going to use here
                the application, which is a global object. Now it's not super clean, but this will do for this very
                simple non-MVVM application. And later we will see how we can clean this up. Let's add the
                SelectedFriend to the application. It's a static property, so again it is not very clean. And then, I'm
                going to call the NavigationService in order to Navigate to the DetailsPage. Now within the DetailsPage
                I'm going to retrieve this object, and I'm going to do that inside the OnNavigatedTo method. Here we
                are. And then inside OnNavigatedTo, what I will do is check if I have a SelectedFriend. And if, yes, I'm
                going to set TextProperty of FirstNameTextBox and LastNameTextBox, and I also have a Preview, which is
                just a small UI, in order to see what the DataTemplate is going to look like. Now that I have this, I'm
                going to do one more thing to DetailsPage; I'm going to worry about what happens when the user is
                modifying the TextBoxes. So here I have the FirstNameTextBox and LastNameTextBox, and here again, I need
                to use some Event Handler, so I'm going to use here the TextChanged Event Handler and call that
                FirstNameTextChanged. Let's create this Event Handler. And then for the other one, I'm going to have
                here, of course, LastNameTextChanged. Here we go. Again, create the Event Handler. And now inside the
                Event Handler what I'm going to do is, again, get this global Friend and set the FirstName to the Text
                property of the TextBox. And I'm going to do the same for the LastName. So again, here I'm using some
                global object, which is not super clean, but right now in this event-based application, this is what we
                have. (Typing)

                Saving the Data Object, Testing

                Finally, I'm going to have a Save button, here we are, I prepared it earlier. And here, again, I'm going
                to add a Click event, SaveClick, and inside the code behind, I'm going to call the data service and I'm
                going to call the Save method with the SelectedFriend. And again, this is an awaitable operation, so I
                need to add async on this method. And in case of Errors, I'm going to use here the MessageBox to Show
                the message. So here we are, our application is complete, and now I'm going to test that. So I'm going
                to run the code inside the Emulator, I'm going to refresh my list, I'm going to tap here on the first
                friend, I can Edit the name, for example ttt, and then I can save here this friend. And then if I go
                back, I see that the friend has been saved; and if I refresh, we see that the name remains the same. So,
                the application has actually saved the changes to the web service. (Typing)

                Summarizing the Issues of Non-MVVM

                This small application works fine, but it has quite a few issues that we want to correct using the
                Model-View-ViewModel Pattern. Notably, we have quite a lot of code behind. Now code behind is not always
                bad in an application, and in fact, sometimes you just need some code behind; for example if you want to
                start some animations, coordinate them together, show some messages to the user, etc. But here we have
                really too much code behind, and we are using a lot of Event Handlers. Those Event Handlers are going to
                tightly couple the XAML to the application. For example, if we open MainPage.xaml, we see that have here
                the Tapped Event Handler, called FriendTap, and this is going to complicate our life because we cannot
                move this DataTemplate to a resource dictionary. Resource dictionaries have great advantages; for
                example, they allow an integrator, or a designer, to work on the UI of the application while a developer
                is working on the pages. They also allow you to structure your XAML resources in a very neat manner, but
                here we cannot move this DataTemplate out of the page's XAML, because otherwise the compilation is going
                to fail when the compiler doesn't find the FriendTap Event Handler. Another issue is a lack of design
                time data. If I go in Expression Blend and open the MainPage, I can find the list, which is a
                LongListSelector. But notice that I don't have any data appearing. Of course this is normal because
                Blend is not going to execute any code, but we can treat Expression Blend in creating design timed data
                and giving this some visual elements that we can visually design and edit into Blend. So when we
                refactor the application to MVVM in the next module, we are going to add the design time data service,
                which is going to help us doing some visual design in Blend. The fewer the problems in the code, we have
                an App.xaml.cs. This static property, which is part of the global application object, this is not very
                elegant and we would like to find a way to store this SelectedFriend somewhere else in a more modular
                manner. Finally, this application would be very difficult to unit test. Notably because we have a lot of
                code into pages, so we would have to create those pages inside the unit test. We also have some code
                inside the global application, so again we would have to create that object, which is really difficult
                in a unit test. We have all of the Event Handlers, which are private methods, so of course they cannot
                be executed from a unit test. All those issues make the application very hard to test, very hard to
                maintain, and very hard to extend with additional features. Let's summarize the issues that we just saw.
                Code behind is difficult to maintain and to extend. We have some coupling because we are using a lot of
                Event Handlers from the XAML inside the code behind, and that makes modifying the XAML very difficult.
                Because we have a lot of code in the code behind, we need the developer every time that we want to make
                small changes to the UI. We don't have any design time data, which makes editing the application in
                Expression Blend or in the Visual Studio Designer extremely difficult. And finally, the application is
                very hard, or maybe even impossible, to unit test.

                Theory: Understanding the MVVM Pattern (1)

                Let's talk now about the Model-View-ViewModel Pattern and understand how it is working. The MVVM Pattern
                is a variation of the very well-known MVC Pattern; the Model-View-Controller Pattern.
                Model-View-Controller is quite an old pattern, it was developed around 1984, and it is very, very widely
                used, especially in web-based frameworks; for example ASP.NET MVC or the Ruby on Rails framework. Here
                we have a Model, which is where the data comes from; it could be a database, it could be web services,
                etc. We have the View, which is what the user is seeing and actuating. And we have a Controller, which
                is coordinating all the actions. It is in charge of refreshing the Model, it is in charge of displaying
                data in the View, and it is in charge of reacting to events from the View in order to refresh the Model
                or to save a data object, for example. MVC is very widely used, but when you work with XAML, there is
                another pattern which is even better, especially because of the DataBinding system. A few years ago,
                Malcolm Fuller came up with the idea of the Presentation Model Pattern. So here we have a pattern which
                is quite similar to MVC, we still have the Model and the View, but instead of having a Controller
                object, what we have is a series of smaller Presentation Models, or ViewModels. And in fact, what we
                typically do is that we have one ViewModel per View. We will see that there are some exceptions to this
                rule, but in general this is what we tried to do. The View is interacting directly with the ViewModel,
                through a two-way interaction system. For the most part, this two-way interaction system is what we call
                DataBinding in XAML. So here, we have a system which allows us to bind properties from an UI element to
                a property of an object, in that case a ViewModel, and we can do that directly in the XAML markup
                without having to use some code. And of course because we do that in the XAML markup directly, this is
                very tool-friendly, which is why we can use a Visual Designer to create those DataBindings, like we will
                see later when we refactor the application.

                Theory: Understanding the MVVM Pattern (2)

                Let's take a closer look at the layers in a typical Model-View-ViewModel application. Between the
                ViewModel and the Model, the interaction is very classy. We have methods called from the ViewModel to
                the Model, we have events from the Model to the ViewModel, and maybe other interactions, but this
                remains quite classy. Between the View and the ViewModel, I already mentioned that we have DataBindings,
                but very often we also have DataBindings going between the View and the Model directly, especially if
                the data objects are implementing INotifyPropertyChanged, which is not very complicated to do and which
                presents us from having to wrap every data object in order to make it observable. The View can also
                actuate methods on the ViewModel, and for this we are going to use something called Commands, where
                we'll see an example when we refactor the application to MVVM. And of course we will gain deeper
                understanding of commands later in this course. Finally, from the ViewModel to the View, sometimes
                DataBindings are not so efficient. DataBindings are great to update properties on the View; for example
                the text, the value of the checkbox, etc. But sometimes you need something a little bit more complex;
                for example when you have to coordinate animations or when you have to display a dialog to the user and
                get his feedback. For example, using some View Services, which we'll see a little bit later, or some
                kind of event bus sending messages. An application very rarely has just one View and one ViewModel. So
                usually we have multiple Views, multiple ViewModels, and interactions between them. And here too, we can
                use messages, services, or maybe even Messages + callbacks, which we'll talk about later in this course.
                Let's take an even closer look at the ViewModel -> View Communication. From the ViewModel, it is of
                course possible to call a MessageBox directly, but this is probably not a very good idea because a
                MessageBox is a View element, which is going to be actuated directly from the ViewModel. This is going
                to cause issues, especially when we do unit tests, because a unit test cannot verify that the MessageBox
                has been displayed, and it cannot dismiss a MessageBox. Other operations are very difficult, or maybe
                even impossible to execute directly from the ViewModel; for example, Animations or Navigation between
                pages, which is why we typically don't do this.

                Theory: Understanding the MVVM Pattern (3)

                Instead, we have multiple abstracted ways to interact from the ViewModel to the View. One of these ways
                is using something called a Behavior. A Behavior is a small piece of code behind, which is encapsulated
                and reusable in multiple pages or even multiple applications. So we will place a Behavior on the View,
                and from the ViewModel, we are going to interact by setting a property and using a DataBinding between
                the Behavior and this property. So here, again, we have a very decoupled and flexible interaction, where
                we can modify the UI, change the Behaviors, without having to modify the ViewModel. Another way to
                interact from the ViewModel to the View is to use something called View Services. Here we are going to
                declare an abstraction, an interface, which defines which methods can be used. For example,
                IDialogService will have some methods, such as ShowMessage, ShowError, etc. This interface is going to
                be injected inside the ViewModel. This is a technique which is very popular nowadays, called Dependency
                Injection, and we will talk about that in a moment. Then we will have a class implement a DialogService,
                and this class is going to interact with the page directly. Another such example is INavigationService,
                which will have methods like GoBack and NavigateTo and HereTo. We will have an object implementing this
                and acting on the View directly to perform the navigation. View Services are very convenient when you
                want to unit test your ViewModel. Because in that case, we can simply disconnect the DialogService, and
                instead we are going to provide custom implementation of the DialogService, which we call the Mock or a
                Stub. In that case, let's call that MockDialogService. And we will let the ViewModel use this well-known
                implementation of the DialogService during the Unit Test. In summary, we can see that code behind is not
                always bad, sometimes it is absolutely necessary in an application, but it can complicate things. So
                Model-View-ViewModel Pattern is a variation of the Model-View-Controller Pattern. The goal is to create
                an application, which has less coupling, especially between the View and the Model. This will make the
                application easier to maintain, easier to test, and it will also allow us to create some design time
                data in order to work in a more comfortable manner in Blend or in the Visual Studio Designer. In the
                next module, we will take the same application and refactor it to MVVM, which will allow us to
                understand the different components and their interaction, and we are also going to add some design time
                data, and finally, create a unit test for this simple application.

                Refactoring the App to MVVM

                Introduction

                In the previous module, we built a Windows Phone Application without using the Model-View-ViewModel
                Pattern. We saw some of the disadvantages of this tightly coupled approach using quite a lot of events
                and code behind. All those principles apply to all XAML-based frameworks, not just Windows Phone Apps.
                And similarly, what we will do in this module applies to all XAML-based frameworks as well. In this
                module, we will refactor the application to use a Model-View-ViewModel Pattern. This is going to solve
                the disadvantages that we saw in the previous module. First of all, we will start by making the model,
                the Friend object, observable, so that we can apply DataBindings directly to those properties. We are
                going to create a ViewModel for the main View, and we are going to create some View services that the
                ViewModel can call in an abstracting manner, in order to execute operations on the View, such as showing
                dialogs or doing some navigation. Then we will bind the ViewModel to the View in order to create a
                One-to-One relationship between those two items. We will add some design time data and that will give us
                the opportunity to use Blend to do some visual design. Finally, we will add a unit test to your
                application and we will see how we can mock the services in order to simulate test conditions.

                Refactor the Model Object

                Let's start the refactoring with a Friend class inside the Model folder. In order to make this class
                observable, we wanted to implement the INotifyPropertyChanged interface. This interface is probably the
                most important when it comes to data binding. It's going to allow the data bindings to be updated
                whenever a property changes on the Model object. To implement this interface, we need just one event,
                the PropertyChanged event. But in addition, we add a Utility method, RaisePropertyChanged, which is
                going to raise the PropertyChanged event if necessary, meaning if somebody subscribed to this event, for
                example a XAML DataBinding. Now we can modify the properties which are going to be observable. So let's
                remove here FirstName and LastName, and instead we are going to add some observable properties, the
                FirstName property, which is going to raise the PropertyChanged event if necessary. And we do the same
                for LastName. So now this Friend class is observable. From a XAML standpoint, we can data bind to those
                observable properties, and the data bindings are going to be updated whenever those properties change.

                MainViewModel Part 1: Properties

                Then we are going to add a new class, and this is going to be the ViewModel. So let's add, first, a New
                Folder. And inside this folder, I add a new class, which I name MainViewModel. Now just like there is a
                MainPage, we will have a MainViewModel. If we had a SettingsPage, we would have a SettingsViewModel,
                etc. There is normally a One-to-One correspondence between the pages and the ViewModel, but this rule
                has quite a lot of exceptions, like we will see in the rest of the course when we do some more advanced
                topics. This MainViewModel, just like before, is going to implement INotifyPropertyChanged, because
                we're also going to have some DataBindings to that. So let's add the same code as before. And here we
                see something which is quite frequent in MVVM Applications. There is quite a lot of repetition inside
                those applications. We have to implement INotifyPropertyChanged quite often, we have to declare
                observable properties quite often, and eventually it would be nice to have something which breaks the
                monotony of MVVM, like, for example, the MVVM Light Toolkit is doing. Let's add a collection to hold all
                the friends, and for this we are going to use an ObservableCollection of Friends. In this small example,
                I'm using the Friend, which is the data object, model object, directly inside the MainViewModel. And I
                made this Friends class observable, which is okay because it's going to make our life quite a lot
                easier. But it's very possible in more complex application that we want to wrap this Friend data object
                inside something else, called, for example, the FriendViewModel. Then I'm going to add the constructor
                for this class, and notice that I inject an IFriendsService, which is, if you remember, the abstraction
                of the FriendService inside the MainViewModel constructor. And I am going to save here, this
                _dataService, as a field of type IFriendsService. So from the standpoint of this constructor, we don't
                know how the FriendService is implemented, but we know that we can use it because the methods of this
                _dataService are known through the IFriendsService abstraction. Another property I want to add to the
                MainViewModel is a SelectedFriend. And here, just like before in the Friend model object, I'm going to
                raise the PropertyChanged event whenever the SelectedFriend changes, which is going to force all the
                DataBindings that are using this SelectedFriend to update themselves and to update the user interface.

                MainViewModel Part 2: Commands and Services

                At this point, I will need to actuate some methods on the ViewModel from the View. And for this we are
                going to use something called Commands. Now don't fret at this point; we are not going to explain how
                commands are working in details right now, but we are going to have a dedicated section a little bit
                later in this course. For the moment, it is enough to know that the command can be executed and that it
                can receive a parameter, which can be of any type. Now in order to use commands more easily, I'm going
                to add a small Helper class, (Typing) and this is something called RelayCommand. This is a class which
                is directly taken from MVVM Light. And I know I said I didn't want to use some Helper classes here, but
                this is the only exception that I'm doing because RelayCommand is going to make our life so much easier,
                even in this small application. So now that I have RelayCommand added to the application, I can add a
                RefreshCommand of type RelayCommand. And remember that this is going to be executed. So when the
                RefreshCommand is actuated, this lambda expression is going to be called, and the Refresh method, which
                is not declared yet, we are going to do that right now, this Refresh method is going to be executed.
                Let's add the implementation of the Refresh method, and here we go that essentially we do what we did
                before in the RefreshClick event. We are calling the Refresh method on the _dataService, which is await
                table, which is why the Refresh method is async, and then, with all those Friends, we are going to add
                them to the ObservableCollection that we had earlier inside the MainViewModel as a property. Another
                thing we need to do is save the modified Friend. So for this I'm going to use the SaveCommand, and this
                time the SaveCommand is taking a parameter of type Friend. And here we see the declaration. I'm going to
                have my RelayCommand, which is going to take, again, an asynchronous lambda as parameter for the Execute
                method, and then here I have the parameter, which is the friend. What the SaveCommand has to do is
                essentially the same thing as the SaveClick Event Handler was doing earlier inside the DetailsPage. So
                let's go and copy that block of code, and we can take here the whole SaveClick Event Handler content,
                I'm going to cut that out, and then I'm going to paste this inside the SaveCommand instead. Of course
                there are a few things that we need to change. Notably, we are not going to use the SelectedFriend,
                which is a static property inside the global application object. Instead what the service has to save is
                the friend which has passed this parameter. So we are more decoupled, we don't use a global object
                anymore. Let's replace that code here. Same thing here, with App.SelectedFriend, we are going to set the
                id on the friend that has passed this parameter. In order to add a little bit more abstraction, we are
                going to use the _dataService that was injected inside the constructor, instead of using the actual
                Runtime Friend service. This way, the MainViewModel doesn't have to know where the _dataService comes
                from; it is just going to use whatever implementation is passed to the MainViewModel constructor.
                Another thing, which is not very elegant, is using a MessageBox within a ViewModel. Those MessageBoxes
                are going to complicate the unit tests quite a lot, because a unit test cannot react to a MessageBox; it
                doesn't know how to verify that the MessageBox has been displayed or it doesn't know how to dismiss a
                MessageBox. So instead, we are going to remove those two lines of code and we are going to use an
                abstraction of a dialogService, which we are going to call the IDialogService. Let's go and add the
                corresponding interface inside the Helpers folder. And this interface is going to be very simple; it's
                going to have here a ShowMessage method taking a message of type string. The MainViewModel doesn't know
                how this interface is implemented, and in fact, it shouldn't have to know, there should be no dependency
                from the ViewModel to the View. But it knows that somewhere inside the application there is an object,
                which implements a method called ShowMessage. So we can use that abstraction inside the MainViewModel.
                We are going to inject the dialogService inside the ViewModel constructor, we are going to save this as
                a field, and then we are going to use that inside the application at this location, and again, inside
                the catch a little bit lower. Let's here name this exception, so that we can use the Message inside the
                _dialogService. Then last, but not least, we have another command, which is going to be used to do the
                navigation to the DetailsPage, and we are going to call that the ShowDetailsCommand. Let's add this
                command. This command is also taking a friend and we are going to set the SelectedFriend property, which
                we added earlier inside the ViewModel. Remember that the SelectedFriend property is an observable
                property, so the PropertyChanged event is going to be raised and all the bindings are going to be
                updated automatically. But in addition, we want to do some navigation to the DetailsPage. So again, the
                MainViewModel shouldn't know how the navigation is done, so that we have a clean abstraction. And again,
                we are going to use the same mechanism, we are going to go to the Helpers folder, add an interface
                called INavigationService, and the content of this interface is going to be quite simple. We are going
                to have a GoBack method and a NavigateTo method, which is taking a uri. Again, the MainViewModel doesn't
                know how INavigationService is implemented, and in fact it shouldn't have to know, so we are going to
                inject an INavigationService inside the ViewModel constructor, we are going to save the field of this
                type, and then, when the _showDetailsCommand is called, we are going to use this _navigationService
                abstraction to navigate to the DetailsPage. Of course those two interfaces need to be implemented, and
                here in this simple application we are going to keep things very simple. Let's add a new class, called
                DialogService. This is going to be public and implement IDialogService. And here for the ShowMessage
                method, we are going to simply use the MessageBox to show the corresponding message. So it's not very
                elegant, in a production application we would use a custom MessageBox here inside the Windows Phone
                application, but here to keep things simple, I'm simply going to use the MessageBox at this location.
                And for the NavigationService, let's do the same thing again; Helpers folder, Add New Class. (Typing)
                This implementation is going to be public. And for the implementation itself, what I'm going to do is
                get the PhoneApplicationFrame, which is the global frame where all the navigation is happening into a
                Windows Phone App. I'm going to call here _mainFrame.GoBack, _mainFrame.Navigate, and in order to get
                the frame, what we do is Application.Current.RootVisual, which can be casted to a PhoneApplicationFrame.

                Pairing the View and ViewModel, XAML

                So now at this point we have all the pieces of our puzzle, and we can compose the ViewModel with a View.
                To do that, I'm going to go into App.xaml, and I'm going to declare a new resource, which I'm going to
                call "Main", and this is of type, MainViewModel. I'm going to use this resource as the source of my
                DataBindings, but in order to create a resource like that in XAML, we need to have a default
                constructor. And for the moment, this is missing in the MainViewModel class. So let's go, again, inside
                MainViewModel, and I'm going to add the default constructor, which is going to take care of creating
                FriendService, DialogService, and NavigationService. What I'm doing here is not very usual in an MVVM
                application, but again this is a very simple sample. So what I'm doing here is saying, when the
                MainViewModel is created from XAML, I want to use, here, the FriendService, the DialogService, and the
                NavigationService. But later when we do unit tests, we are going to use this constructor directly, and
                we are going to provide some custom implementations of those services. Let's do a little bit more UI. We
                are going to go inside MainPage.xaml, and here I'm going to declare the DataContext of this page, which
                is set through a Binding to the Main StaticResource that I created earlier in App.xaml. So from now on,
                everything which happens inside this page will be in reference to the DataContext implicitly, except of
                course if you specified otherwise in an explicit manner. This allows me to go down to the
                LongListSelector. I'm going to remove the Name of that List, because we are not going to use that
                anymore, and instead I'm going to add here ItemsSource= in a decoupled manner from the markup, through a
                binding, to the Friends ObservableCollection that we declared earlier on the MainViewModel. Next thing I
                can do is take care of the RefreshClick inside MainPage.xaml.cs. Now here, because I am inside a Windows
                Phone Application, I'm not going to call the command directly from the XAML, because this is not
                possible inside an ApplicationBar. Instead I'm going to continue using RefreshClick, and here what I
                will do is get the DataContext of the page, which is a MainViewModel, and then I'm going to call the
                RefreshCommand directly on that MainViewModel. Later, when we do some Windows 8, we will see that we can
                use commands directly from the XAML of the ApplicationBar without having to go through the code behind.
                For the DetailsPage, we will do something very similar. Let's go and open DetailsPage.xaml, and I'm
                going to point the DataContext to the exact same StaticResource called "Main". Of course I need to
                change how those TextBoxes are assigned, and the first thing I can do is remove those TextChanged Event
                Handlers, we are not going to use that anymore. And why don't we do the DataBinding in Expression Blend?
                Like this, we can see how Expression Blend works together with MVVM. I'm going to build the application
                in order to have all the objects ready. Let's open DetailsPage.xaml, select here the FirstNameTextBox,
                and here for the TextProperty I'm going to create a DataBinding. And here notice that Blend knows that
                the data context of this page is MainViewModel, and so I can take the SelectedFriend.FirstName and do a
                TwoWay DataBinding on this property; TwoWay meaning that when the user is typing something in the
                textbox and then the textbox loses a focus, the DataBinding is going to be updated automatically and the
                property is going to be set on the Friend object. Let's do the same thing here for my LastName,
                SelectedFriend.LastName. So we selected very convenient because we don't have to know in advance how the
                object is built. We can visually go and select the right property. Of course we don't have design time
                data yet. We are going to worry about that in just a moment. Let's save everything, go back to Visual
                Studio. Studio tells me something changed, which is okay. And here we see the XAML, which has been
                created, and notably this TextProperty is set now through a TwoWay binding to SelectedFriend.LastName,
                and respectively to SelectedFriend.FirstName. For the Preview, we are going to do the same thing, so I'm
                going to copy here this Binding, I'm going to remove the Name because we don't need that anymore, and
                then I'm going to paste here the FirstName Binding, but I'm going to make that OneWay because this is a
                TextBlock. Same thing for the LastName DataBinding. Let's remove this Name, and use the LastName
                DataBinding instead. So you see that with Bindings, this is a very decoupled mechanism, and I can modify
                my UI without having to worry about code. I can do that either in Expression Blend or directly in XAML.
                Inside the code behind of the DetailsPage, we can remove quite a lot of things. Let's get rid of
                OnNavigatedTo of the TextChanged Event Handlers, we don't need that anymore. And when we Save, what we
                are going to do is pretty much the same thing as before. I'm going to get the DataContext, cast it to
                MainViewModel, and Execute the SaveCommand, using for that, the SelectedFriend as a parameter. Before we
                do that, we are going to have a method called UpdateBinding, and this method is just to take care of a
                small issue in Windows Phone, which is that when you click on an ApplicationBar button when a TextBox
                has a focus, the Binding is not automatically updated. The ApplicationBar in Windows Phone is a
                component which is a little bit annoying and you have to take care of a few things manually. So here we
                are going to use this code, let's just say that it is going to update the binding and make sure that the
                ViewModel is up-to-date whenever I click on the Save button.

                Adding ShowDetailsCommand and Testing the App

                Last, but not least, we need to take care of the navigation to a Friend's detail. For the moment, we use
                this Tap Event Handler to do the navigation, but if we want to clean the XAML and copy this DataTemplate
                to a ResourceDictionary in order to keep the XAML a little bit cleaner and more organized, so let's do
                that. I'm going to cut the DataTemplate from the MainPage.xaml. And then I'm going to move it to Styles,
                Styles.xaml. This is a global ResourceDictionary, which means that everything I add to this
                ResourceDictionary here will be available throughout the application automatically through a
                StaticResource. Because this is a global ResourceDictionary, the FriendTemplate will be found by the
                XAML parser and the StaticResource will be working just fine, but we will have a problem here with the
                Tap Event Handler. The XAML parser is not going to be able to find this FriendTap Event Handler. And in
                fact, if we try to run the application now, we will see that when we try to use this DataTemplate, we
                will get a crash and the application exits. What we need to do now is to remove the tight coupling
                between this StackPanel and the code behind in MainPage.xaml.cs. So I'm going to remove, here, the
                FriendTap Event Handler. I can also go into MainPage.xaml and I'm going to remove the FriendTap here.
                And instead, we are going to use a loose way of executing a command using a behavior. We have talked
                about behavior in the first module in the theory part. Behaviors can be used in XAML directly without
                using Blend, but they are a little bit easier to apply if we use Expression Blend. So let's do that and
                we will talk a lot more about behaviors a little bit later. Jumping into Expression Blend, I'm going to
                select here the LongListSelector, and I'm going to go into â€˜Edit Additional Templates', â€˜Edit
                ItemTemplate', â€˜Edit Current'. Now notice that I'm jumping into the Styles.xaml ResourceDictionary,
                which is normal, because this is where I copied the DataTemplate earlier. Now I want to add a Behavior
                to this StackPanel. And to do this, I'm going to go into the Assets library, in the Behaviors category,
                and I'm going to select a built-in behavior called InvokeCommandAction. Let's Drag & Drop this on the
                StackPanel. In the Properties I want to make sure that I have selected an EventTrigger, and I'm going to
                select the Tap Event. And now we'll see what's going to happen. Every time that the user taps on the
                StackPanel, I want to invoke a command, so let's create a DataBinding. And I'm going to invoke the
                command, not on the Friend, which is a current data context, but instead I'm going to select here the
                StaticResource, Main, which is a MainViewModel, and I'm going to take the ShowDetailsCommand. Now
                remember that ShowDetailsCommand is using a Friend as parameter, so I'm going to have to add the
                CommandParameter to this Command call, and I'm going to select, again, â€˜Create Data Binding'. Remember
                that the Friend is the current data context, and this is, in fact, exactly what I want to use. So I'm
                going to select here a Custom Data Binding and leave the Path empty. What it means is that the
                CommandParameter will be set through the Binding to the current data context of the StackPanel, which is
                a current Friend. This is exactly what we want to pass to the ShowDetailsCommand. Let's click OK, and
                now we are ready to test the application. Testing the application can be done in Visual Studio or
                directly in Blend. I'm going to run the application in the Emulator. If I press the Refresh button, the
                command will be actuated, and we get the list of friends. If I select a friend, the ShowDetailsCommand
                will be called on Tap, and I see that I can go and edit the details of the friend and call the
                SaveCommand to save the modified friend. If I go back into the MainPage and Refresh, we see that the
                change has been saved correctly to the server. After refactoring, we have an application which has the
                same functionality, but it has a cleaner architecture and it's going to be easier to test, to design,
                and to maintain later.

                Adding Design Time Data and Designing in Blend

                After refactoring the application, we now have a Model-View-ViewModel architecture, which we are going
                to leverage. The first thing we want to do is add some design time data to the application to facilitate
                the work in the Visual Designer. When we open the application in Expression Blend, we notice that the
                list controls are empty. We have some static UI elements on the screen, but everything which is dynamic
                is not loaded. However, Expression Blend is not only displaying a static user interface, but it is also
                executing some parts of the code. So we are going to use this fact and force Expression Blend to
                generate some design time data. In Visual Studio, let's make things a little bit more interesting by
                adding a new property to the Friend Model class. We are going to use the PictureUri to show the Friend's
                picture in the application. Then we are going to create a design time implementation of the
                IFriendsService interface. Remember that the FriendService is implementing this interface, and we are
                going to use this abstraction to create a version of the class, which is used only at design time. To do
                this, we are going to create a new folder. Let's call that Design, and then inside this folder I'm going
                to Add the New Class, and I call this the DesignFriendsService. We want this class to be public and to
                implement IFriendsService. (Typing) Let's implement the interface. The Save method is not going to be
                used at design time, but we want to take care of the Refresh method. And what we are going to do here is
                create some simulation of the Friends; we are going to create 10 items with a simulated FirstName,
                LastName, and a Picture coming from the web. Now we need to tell the MainViewModel which version of the
                IFriendsService it needs to use. Let's go into the MainViewModel class, let's select the constructor,
                and remember that the default constructor is used when the MainViewModel is instantiated from XAML, and
                here we are using the default FriendsService. But instead, because the constructor expects an
                IFriendsService, we can actually change this definition here, and instead we are going to use an
                expression, saying that if we are in DesignTool, we are going to use DesignFriendsService; and
                otherwise, if we are at Runtime, we are going to use a standard FriendsService implementation. The last
                thing we need to do is, for the MainViewModel to execute the Refresh method, of course, at design time
                the Refresh method will be executed on the DesignFriendsService. And finally, when the 10 design time
                Friends have been created, we select the first one and assign it to the SelectedFriend. We are going to
                use that later in the design of the DetailsPage. Let's build the application now. And if we change into
                Expression Blend, we notice that some design time data is up here in the LongListSelector, which will
                make the design time work much easier. For example, let's edit the DataTemplate of this
                LongListSelector. Here we are inside the Styles.xaml ResourceDictionary. I'm going to take this
                StackPanel, group it into a grid. I'm going to add the column to this grid and set the width of this
                column to 100 pixels. Then I'm going to take the StackPanel here and I'm going to move it to the second
                column, and in the first column I'm going to take an Image control. And since I have some design time
                data available, I can create a DataBinding here to the PictureUri of the Friend. And now we see that we
                have an Image, which is loaded from the web by Expression Blend, which allows me to do some Visual
                Design here; for example, let's set the Height of the Image to 100 px. And now we can do a few things
                visually; for example, let's change the orientation of the StackPanel to Vertical, we can select here
                the LastName and increase the Font Size to 36 password. And then we probably want to change here the
                margins to make things a little bit more compact and maybe just add a little bit margin on the FirstName
                here. So you see that you have the possibility to create your design visually in Blend, which of course,
                gives us a lot of creative freedom. If I change into the MainPage, I see the result of my work. And for
                example, here it is easy to see that I need a little bit more margins, so let's add some margins to the
                left, to the right, and finally a bit margin at the bottom as well. And here we go; we have something
                which is nicer. Now I can run the application directly from Expression Blend, Let's Refresh the page.
                And here we see the actual Runtime data showing, including the new designs that we just created.
                Obviously the application needs a lot more design love at this point, but the point is that you can do
                this design visually in Expression Blend or in the Visual Studio Designer, and this is going to make
                your life as a designer much easier.

                Unit Testing the Application

                In the next section, we are going to see how we can unit test our application and how we can implement
                some test version of our services in order to create some well-known conditions for the unit test. I
                will create the unit test project in Visual Studio and use the MSTest framework. You probably have your
                own favorite unit test framework, it's absolutely up to you, and in fact all the principles that I'm
                showing now apply to any unit test framework in an MVVM application. So I'm going to Add a New Project,
                and under Windows Phone, I'm going to select a Windows Phone Unit Test Application. I'm going to name
                that WhyMvvm.Test. And then I'm going to remove here the generated method. Let's add our own test
                method, and understand what it is doing. This test method is going to create a new MainViewModel, so
                obviously the test application needs a reference to the WhyMvvm Project. Now we can use the
                MainViewModel class and the Friend class, and we notice that we are using the constructor, which is
                taking some services as parameter. If you remember, there are two constructors in the MainViewModel, the
                default constructor, which is used directly from the XAML, and this default constructor is going to use
                the runtime implementation of the services. There is, however, a second constructor, which we call
                directly here, and we are going to create some test implementations of the services. We have a
                TestDialogService, a TestFriendsService, and a TestNavigationService. Let's implement those services.
                First, the TestFriendsService is going to implement the IFriendsService interface. (Typing) But instead
                of calling a web service, it's going to have a well-known implementation. And this implementation, when
                the Save method is called, is going to throw an Exception using an ErrorMessage, which is defined here
                as a constant. Then, we have a TestDialogService, and here too, we are going to create an implementation
                for IDialogService, and we are going to use a well-known implementation, which instead of showing an
                actual MessageBox, is simply going to Save the message that must be shown into a property. Finally, the
                last service is a TestNavigationService. And this one is going to be even simpler. (Typing) It is simply
                going to declare the method, but it's not going to do anything to avoid some navigation during the unit
                test. So now in our test method, we are using those well-known implementation of services. We are going
                to start the test by asserting that the MessageShown property is null. Then we are going to execute the
                SaveCommand on the MainViewModel, but we know that this SaveCommand is going to call the Save method of
                our well-known TestFriendsService. This is going to throw an exception and we want to verify that the
                corresponding ErrorMessage is passed to the DialogService, which is what we do here in this Assert. Now
                we can run the test and see if everything works fine. So let's go to Test, Run, All Tests. The project
                is building, so tests are starting, and here we see that the test is green, which is a good sign for the
                rest of our development process.

                Summary

                In this section, we have taken our non-MVVM application and we have refactored it to a
                Model-View-ViewModel architecture. We started by making the Model observable. We implemented the
                INotifyPropertyChanged interface and raised the PropertyChanged event. We created a MainViewModel to
                drag the Views. We moved some of the View functionality in some abstracted View services and we injected
                those View services inside the ViewModel. Then we bound the View to the ViewModel in XAML. Then we saw
                how to add design time data in order to make the work in Blend or in the Visual Studio Designer much
                easier. Finally, we added a unit test project to the application and we showed how we can mock services
                in order to create some well-known test conditions. In the next module, we are going to get familiar
                with some of the components of the MVVM Light Toolkit, and we will see how those components can simplify
                the creation of Model-View-ViewModel applications.

                The Core Components

                Introduction: What is MVVM Light and What is it Not?

                In the previous modules, we saw some of the advantages of the Model-View-ViewModel Pattern. And we also
                learned how to refactor an existing application to MVVM. To do this, we didn't use any toolkit or
                framework. In this module, we will introduce some of the components of the MVVM Light Toolkit and we
                will see how they can help you to code faster. First, I would like to have a discussion on what MVVM
                Light is and what it is not. Often, people talk about MVVM Light as a framework, but I prefer to call it
                a toolkit. This is a subtle difference, but it helps to understand what MVVM Light actually does. Then
                we'll start studying the MVVM Light components with a foundational ObservableObject, and ViewModelBase
                classes. The ViewModelBase was actually the very first item added to MVVM Light. These two classes help
                your code to be cleaner and more efficient. We will continue with a study of the RelayCommand; a very
                convenient object that allows you to write less code, to expose properties, implementing the ICommand
                Interface. After that, we will see what the Messenger does. This is a very powerful object, but with
                great power comes great responsibility, and it is important to understand well how this component works
                and to take some precautions. We'll finish this study of the core MVVM Light components with a
                DispatcherHelper. This is a lesson on components that provides a lot of help when dealing with
                asynchronous code and background threads. At the end of this module, you will have a good understanding
                of all the components in the code DLL of MVVM Light and be able to use them in common scenarios in the
                XAML application. Before we talk about each component, let's understand â€˜What is MVVM Light?' and â€˜What
                is it not?' MVVM Light is a toolkit, it is not a framework. With Toolkit, we understand that it is a
                suite of tools, some helper classes containing two DLLs, project templates, item templates, and code
                snippets for Visual Studio. Those are helpers to help you go faster into your code, to avoid the
                monotony of having to write the same code over and over and over again, and of course those tools are
                not only useful for XAML-based applications, but some of them, such as a Messenger or SimpleIoc, can be
                used for any type of decoupled application. MVVM Light, however, is less intruding than the framework
                and lets you select which components you want to use and which ones you want to leave aside.

                The ObservableObject and the ViewModelBase

                Talking about the components, let's start with two classes very useful for databinding; the
                ObservableObject and the ViewModelBase. In a typical MVVM application, the ViewModel layer and the Model
                layer will have multiple classes. Let's start with the ViewModel. In this layer, the classes typically
                implement the INotifyPropertyChanged interface. Until now we implemented INotifyPropertyChanged
                explicitly on each of the classes of the ViewModel. Of course this is quite a lot of repetitive work and
                this can be simplified by adding a ViewModelBase class, by having the ViewModel classes inherit this
                class and by implementing INotifyPropertyChanged directly in the base class. We can also have multiple
                flavors of the RaisePropertyChanged method, and some Helper's properties that we add to the
                ViewModelBase class. In the Model layer, we can also have the classes implement INotifyPropertyChanged.
                And here too, until now, we implemented INotifyPropertyChanged on each of the classes. It is also
                interesting to have a base class, named ObservableObject, which is very similar to the ViewModelBase.
                And in fact, ViewModelBase can easily inherit from ObservableObject in order to simplify the
                implementation. Classes deriving from ObservableObject and ViewModelBase can use a variety of methods to
                raise a PropertyChanged event. Of course, the "Classic" one, raising the PropertyChanged event with a
                string for the property name, and here typically we will use a constant for the property's name. But
                there are also more comfortable ways; for example, the RaisePropertyChanged method, which takes an
                expression as parameter. Using an expression to identify the properties that have changed is better than
                the string, because it supports IntelliSense, and also if you change the name of the property, automatic
                refactoring tools will help you to propagate the change everywhere in your code. There is a very small
                performance impact because of the need to use some light Reflection to get the name of the property.
                Another method, named Set, can help you to create even less code, like we will see in the sample. For
                classes in the ViewModel layer, you can also broadcast the PropertyChanged event through the Messenger
                class. Later in this module, we will learn how to use the Messenger to send messages from object to
                object. This is a very decoupled manner of communicating. To do this, you use an overload of the
                RaisePropertyChanged method, which in addition of the property name, takes the oldValue, the new value,
                and the parameter specifying if you need to broadcast using the Messenger. Of course, just like before,
                you also have the other variants of these methods, and the message sent through the Messenger class is a
                PropertyChangedMessage, like we will see a little bit later in the section about the Messenger. In
                addition to the PropertyChanged event, MVVM Light also supports a PropertyChanging event. This event is
                raised just before the property changes, when the property still has the oldValue, which can be useful
                in certain scenarios. ObservableObject and ViewModelBase supported two overloads of the
                RaisePropertyChanging method, and the Set method that we saw before is also automatically raising the
                PropertyChanging event. Classes deriving from ViewModelBase can use the IsInDesignMode property. This
                property is useful because XAML frameworks have different ways to check if the code is running into a
                Visual Designer, such as Blend. For example, this is a code that we would use in Silverlight and Windows
                Phone, in Windows Store Application in Windows 8, and in WPF. So MVVM Light proposes a way to unify all
                that, and has just one property, named IsInDesignMode. For convenience, this value is also exposed in a
                static property on the ViewModelBase class.

                The ObservableObject and the ViewModelBase (Demos)

                Now we can refactor the small application that we built in the previous module to use MVVM Light. The
                first thing we will do is add a reference to the MVVM Light assemblies. To do this, I'm going to select
                â€˜Manage NuGet Packages', go online, and type mvvmlight in the Search box. I'm going to take the
                â€˜libraries only' and click Install. (Typing) One of the libraries are installed. I can open the
                MainViewModel class and I'm going to change here the INotifyPropertyChanged interface implementation by
                having the MainViewModel derive from ViewModelBase. Now I can delete the INotifyPropertyChanged
                implementation, which I had at the end of this class. And the ViewModelBase class is going to take care
                of that. Then we can simplify the observable properties; for example, the SelectedFriend property. I'm
                going to remove this code here. And instead, I'm going to use the Set method, taking an expression for
                the property name. Here you see that I can use IntelliSense for that. And passing the value. Also, I can
                use the IsInDesignMode property to detect the design conditions. This is going to be useful, especially
                if we want to share code; for example, with Windows 8, WPF, or Silverlight. So here I can use
                IsInDesignMode directly, and in a static context, for example here in the constructor I can use
                IsInDesignMode static instead. Now we can take care of the Model class. So let's open, here, the Friend
                class. And here I'm going to derive from ObservableObject, which is a little bit more lightweight than
                ViewModelBase, and for example doesn't have design mode detection. Let's enhance this class by adding an
                IsDirty property. This property is going to be set to true, if the class needs to be saved to the web
                service. And we can refactor the FirstName and the LastName properties to a simpler form using the Set
                method, and notice that here we use a written value of this method to detect if the property has changed
                and to set the Dirty flag accordingly. And we can do the same here for the LastName property. (Typing)
                Of course what I can do is get rid of the explicit implementation of INotifyPropertyChanged, since now
                this is taken care of by the ObservableObject class. So here we are, this is a small step, but we have
                already refactored our application to take advantage of the MVVM Light classes. Now we can verify that
                our changes didn't break anything, let's run the new application here in the Emulator. I can Refresh.
                Just like before, the Friends list is being loaded and I can navigate to a Friend, do some editing, etc.
                So you see that everything's working just fine.

                Introduction to ICommand and RelayCommand

                After talking about ViewModelBase and ObservableObject, we can talk about the RelayCommand. RelayCommand
                is another very important component in the MVVM Light Toolkit, because it's going to help you to expose
                some functionality on the ViewModel in a very decoupled manner. The RelayCommand is an implementation of
                the ICommand Interface. This interface is not only useful for XAML-based frameworks, but it has
                definitely been used a lot, and especially since the Model-View-ViewModel Pattern got popular. The
                ICommand Interface defines three members; the Execute method is going to be called when the command is
                actuated, then there is the CanExecute method, which should return true or false depending on if the
                command can be executed at that point, or not. And there is a CanExecuteChanged event, which should be
                raised if the Status of CanExecute changes. So if anything in the context of the command changes and you
                want the CanExecute method to be called again, to be reevaluated, then you should raise the
                CanExecuteChanged event. Of course, implementing the ICommand interface for every functionality that you
                want to expose on the ViewModel is quite a lot of work. You will need to have a new class for each
                command. And this class should implement ICommand and should provide an implementation for Execute, for
                CanExecute, and also a way to raise the CanExecuteChanged event. This is obviously quite a lot of
                repetitive work, and here too, the MVVM Light Toolkit is going to simplify the process of implementing
                such functionality. To do this, MVVM Light proposed an implementation of ICommand, called the
                RelayCommand. Let's understand how this works.

                Demonstrating the Commands

                To better understand how RelayCommands work, we are going to start by understanding a standard ICommand
                implementation. So here we have a Windows 8 application, we have a MainViewModel, which is bound to the
                DataContext of the page, and we have here a TextBox. Here below, we have a button, and this button
                doesn't have a Click event, but instead it is using the command, which is bound to something called
                SayHelloCommand, which will be on the MainViewModel. And there is also a CommandParameter, which we bind
                to the TextBox that we saw just before, and we are going to use the TextProperty. Now let's take a look
                to this SayHelloCommand. So the SayHelloCommand is going to be on the MainViewModel. Let's open this
                class. And here we see that the SayHelloCommand is of type SayHello. So somewhere in the application, we
                have a class and here we see that the properties initialized to a new SayHello instance, which is using
                the current ViewModel as a parameter. The SayHello class is here and we see that this is an
                implementation of the ICommand interface. So constructor, like we mentioned, is taking an instance of
                the MainViewModel, which we are going to Save as a field, and then we have the ICommand implementation,
                the Execute method, which is going to be called when the command is actuated, so in that case when the
                button is clicked. And here what we will do is show a MessageDialog using the parameter that is passed
                to the command. Remember that in the XAML, we had a CommandParameter attribute, which is set. In
                addition to that, we implement the CanExecute method. Remember that this method needs to return true if
                the command can be executed, and false if it cannot be executed. And here we are going to rely on the
                _owner attribute. The _owner attribute is the MainViewModel which owns the command and which we passed
                in the constructor. Of course this is a little bit annoying to have a dependency like that from the
                command to the MainViewModel, but here this is, unfortunately, what we have to do. On the _owner, we are
                going to check the Counter property, and if this property can be divided by 2, we are going to return
                true, meaning that the command can be executed. The last member of the ICommand interface is the
                CanExecuteChanged event. And of course we need to raise this event if the context changed and if the
                CanExecute method needs to be reevaluated. So how do we do that? Well because we are outside of the
                MainViewModel and we want to react to a change of the Counter property, we'll need to observe the
                PropertyChanged event of the MainViewModel, and if the property that is changed is the Counter property,
                then we are going to raise the CanExecuteChanged event and this will force the Binding to that command
                to call CanExecute again. So this is a basic way that the command works with a Binding, and because a
                Binding is to a control which can be disabled, when CanExecute returns false, this button is going to be
                disabled automatically. Let's take a look at a small application. I'm going to enter my name, and if I
                click the button, the command is executed and the message dialog is shown. Now if increment the Counter,
                for example going to 1, this forces a CanExecute method to be re-executed, and this time it will return
                false because 1 cannot be divided by 2. So as a consequence, the button to which the command is bound
                will be disabled. If I increment again, this time the CanExecute method returns true and the button is
                enabled.

                RelayCommand Demo

                MVVM Light allows to simplify the small application by taking care of the ICommand implementation.
                Notice that we don't have the SayHello class anymore. Instead, the SayHelloCommand is of type
                RelayCommand of string. And of course the string is a type of the CommandParameter; in this case we
                passed a TextProperty of the TextBox control. The RelayCommand is constructed here and it takes two
                parameters. The first parameter, which is compulsory, is the delegate to the Execute method. In this
                case, we use a named method, called ShowMessage, and notice the parameter of type string. This method
                does exactly the same as before; it simply shows a MessageDialog. The second parameter is optional. In
                this case, we use an anonymous lambda expression, and this is a delegate to the CanExecute method. Based
                on the written value of this method, the command will be enabled or disabled. In this case, we take the
                Counter attribute and then we check if it can be divided by 2. If the result of this expression is true,
                this is what we return, and the command will be enabled. Depending on your personal preferences, you can
                use named methods or anonymous lambdas for those to delegate, or you can mix and match them. Of course
                the code is much simpler, because a RelayCommand property has direct access to private members of the
                MainViewModel; for example, here, the Counter attribute. In order for the CanExecuteChanged event to be
                raised, we use a built-in raised CanExecuteChanged method. Here, every time that the _counter property
                is set, we will raise the CanExecuteChanged event for the SayHelloCommand. Running the application
                produces the exact same result. (Typing) But even in this small application, the advantage of using a
                packed implementation of ICommand is quite clear.

                RelayCommand Slides

                So let's review what we know about RelayCommands. The RelayCommand is a packed implementation of the
                ICommand interface. It needs a delegate to the Execute method, which will be invoked when the command is
                actuated. Optionally, you can also pass a delegate to the CanExecute method, which specifies if the
                command is enabled or disabled. Note that if the control to which the command is bound allows it, the
                control will be disabled if CanExecute returns false. The RelayCommand has a method called
                RaiseCanExecuteChanged that will, well, raise a CanExecuteChanged event. This will false the system to
                reevaluate the CanExecute method, and possibly change the state of the control to which the command is
                bound. The advantage of the RelayCommand is that, since it is packed, it replaces an explicit
                implementation of the ICommand interface, which saves quite a lot of work. When you create a new
                instance of the RelayCommand here as a public property on the ViewModel, you pass a delegate to the
                constructor. This is the Execute method, which can be declared explicitly a name, as shown here, the
                DoSomething method. Optionally, it is possible to pass a second delegate, which can also be a named
                method; in this case, the CanDoSomething method. This method returns a Boolean, true if the command is
                enabled, and false if the command should be disabled. However, it is also possible to declare each of
                the delegate as anonymous lambda expression. For example, here the Execute delegate is an anonymous
                lambda. Or here, the CanExecute delegate, which returns true or false. Note that for simple expressions,
                another possible syntax for the CanExecute lambda is to avoid the returned keyword, as shown here.
                Finally, there is also a generic implementation of RelayCommand, taking a type parameter. This is a type
                of the comment parameter, which the ICommand interface allows. There can be only one parameter per
                command, which is a restriction of the ICommand interface itself. Generic RelayCommands are built in a
                similar manner, for example with a named method, and here note the parameter of the DoSomething method.
                Same thing for the CanExecute delegate, it also receives as a string parameter. And finally, each of the
                delegates can also be an anonymous lambda expression, just like before, with a single difference that
                the lambda expression is declared with a parameter, in this case of type string.

                The Messenger, Receiving and Sending Messages

                Now I would like to talk about an important component of the MVVM Light Toolkit, a component which is
                easy to love, but which can also be easy to overuse, the Messenger. First let's review how conventional
                event handling works in .NET. One issue we have is that registering an event handler will often create a
                strong link between the instance handling the event and the instance raising the event, so this, of
                course, is a potential memory leak. For reference, this is how you register an event handler in .NET;
                for example, the Click event of the button. And this is how you unregister in order to remove any risk
                to a potential memory leak. Of course there is also another difficulty, which is how to even find the
                instance raising the event that we want to register to. Sometimes, this instance can be hidden, or it
                can be located in a part of the application that is not easy to access. Or, sometimes, the event
                subscriber doesn't even know if there will be such an instance at runtime; for example, in a plugin
                scenario. And of course this is especially a problem with decoupled application, when one part of the
                application knows as little as possible about other parts. So for all these scenarios, the Messenger can
                help. What is Messenger? Well sometimes it's called an "event bus". Simply said, it is a system that
                sends messages to a list of recipients. It is fully decoupled, so the center doesn't know if any
                recipient gets the message. And the recipient also doesn't know who sends the message, so recipients
                register to receive the messages based on some criteria. Typically, we use a default instance of the
                Messenger, but it is also possible to create new instances of the Messenger, which will each operate on
                their own private channel. In order to get a message, the recipients inform the Messenger that it is
                interested in a specific message type, and the type can be anything, from a value type like int, bool,
                etc., to normal .NET classes. Typically, messages are broadcasted to all recipients that registered for
                that message type, but it is also possible to open a "private channel" with a token, like we will see in
                a moment. In the typical case, the message recipient registers to the default Messenger instance using
                one of the Register methods. The important parameters are, the type of the message, the instance that
                registers in order to check the lifetime, and a delegate to the message handling method. There are
                multiple ways to register for a message. If you remember the section about RelayCommands, this is quite
                similar. You can easily pass a delegate to a named method, which will receive the message. Or, if you
                don't want to look for a name for this method, you can pass an anonymous lambda expression, as shown
                here. In both cases, notice the message parameter, which contains whatever was sent. Sending a message
                is even easier. Again, any kind of object, even simple values, can be sent. For example, here is how you
                send an instance of MyMessageType. Like mentioned before, you could possibly send a Boolean value if
                really you wanted to. Of course this is probably not a great idea, as there is absolutely no context and
                the recipient is unlikely to know what to do with that message. In a simple Master Details app, we could
                just send a selected item; for example, here's a selectedFriend. Of course, here too, some context is
                missing, and if the application grows more complex, it might be necessary to refactor this part to add
                the missing information. The more realistic scenario is to send dedicated message types. There are a
                number of built-in message types in MVVM Light; for example, the very useful NotificationMessage. This
                message type takes a string, an instruction for the receiver. It can also carry a payload, in this case
                a selectedFriend. Optionally, these built-in message types can also carry a reference to the message
                sender. A little bit like conventional events, often pass the event sender to the subscriber. This can
                be useful, but of course we need to be careful not to store this reference and create, again, the memory
                leaks that we were trying to avoid.

                Messenger Advanced Options

                Let's talk a little bit about memory here. When the recipient registers to the Messenger with a message
                handling method, the Messenger keeps, of course, a reference to this method. Sometimes, it can be
                difficult to unregister. We do our best to avoid the discourses of memory leak. Notably, whenever
                possible, the message handling methods are kept as weak references, so that the object can be garbage
                collected, even if they didn't unregister first, but sometimes this is not possible. The table here
                shows a summary. Message handling methods can be Static, Public, Internal or Private. They can also be
                anonymous Lambdas, which is the same as a Private method. In WPF and in Windows 8, there are no
                problems. You can register a private method or a lambda expression as message handler, and it will not
                create a strong leak. In Silverlight and in Windows Phone, unfortunately, there are some additional
                security restrictions in place. Because of this, it is not possible to create a weak reference to a
                Private, Internal or Anonymous method. Only Static or Public methods are fully safe in these two
                frameworks. So if you use Silverlight or Windows Phone, make sure to analyze your scenario carefully. If
                you see a risk for a memory leak, you should unregister the message handling method. Unregistering is
                quite easy and is generally a good idea to keep things clean. You can easily register a recipient
                altogether, for all the delegates that it registered, or you can unregister for a specific delegate. If
                you are using Tokens to open private channels, like we will show in a moment, you can also unregister
                using the same Token. So let's talk about these tokens. This is a special case, but it can prove useful
                sometimes. In this scenario, one or more recipients can register using a token in the Register method.
                So token can be anything, it just has to be unique. When the Sender sends a message using the same
                token, the Messenger will filter who receives the message. So even if Recip 2 registered for that
                message type, because it didn't use a token, it will not receive the message at all. This prevents a
                need to write filtering logic in every recipient. From a code standpoint, this is how it works. Here we
                use a Guid as a unique Token, but again it could be anything, such as a string or an instance of an
                object. Then we call the Register method using the Token as parameter. And, of course, the same Token is
                used in the Send method of the Messenger. Another special case that can be very useful, is a possibility
                to register for an interface or a base class. For example, let's imagine an IMessage interface,
                implemented by a class called ImplementMessage. If a recipient registers for a message of type IMessage
                and sets this Boolean flag to true, then the method will be called when any message implementing
                IMessage will be sent. This is true when you send a message of type ImplementMessage, but it is also
                convenient with GenerateMessage, that can carry a payload of various types. In this case, the method
                will be called whatever the type of the payload is. Then it is easy to handle the payload of the
                message. I guess that this presentation wouldn't be complete if we didn't mention a few dangers. It is
                very tempting to overuse a component. If you overuse the Messenger, this can lead to confusing code,
                where it is not exactly clear what is happening. If people with less experience have to maintain this
                code, this can cause difficult situations. Be reasonable; for me the Messenger is a last resort, when I
                cannot or don't want to use conventional code, like event handlers, and when for some reason I cannot
                use an IOC container with some services, like we did with the DialogService or the NavigationService.
                Finally, be advised that it is always right. Test your code for memory leaks, make sure you cover
                everything with test cases, and if you are in doubt, use the Unregister method.

                Messenger Demos

                In order to demonstrate the Messenger, I will use a Windows 8 application, but these components work
                exactly the same in Windows Presentation Foundation, Silverlight, Windows Phone, and Windows 8. We will
                let some user controls communicate in a decoupled manner and demonstrate a OneWay message, as well as a
                message with feedback. Here we have an MVVM application with a receiver and a SenderViewModel. So Sender
                can send two kinds of messages; one message type is named LogMessage and carries a Text and a Timestamp.
                If we run the application, we notice this blue area, this is a SenderViewModel. There is a Send button
                and a text field. Let's enter a message. And then we can press Send. Nothing happens because there is no
                receiver registered to get this message. In the ApplicationBar, there is an add button. This adds a user
                control with a ReceiverViewModel as its data context. If I press the Send button now, the message of
                type LogMessage is Send, because each of the ReceiverViewModel subscribed to this message type, we can
                see that those three user controls are getting it. If we add a false user control and send the message
                again, we see that all four user controls get the message, but for the sender it doesn't make any
                difference. In fact, if I remove all the receivers, and send the message again, nothing happens. The
                sender doesn't know that no one got the message. Now let's look at another message type called
                LogMessageWithFeedback. It is based on the previous message type, LogMessage. In addition, it has a
                Feedback property, which is an Action. We will use this action to send Feedback after the user has
                confirmed or cancelled the message. Let's register a mix of receivers. (Typing) Just like before, the
                red ones listen to a LogMessage. The orange ones, on the other hand, listen to a LogMessageWithFeedback.
                So first, let's send a LogMessage. Here we see that only the red ones got it. If I send a
                LogMessageWithFeedback, the orange ones got it, but not the red ones. Using the LogMessageWithFeedback,
                the user can send some Feedback to the sender. This will execute the Action and the dialog is shown; for
                example, here OK or here Cancel. Of course the parameter could be anything. Here I use the Boolean, but
                it could be a string or even a complex object type. Let's take a look at the code. First, the two
                message types. This here is a LogMessage, and as you can see, it's a plain old object with two
                properties; the Text and the Timestamp. Here is now the LogMessage with Feedback. Like we saw before, it
                is based on the LogMessage, so it also has the two properties, Text and Timestamp, but in addition it
                has this Feedback property, which is going to be used to send some Feedback back to the Message sender.
                Now let's go to the SenderViewModel. And here we see what happens when a message needs to be sent.
                First, the message is constructed here, we take a LogMessage, and then we use Messenger.Default to Send
                the message. If we need some Feedback, we will go to the other command and here we build a Message with
                Feedback. which also takes a Text, a Timestamp, and the Action , which is going to be executed whenever
                the user wants to give some Feedback. Here when the Action is executed, we will show a MessageDialog
                using the result to show the string "OK" or "Cancel". Now we can look at the ReceiverViewModel, and this
                is where we will register for the type of message that we want to receiver, either for
                LogMessageWithFeedback or with a simple LogMessage. Like we saw in the slide, the Receiver method needs
                a reference to the receiver itself, in order to monitor the lifetime, and a delegate to the method which
                will be executed, in this case we will build a string with the parameters from the message, Text and
                Timestamp, and then we will assign this to the Display property, which is data bound in the XAML. In the
                case of the Feedback message, we will also Save the _feedback property, which is an Action , so that we
                can execute it later. The execution of the Feedback is shown here. This is a command which is bound in
                the XAML to the OK and the Cancel button, and you can see that we will simply execute the _feedback
                action and we will pass here a Boolean as a result parameter. Finally, notice that we take care here of
                unregistering the two message types. For simplicity, we simply unregister everything when the user
                control is unloaded. This is not strictly necessary, because in Windows 8 even private methods can be
                saved with a weak reference, and the receiver can be garbage collected, even if we didn't do that, but
                it is always a good policy to cleanly unregister whenever possible.

                Dispatching to the UI Thread With the DispatcherHelper

                Now we will talk about the lesser known, but useful component of MVVM Light; the DispatcherHelper. In
                modern applications, multithreading is more and more important. For example, Windows Presentation
                Foundation allows doing synchronous web request to a server. However, in Silverlight, which came later,
                it is not possible anymore. All web requests have to be asynchronous, which is to say that they are
                multithreaded. Similarly, in Windows 8, which is the most recent XAML-based framework, every file access
                has to be asynchronous, as well as many other operations. So more and more, we see that we need to
                program in multithreaded environments. However, this is not always easy. There are a few things that
                need to be taken care of. In this section, we will talk about an issue that may very well crash your
                application if you don't pay attention. So let's review how threading works in .NET. All XAML
                applications start with a Main Thread. This thread is like a queue, where all operations are executed
                one after the other. From the Main Thread, it is possible to start one or more Background Threads. This
                can be explicit, for example by calling the ThreadPool class, or by using a BackgroundWorker, etc. In a
                more complex manner, however, some operations can also operate on a Background Thread, without the
                developer being always aware of it. For example in a Phone application, some senses can raise events on
                the Background Thread; for example, the Compass Sensor or the accelerometer, etc. Another example is the
                HttpWebRequest class, which is used to send complex web requests to a server. Even if the request is
                sent from an application's Main Thread, the response is always received on the Background Thread. One
                issue in that case is that we sometimes need to get back on the Main Thread from the Background Thread.
                This is necessary, because the Main Thread owns all the UI elements. So, if an operation running on the
                Background Thread attempts to modify an object owned by the Main Thread, an Exception is thrown because
                of Invalid Cross Thread Access. Here we see an example of code that can crush the application, because
                the StatusTextBlock is a UI element, but it is accessed from the Background Thread, the Exception is
                thrown. In order to clean this up, we need to take some precautions. The Background Thread will contact
                the Main Thread's Dispatcher and request that the operation accessing the UI element is executed on the
                Main Thread directly. The Dispatcher is a kind of controller for the thread and there is exactly one
                Dispatcher per thread. In code, here is how we do things. Know that in Windows 8, things would be
                slightly different, but the main point remains the same. We have to use a Dispatcher object to send the
                request to execute the operation. In this case, the UpdateStatus method on the Main Thread. This method
                will then safely access the UI element. In theory, this is relatively easy, but there are a few
                difficulties. First, the Dispatcher property that we used before is only available on the view; for
                example, in a page or a window. If we execute the method in a ViewModel, accessing the Dispatcher can be
                difficult. Also, the syntax is a little bit complicated, and it is not the same in all the XAML
                frameworks. For instance, in Windows 8.1, the Dispatcher API is not the same as in Windows Phone, WPF or
                Silverlight. In order to simplify all this, we can use the DispatcherHelper component of MVVM Light. So
                DispatcherHelper stores an instance of the main Dispatcher and provides unified access to its API,
                whatever the framework is. First, the class must be initialized. If possible, as soon as the application
                starts. It is important that the call to Initialize is executed on the Main Thread, which is quite easy.
                Then, whenever some code is executed on a Background Thread like here, the CheckBeginInvokeOnUI method
                can be used. This method receives a delegate, in this case a lambda expression. This delegate will be
                executed on the Main Thread. The DispatcherHelper will check if direct access to the UI element is
                possible. If yes, the method will be executed at once without waiting. On the other hand, if a Cross
                Thread Access is needed, the DispatcherHelper will execute the dispatching properly.

                DispatcherHelper Sensor Demo (Windows Phone)

                We are going to see a few examples of scenarios where the DispatcherHelper becomes useful. First, we
                will study a small Windows Phone application using the accelerometer sensor. This is one of the sensors
                that works on the Background Thread. Not all of them do. The Geo Coordinate Watcher component, for
                example, returns its values on the Main Thread directly. So when you read the location, you don't need
                to dispatch the result to the UI Thread, but when you read the heading with a compass, or an
                acceleration using the accelerometer, you need to do so to avoid a crash. So DispatcherHelper allows you
                to stop worrying about that, because it will automatically find out if dispatching is needed or not. In
                this small application, I have a MainViewModel, which is going to subscribe to a service called
                ISensorService. This is an abstraction of the sensors. In this sample I only take care of the
                acceleration, but we could easily add all the sensors, such as compass or location. The ISensorService
                is located in the Model. We have one method called RegisterForAcceleration, and here is the
                implementation of the SensorService, and the RegisterForAcceleration method. This method takes a
                callback and it will execute the callback everything that the value of the accelerometer has changed.
                The callback is provided by the caller, in this case the MainViewModel. Let's run the application in
                Debug mode and see what happens. If I press the Start button here, the application will crash, with an
                invalid cross-thread access exception. This is a symptom of what we explained earlier in the slides. The
                Sensor event is executed on the Background Thread, which is also where the callback method is executed.
                However, if we inspect the MainViewModel code, which provided the callback, we see that it is assigning
                the returned value to the StatusMessage property. This wouldn't be an issue if the StatusMessage was not
                bound to a TextBlock in the XAML. We know that all UI elements belong to the Main Thread, so the crash
                happens when the UI element, the TextBlock, is being touched from the Background Thread through the
                StatusMessage property. To fix this, we are going to go back into the Service code and we are going to
                use a DispatcherHelper here. I'm going to use the CheckBeginInvokeOnUI method. This method takes an
                action as parameter, this is a delegate. And now I can copy the code to the _callback method, which is
                going to be executed on the Main Thread, so this is a safe zone. Note that for this to work, we need to
                initialize a DispatcherHelper. It can be done anywhere in the code, making sure that the Initialize
                method is called on the UI Thread. Typically, we do this in App.xaml.cs in one of the Initializer
                method, so that the DispatcherHelper is initialized as early as possible. Here in the Phone application,
                I do this in the InitializePhoneApplication method. Now we can run the application again and we will see
                that this time the application does not crash. And in fact in the Simulator, we can simulate shaking the
                device, here, using the shake Recorded Data. Again, not all sensors need to be dispatched to the Main
                Thread. The Location Sensor, for example, is automatically returning on the Main Thread directly.
                However, if you use DispatcherHelper, you don't have to worry about this.

                DispatcherHelper WebRequest Samples (WPF and SL)

                Another example is using a WPF application and a Silverlight 5 application using shared code. We are
                going to execute web code using an HttpWebRequest. Of course this is a very simple example and we don't
                really need this complex object; we could do the same using a web client. HttpWebRequest is useful when
                you need to do more complex operations, but here for the purpose of the demo, we'll use that anyway,
                because of the fact that it gets a response on a Background Thread. So here, everything inside the
                BeginGetResponseCompleted method is executed on this Background Thread. And as you see, we are trying to
                set the Status property, which is data bound to a TextBlock in the XAML UI. If we run this application
                in WPF, everything works fine. Here I can load the web page, and after a short delay, we see that the
                Status was updated. This is because WPF automatically dispatches a PropertyChanged event to the Main
                Thread. So here, everything works fine. Now I'm going to stop the application, and then I'm going to
                move to Silverlight. Let's set this as a startup project and I'm going to run the application again in
                Debug mode, and now if I press a Load button, we see that we get an exception, and if we check the
                details, we will see that there is an UnauthorizedAccessException, so again this is an invalid
                cross-thread exception. So in order to get the application to work, I'm going to have to use a
                DispatcherHelper again, and I'm going to do that in the BeginGetResponseCompleted method, just when the
                Status property is set. (Typing) And now, again, I have created a delegate, which will be executed on
                the Main Thread, and so I can set the Status in this safe zone. Now let's run the application again. And
                we will see that this time, the web page was loaded and the Status was set properly. Because we are
                sharing the MainViewModel code between Silverlight and WPF, using DispatcherHelper is very convenient,
                because in WPF nothing changes, so Status will be set directly on the Main Thread without dispatching;
                however, in Silverlight, the dispatching will be executed, but there's a developer, we don't have to
                worry about that; the DispatcherHelper component is taking care of this. This small example shows a
                value of having a component, such as DispatcherHelper, in order to simplify multithreaded code.

                Summary

                In this module, we discovered the core components of MVVM Light and we learned the features. We talked
                about the base classes used to make observable properties easier to use; the ObservableObject and the
                ViewModelBase. Then we studied commanding in .NET and we understood how the RelayCommand component of
                MVVM Light simplifies this task. We continued our tour with the Messenger component, a system allowing
                to send decoupled messages, even if the sender and the receiver don't know each other. And finally we
                finished with a short explanation of multithreading and dispatching in .NET, and discovered the
                DispatcherHelper component of MVVM Light. In the next module, we will continue to explore MVVM Light by
                discovering the Extras assembly and the components that it contains.

                The Extras

                Introduction

                Welcome to Module 4 of the MVVM Light course. In the previous module, we talked about the core
                components of MVVM Light, the ObservableObject, ViewModelBase, RelayCommand, Messenger, and the
                DispatcherHelper. We'll start this module with a discussion of how Views are bound to their respective
                ViewModels, and we'll discuss various strategies that we recommend using in MVVM Light applications.
                There are two more components that I would like to study in this module; the SimpleIoc and the
                EventToCommand. These two components are placed in a separate assembly called Extras. First we will
                start with an introduction to the Extras assembly, and why it is even there. Then, we will have a
                detailed study of the SimpleIoc component, an IOC container that is well suited for MVVM applications.
                Later, we will talk about the EventToCommand behavior and understand what behaviors are and what this
                particular element does. At the end of this module, you will understand the standard structure of an
                MVVM Light application and understand how the Views are bound to the ViewModels. You will also
                understand why MVVM Light comes in two separate assemblies, and you will know how to use a SimpleIoc and
                the EventToCommand components.

                Setting the DataContext

                At this point, I would like to take a moment to talk about the way that the ViewModel is data bound to
                the Views in a typical MVVM application. First let's recapitulate what the DataContext is. It is, in
                fact, a shortcut; it's a way to say, everything that happens here is in reference to this DataContext,
                unless explicitly specified otherwise. So we don't need to write the fully-qualified Binding expression,
                like we have here, in different places in this document. Instead, we can define the DataContext; for
                example, here, directly in the XAML. And then we can have tighter XAML expressions, which is much more
                comfortable; for example, here in the document. Of course we can still use fully-qualified expressions;
                for example, here, when we're referred to a property, defined in another resource named Strings. So in
                summary, the DataContext is really just a shortcut. It can be set in XAML, like in the previous slide,
                which works great with visual designers, such as Blend or the Visual Studio Designer, because these
                tools pass the XAML code when they render an element. So, of course, a DataContext is taken in account
                by the designer, and the built-in helpers take advantage of this knowledge. Sometimes, however, it is
                more convenient to set the DataContext in the code behind directly; for example, in the Master-Detail
                scenario, if we pass an object to the DetailsPage, it is quite frequent to set the DataContext to this
                object in the OnNavigatedTo method, such as shown here in Windows 8. These are the two main ways to set
                the DataContext, either in XAML through a resource or in the code behind. One thing to consider is that
                when the DataContext is set in code behind and not in XAML, the Visual Designer Tools do not run this
                code. In fact, they never run any code behind because, like this, we avoid some issues, for example with
                animations or other things that are typically triggered in this code. In the earlier demos, we saw the
                advantage of having Blend run some of the application's code, like this we can create some design time
                data. If, however, if we set the DataContext in code behind, we need to come up with another strategy to
                create the design time data. Thankfully the XAML Tooling Team thought of that and created a design time
                data context, which is very convenient. Here is an example. First, we declare an xmlns, pointing to the
                namespace in which the ViewModel is declared. We add another xmlns used by Blend in the Visual Studio
                Designer, typically with a prefixed "d", like design. This prefix is declared Ignorable. This indicates
                to any XAML parser that it should ignore any attribute prefixed by "d"; however, the Visual Designers
                look for these "d" prefixes and will use them for design time tasks. For example, here, the design time
                DataContext is set to an instance of the DetailsViewModel, which will be created at design time. Right
                now the MainViewModel is defined as a global resource in App.xaml. This is not very satisfying, because
                it forces the MainViewModel to be created as soon as the application starts, when the corresponding XAML
                line is parsed. If we have a lot of ViewModels, it means that all of them will be created when the
                application starts, which can slow down the starting time and is really not ideal. This is why MVVM
                Light proposes an additional degree of flexibility, with the addition of the ViewModelLocator. The
                ViewModelLocator provides some additional flexibility to control the lifetime of services and of
                ViewModels. In MVVM Light applications, we declare the ViewModelLocator in the global resources in
                App.xaml. The ViewModelLocator declares the most important ViewModels of the application as public
                properties, for example, here, the MainViewModel, so that it is easy to bind to them, for instance,
                using a visual tool such as Blend. Not all ViewModels are declared by the ViewModelLocator, however. It
                depends on how long they will be alive, when they are created, and so on. In MVVM Light, here is how the
                ViewModelLocator is declared in the App.xaml file, and here is how you can bind to the Main property of
                type MainViewModel in the view. Of course, if you have multiple ViewModels, you will have multiple
                properties with different names.

                Binding to a ViewModel (Demos)

                Let's implement these changes in our application. Again, I want to stress out that this application is a
                Windows Phone app, that the toolkit and all the implementation works exactly the same on every other
                XAML framework, such as WPF, Silverlight or Windows 8. We will use a NavigationService, which is closer
                from the one we use in Production Windows Phone applications. It has one more method, which we add in
                INavigationService. (Typing) This method allows to navigate to a URI and pass an object, a user state,
                to the page that we navigate to. Let's remove the primitive NavigationService we were using until now.
                And replace it with another one, which implements the new method. (Typing) This NavigationService
                implements the new NavigateTo method, it will save the state, and it also provides a new method,
                GetAndRemoveState, which is static and that every page can use to easily retrieve the state when it is
                navigated to. Then we will take care of the ViewModelLocator. Let's add this class in the ViewModel
                folder. (Typing) This is a plain object, which we will make public, and it exposes one public property,
                which is the MainViewModel. This property is exposed for data binding purposes. Then, let's add a
                constructor, which will take care of creating all the services, as well as a MainViewModel. As you can
                see here, we use a DesignMode detection to create the correct FriendsService, either the
                DesignFriendsService or the runtime FriendsService here. We also create a dialogService, a
                navigationService, and we pass those to the MainViewModel constructor. The ViewModelLocator should be
                exposed as a global resource in App.xaml, let's open this file. And here we see the MainViewModel that
                we were using until now. We can replace this with ViewModelLocator, and change the Key for clarity to
                name it Locator. As we mentioned, this is an additional level of flexibility in the creation and
                lifetime management of the services and of the ViewModels. For convenience we can add a static property
                in the ViewModelLocator class, which retrieves this instance from the application's resources and
                exposes it to other objects. Then let's take a look at the MainViewModel. The default constructors that
                we had created were here as a kind of a hack to allow the creation of the MainViewModel in XAML.
                However, now we don't need this anymore because the creation is taken care of by the ViewModelLocator,
                so we can simply remove this default constructor. As such, we have delegated the creation of the
                MainViewModel to another object, the ViewModelLocator, thus implementing a common design pattern, named
                Inversion of Control, or IoC. For design time, let's just add the call to the Refresh method in the unit
                constructors that we have now. Then, we will remove the SelectedFriend property. (Typing) While it is
                not wrong to have the MainViewModel hold a SelectedFriend, it is cleaner to pass this object to each
                page and to let the page set its own DataContext in code. This way, each page is responsible for its own
                state. Also, this minimizes the risks of memory leaks by letting the page handle the SelectedFriend's
                lifetime. So we can just remove this property here, and then in the ShowDetailsCommand, instead of
                saving the SelectedFriend here, we will remove this line here, and we will pass the Friend to the new
                NavigationService that we just added. The Friend will be passed as a state to the page that we navigated
                to. Let's take care of the XAML now. First, in MainPage.xaml, we need to modify the DataBindings, which
                we are going to the MainViewModel. Instead, we use the Main property of the Locator that we declared as
                a global resource. The rest remains the same. Then, in Styles.xaml, we are going to do the same to
                locate the ShowDetailsCommand on the MainViewModel. So here, I'm using the dot syntax in order to drill
                into the MainViewModel and to locate the command inside it. Of course this is in reference, here, to the
                Locator, which is exposed as a global resource. Finally, let's open the DetailsPage. And here I need to
                retrieve the state from the NavigationService and to assign this object as a DataContext of the page. So
                let's add an OnNavigatedTo method, which is going to take care of this. We also need to modify the
                SaveClick Event Handler to retrieve the MainViewModel from the ViewModelLocator, and to execute the
                SaveCommand. In the XAML, we will remove the DataContext from the XAML here, because it is now taken
                care of in the code behind. Then we need to remove the mention of SelectedFriend in every Binding, since
                the reference for the Binding is now the Friend itself. (Typing) Now we can run the application and see
                that we have the exact same functionality, but with a cleaner architecture. We can load the Friends
                list, navigate to a friend, edit and save changes, etc. The only small different now is the design time
                experience in the DetailsPage. If we go to Blend, we see that the fields are empty. This is because, as
                mentioned earlier, Blend does not run the code behind where the DataContext is assigned. What we can do
                now is specify a design time experience for the Friends class in the default constructor. So let's do
                this in Visual Studio. I will open the Friend class, and add a default constructor, which is going to
                take care of creating design time data here. Then, using the design time DataContext that we introduced
                in the slides, we instruct Blend to use that constructor at design time. After we build the project, we
                can switch back to Blend and we will see that we now have some design time data appearing in the details
                page. In MainPage.xaml, however, the design time experience remains exactly the same as before. With
                these changes, we are getting much closer to the MVVM Light application architecture, which offers a
                clean, decoupled structure, as well as a great design time experience.

                Why an Extras Assembly?

                As we mentioned, MVVM Light components come in two separate assemblies, named GalaSoft.MvvmLight and
                GalaSoft.MvvmLight.Extras. Many people have asked why there are two different assemblies. The reason is
                that the components in the Extras DLL require external references. The SimpleIoc container needs a
                reference to the Microsoft.Practices.ServiceLocation assembly. As for the EventToCommand behavior, it
                needs a System.Windows.Interactivity assembly. We will understand a bit later why these external
                references are needed. For some users, adding external references can cause problems, for reason of
                Licenses, or because of the Procurement process. In order to allow the maximum number of people to use
                MVVM Light without issues, I split the components in these two assemblies. If the external references
                are a problem, the user can nonetheless use a Core DLL and leave the Extras aside.

                Introducing Dependency Injection and Inversion of Control

                Now let's talk about the SimpleIoc container. Before we start, it is interesting to recapitulate two
                important concepts of modern programming -- What is dependency injection and what is an IoC container?
                Dependency Injection is a programming concept. It delegates the creation of services that an object
                consumes outside of this object. For example, it is quite common to do something like this. We have a
                DataService and we create the DataService inside the object that uses it; for instance, here in the
                constructor. Of course, this causes a number of questions. What happens if multiple objects use a
                DataService; does it need to be created multiple times? What if we want to switch to a different
                implementation of the IDataService interface? For example, in order to test the MainViewModel class. Who
                is responsible for the lifetime of the DataService, etc.? On the other hand, let's consider this code.
                Here, the IDataService is injected inside the MainViewModel constructor, which then Saves it. As a
                consequence, the MainViewModel is kept completely ignorant from the IDataService implementation. It is
                much easier to swap the IDataService implementation for another one, without the MainViewModel being
                aware of it. So Dependency Injection is a way for an object to say, I want to consume a service, but I
                don't want to be responsible for the creation of this service. Instead, the dependency is injected
                inside the consumer. Here is an example where an external class, named Startup, takes care of creating
                the correct implementation of IDataService based on a condition. Then, this service is injected inside
                the MainViewModel constructor. Now let's talk about another modern application development topic, IOC
                Containers. The abbreviation IOC stands for Inversion Of Control; in the sense that instead of creating
                the object within the consumer class, like we saw before in the MainViewModel, the creation is delegated
                to someone else, thus passing the control to that external instance. An IOC container is an object
                responsible for a few things. It will create services on demand. It is responsible for composing objects
                together by resolving dependencies and injecting the correct instances. It is also responsible for
                caching the created objects and providing an access to them. There are multiple IOC containers available
                to .NET developers. In fact, many of them are available as open-source projects. Here is a
                non-exhaustive list of a few well-known IOC containers.

                Registering Classes with SimpleIoc

                MVVM Light provides another IOC container, called SimpleIoc. You might ask yourself, with all the
                available IOC containers on the market, why is another one needed? Well first of all, SimpleIoc is very
                well suited to MVVM applications, because it has been developed specifically for them. It works also in
                Blend and in the Visual Studio Designer, which is great to create design time data for your ViewModels.
                Also, consider that many developers have never used an IOC container before, and many don't know the
                concept. On another hand, many developers do have a favorite IOC container, and it is almost impossible
                to select one which works for everybody. So instead, I decided to provide a very simple one with basic
                functionality, a little bit like a "gateway drug" to Inversion Of Control and Dependency Injection. Once
                the developers get familiar with the concept, they may be interested to check more advanced components,
                and of course it is possible to replay the SimpleIoc of MVVM Light with another IOC container later.
                Because of these considerations, SimpleIoc was born and integrated into MVVM Light. An IOC container
                always has two important phases, the registration and getting instances. In SimpleIoc, this is how you
                register a class with a container. Simply use a Register method, like here using it with a class.
                Another even more frequent case is registering an interface and specifying which implementation to use;
                like here, the IDataService interface and its DataService implementation. This allows for conditional
                registration; for example, here, based on the condition. One typical usage for this is a detection of
                design time mode, when the application runs within the Designer, such as Blend. In that case, we can
                register a design time DataService, and then at runtime, rather use the actual DataService
                implementation. Note that when the class is registered, it still does not mean that any instance is
                created. The creation is on demand, only when the GetInstance method is called for the first time. Also,
                the created objects are cached and can be accessed as many times as needed. The SimpleIoc act is a
                global cache for the application, which can be very convenient. However, if an object must be removed
                from the cache because it is not needed anymore, this must be done explicitly. Another way to register a
                class is to use a Factory. This is a delegate that returns an instance of the given class. Typically,
                factories are expressed as lambda expressions, like here. These can be useful, for example, if we want
                to return an instance that had been created earlier, or like here, if we need to pass parameters to the
                MainViewModel constructor. Here too, the execution of the factory delegate does not happen immediately
                when the registration occurs. It is only executed on demand when the first instance is retrieved from
                the SimpleIoc. The factory is executed once only, and the result is cached just like before. There are a
                few options that can be used when registering to SimpleIoc. First, the option to immediately create an
                instance as soon as the class or the interface has been registered by using a Boolean as shown here.
                This can be useful if you want to guarantee that the class exists as early as possible. For instance,
                imagine that you have a service that needs to listen to a web circuit in order to receive messages from
                a server and to cache them. Of course, it is good if this object can be created as soon as the
                application starts. Or, imagine a Settings object, which needs to load the saved settings from the file
                system as soon as the application starts. Note that it is also possible to force the immediate creation
                of the instance when a factory is used, like here or here. Another very useful option is the possibility
                to register a class or an interface with a Key. This allows having multiple instances of the same class
                or interface inside the IOC container. Of course, the corresponding instance needs to be retrieved with
                the same Key, so there must be some kind of contract between the class responsible for the registration
                and the consumers that will get the instances later. A little bit later in this module, we will see how
                to recreate instances using a Key.

                Creating and Getting Instances from SimpleIoc

                This is where the GetInstance method is useful. It is quite straightforward; for example, here,
                retrieving the Default instance of MainViewModel, or of IDataService. During registration, it was
                possible to pass a key to the Register method. Back then, we mentioned that it was useful in order to
                have more than one instance of the same class or interface inside the IOC container. Now we can also use
                the same key to retrieve the registered instance. Of course, it means that the same key must be used
                during the registration, and by the consumer. On the other hand, if the instances are registered without
                a key, it is possible to use a key anyway to retrieve an instance. In that case, one specific instance
                per UniqueKey is created and cached. This can be useful if you need a number of instances of the same
                type for some reason. However, be aware that all created instances are cached. If you want to remove the
                instance from the cache in order to free memory, you need to explicitly unregister the instance using
                the same key. We will talk about unregistering a little bit later. One of the advantages of using
                SimpleIoc to create instances is that it will also take care of creating the necessary dependencies and
                to compose them. For example, consider the following MainViewModel constructor. It requires two
                services, one instance of IDataService and one instance of INavigationService. In MVVM Light, typically
                the registration to SimpleIoc takes place in an object, called ViewModelLocator, that we discovered
                earlier in this module. Inside the constructor, we can register the services, like shown here. Then, we
                take care of registering the MainViewModel itself. Later, when the GetInstance method is called for the
                MainViewModel, the SimpleIoc will check if it already has an instance of this class in the cache. If
                not, it will create one, but of course in order to create the MainViewModel, SimpleIoc needs an instance
                of IDataService. Again, same story; it checks if it has an instance of IDataService registered, if not,
                it will create one. Then, the same scenario happens again with the INavigationService. And finally, when
                all the parameters are ready, the MainViewModel can be created, cached, and returned. Let's take a
                moment to talk about two ways to do Dependency Injection in a class. Of course, we already mentioned the
                injection in the constructor, which we use in various examples. This is convenient when the service is
                created in the IOC container and never changes. When the MainViewModel is created here, the instance is
                retrieved and stored as a private attribute for convenience. There is, however, another way to inject a
                dependency in a class, through a property. Here, every time that the property is accessed, it is
                retrieved from the IOC container. This way of doing is useful if the instance of IDialogService may
                change during the application lifetime. In this case, it is not safe to inject the instance in the
                constructor and to save it as an attribute.

                Unregistering Classes from SimpleIoc

                Of course, since we can register to the SimpleIoc component, there is also a way to unregister. This is
                pretty straightforward using the Unregister method. A few things to take in consideration, though. When
                you unregister a class or an interface, you also remove all the instances from the cache automatically.
                If that was not the desired effect, you must take care of retrieving the instance before you go
                Unregister and to save it separately. Unregister can take a parameter, or not. If we call the method
                without any parameter, like here, the class or interface is completely removed from SimpleIoc. Any
                subsequent call to GetInstance will cause an exception to occur. It is, however, possible to pass a
                parameter to the Unregister method. So parameter can be an instance itself. In that case, the instance
                passed as parameter, like here the (this) keyword, is removed from the cache. However, the
                IDialogService interface itself is not removed completely from the IOC container. Calling GetInstance
                again, at this point, will force the creation of a new instance, which will then be cached again.
                Similarly, the key can also be passed to the Unregister method to identify an instance with the same
                result. Note that even if you try to Unregister a class, an interface, a key or an instance that do not
                exist in SimpleIoc, there are no side effects. So really, it is a good clean policy to think about
                unregistering your objects, once you don't need them anymore, in order to optimize memory usage.

                A Typical Scenario with SimpleIoc

                In Navigation Applications, like in Windows Phone and Windows 8, a typical scenario involves navigating
                away from the current page and to a new page. In that case, it can be interesting to add and remove
                services from the IOC container. For example, a custom dialog may be displayed to the user, using an
                IDialogService interface, which is implemented by each page. So each page, when it is displayed, becomes
                a current IDialogService, and the page that was previously displayed needs to unregister. This is how we
                do it. In the OnNavigatedTo method, we add the page itself in the IOC container as the IDialogService.
                Notice how we use a factory to do this and how the factory returns a this keyword, the current page
                itself. For the consumer, which is typically a ViewModel, this is a good way to access functionalities
                of the View in an abstracted manner. The functionality is exposed in the IDialogService interface. At no
                time does the ViewModel know that it is, in fact, using the page itself; this is a clean, decoupled
                implementation. When we navigate away from the page, we Unregister the page, like this. Because we
                passed the (this) keyword as parameter, the instance only is removed from the IOC container.

                SimpleIoc's Utility Methods and Properties

                In addition to the Call methods, SimpleIoc proposes a set of Utility Methods. For example, sometimes it
                is useful to know which classes or interfaces have been registered to SimpleIoc. Also, we might be
                interested to know if a given class or interface has been not only registered, but also created and
                cached. This is what the IsRegistered and the ContainsCreated methods do. Consider this code; if we
                register an interface, in this case IDataService, the call to IsRegistered will return true, as
                expected. However, a call to ContainsCreated will return false, because even though IDataService has
                been registered, the cache does not contain any instance yet. If, after that, a call to GetInstance is
                made, the SimpleIoc will create an instance of DataService and cache it. This is why the next call to
                ContainsCreated returns, this time, true. Another useful method is GetAllCreatedInstances. Because the
                cache can contain multiple instances of the same class by using key, this method allows retrieving them
                all. Note, however, that this method only retrieves instances that have already been created at the time
                where it is called. If a class is registered, but GetInstance has never been called yet, the
                GetAllCreatedInstances method will return an empty list. Let's illustrate this with some code. Right
                after registration, GetAllCreatedInstances returns an empty list. If later we call GetInstance twice
                with different keys, two instances are created and cached. The next call to GetAllCreatedInstances will,
                this time, return them both. On the other hand, the GetAllInstances method acts differently, so do not
                get confused. Calling GetAllInstances does force the creation of instance per class, if that was not
                already the case. This is what we call the default instance of each registered class. For example, here,
                we register the IDataService interface. Even though GetInstance has never been called, the next call to
                GetAllInstances returns one instance. The creation of this Default instance of IDataService has been
                triggered by the call to GetAllInstances.

                The ServiceLocation Assembly and SimpleIoc

                In the beginning of this module, I mentioned that an additional reference is needed by SimpleIoc. The
                Microsoft.Practices.ServiceLocation DLL. This assembly contains a ServiceLocator class, as well as a few
                helper classes, which are quite useful to standardize the usage of IOC containers. Indeed, there are
                quite a few IOC containers available on the market. Choosing which one to use depends on many factors.
                During the course of the lifetime of an application, it is not unconceivable that the Development Team
                decides to swap their IOC container with another one. This is especially plausible in the case of
                SimpleIoc, which is very easy to use, but has limited functionality compared to more powerful offerings.
                In order to facilitate the swapping, the makers of the most popular IOC containers agreed on an
                abstraction model. First, the user can define which IOC container instance should be used everywhere. In
                the case of SimpleIoc, the Default instance is named SimpleIoc.Default. You should register this
                instance with a ServiceLocator class, as shown here. Following this initialization, it is possible to
                interchange SimpleIoc.Default and ServiceLocator.Current. For example, the GetInstance method can be
                called here, on ServiceLocator.Current. This is exactly the same as calling
                SimpleIoc.Default.GetInstance. Of course, the advantage is that ServiceLocator is a standard, and so, if
                at a later point the Development Team decides to use another IOC container using the same standard, all
                the ServiceLocator methods can be left unchanged in the code, which reduces greatly the number of lines
                of code to modify.

                SimpleIoc Demos

                The WhyMvvm application that we built in the previous modules of this course runs fine without an IOC
                container, but adding SimpleIoc to it brings some advantages. Most importantly, it will make it easier
                to extend the application with new features when the time comes. In a typical MVVM Light application,
                the IOC setup is done in the ViewModelLocator. Of course, this is not compulsory and objects can be
                registered in other parts of the application too. It is a good practice to keep the registration
                instructions somewhat centralized in order to make it easier to make changes to the IOC container when
                needed. Here we are in the ViewModelLocator class in the ViewModel folder. We will initialize a
                SimpleIoc in the static constructor of the ViewModelLocator. First, we will let the IOC container create
                the friendsService on demand. So we can replace the creation of the service here and here with a
                registration instead. Let's start with a DesignFriendsService and the runtime service. Now of course I
                can remove the creation of the service here, here, and here. Then, there is a registration for the
                DialogService and the NavigationService. Here, we don't use a conditional registration, but if needed,
                it would be easy to change. Let's add the registration here. Finally, the MainViewModel, which uses all
                these services, can also be registered. In order to trigger the creation of the MainViewModel and all
                the associated services, the GetInstance method needs to be called at some point, but we also need the
                Main property, which is located here, because this is what is used by the DataBinding in XAML. So let's
                replay the Main property by a property with only a getter, and call GetInstance from here. To illustrate
                how easy it is to get the MainViewModel instance or any other cached instance from anywhere in the
                application, let's move to the DetailsPage. Here, we are getting the MainViewModel instance from the
                ViewModelLocator through a static property, which is not very elegant. We can replace this by a more
                decoupled approach using the IOC container. Effectively, the instance of the MainViewModel is the same,
                but we are not using the ViewModelLocator anymore, which is cleaner. This was just a small example of
                how to use SimpleIoc, and there are many other scenarios where this class is very useful. Because it is
                Blendable, that is to say that it works just fine in Blend and in the Visual Studio Designer, it
                facilitates a creation of design time code or can be used in a similar manner to execute unit tests
                without having to modify the ViewModel classes. It is a very handy component of the MVVM Light Toolkit.

                Introduction to Behaviors

                Now let's discuss the last component of MVVM Light Version 4, the EventToCommand. This is a so-called
                behavior, or like we sometimes hear, Blend Behavior. First, let's understand what Behaviors are.
                Initially, behaviors are a modified version of a pattern that the WPF community came up with, called
                Attached Behaviors, and based on attached properties that are available in all XAML-based frameworks.
                For more information about Attached Behaviors, see the link here. I won't go deeper in the details of
                Attached Behaviors, because this is off topic for this course, but it is enough to say that these are
                very powerful and useful in certain situations. The behaviors we are using here are sometimes called
                Blend Behaviors, because they were developed initially by the Blend Team. Mostly, they are a response to
                the problem that the original Attached Behaviors were not easy to use in a tool such as Blend and had to
                be added in XAML manually. On the other hand, the so-called Blend Behaviors were great in Blend, as you
                would expect. However, they are not directly related to Blend, and you can use them, even if you never
                stop blending your life, which of course would be a pity. Behaviors are small pieces of code behind that
                are encapsulated and very easy to redistribute, for example, as part of a DLL. When Visual Studio gets
                installed, you also get all the necessary pieces to use a set of behaviors as part of the SDK,
                especially now that Blend gets installed for free. With Visual Studio 2012 and 2013, you have all you
                need to use behaviors and clean your code behind. Behaviors attach to a UI element. As mentioned, you
                don't need Blend to work with Behaviors, but if you do use Blend, it makes it much easier to find
                behaviors, place them in your XAML, and configure them. Here we see the Blend Assets Library and we see,
                for example, the MouseDragElementBehavior that we will drag and drop on the rectangle and then
                configure. Let's see a quick demo. This is a Windows Presentation Foundation Application created in
                Blend. Now I will add a rectangle to this window, let's make it blue, and in many applications we need
                to implement dragging of an element. This is quite repetitive and honestly quite annoying, because we
                need to handle multiple mouse events and do some calculations to see by how much the mouse moved. The
                first time we implement this, it is interesting, but after the second time we already wish we had
                something better. Thankfully someone encapsulated this code in a behavior named MouseDragElement. Once
                we find this element in the Assets Library, we can drag it on the rectangle and drop it. Then we can run
                the application, and immediately the rectangle can be dragged around the window. This particular
                behavior has one property, so if I select it in the object and timeline, I see the property here called
                ConstrainToParentBounds. If I check this property and run the application again, we will see that the
                rectangle is not constrained to the Window's boundaries. So in Blend, it is really easy to just drag and
                drop the behavior on the element and then to configure it. Here is how the code looks like in XAML.
                Notice how the behavior is neatly attached to the rectangle using the Interaction.Behaviors construct.
                Also, note the usage of two namespaces here; the interactivity namespace, which is where the base
                classes for all the behaviors are found, and also the interactions namespace, which contains a
                MouseDragElementBehavior itself that we just used.

                Introduction to EventToCommand

                In addition to Behaviors, there is another group of elements we can use in a similar manner, named
                Actions. There are differences between Behaviors and Actions. Behaviors are standalone and
                self-sufficient. On the other hand, Actions are always attached to a trigger to be useful. In hardware
                terms, you can think of the action as an actuator, an element that will perform an operation. On the
                other hand, the trigger is a kind of a sensor. One trigger can have one or multiple actions. When the
                trigger fires, it will execute all the actions that are attached to it. There are multiple kinds of
                triggers; for example, the most common one is the Event Trigger, which triggers when an event is fired
                on the attached element. For example, you could use a SelectionChanged event of a ListBox to execute a
                series of actions. Or, another trigger is a Data Trigger, which is great in case of MVVM. The trigger
                will fire when a certain property reaches a certain value, which is set in the Trigger's properties. Of
                course, you can also develop your own behaviors, triggers, and actions. I highly recommend any client
                developer to take a good look at behaviors. In MVVM Light, there is one action which is very useful in
                relationship with RelayCommands; the EventToCommand. In fact, EventToCommand is not a very good name,
                and in retrospect, I wish I would have chosen a better one. It is really an action, meaning that it can
                be attached to *any* trigger, not just Event triggers. The intent of EventToCommand is rather simple;
                every time that it is triggered, it will execute a Command. Because a Command property is a dependency
                property, it can be set by DataBinding, which allows a nice decoupling of the View and the ViewModel. In
                addition to the Command property, there is, of course, a CommandParameter property, which can also be
                data bound. If it is set, this parameter will be passed to the command. Remember from our study of
                ICommand and RelayCommand in an earlier module that the ICommand's methods have a parameter, which can
                easily be set or left null. So which are the scenarios in which you may want to use EventToCommand? Well
                one frequent scenario is whenever you want to execute the command from an element which doesn't support
                them. In fact, in .NET, only the ButtonBase class supports a Command property. It means that the UI
                elements, which derive from ButtonBase, will support Command, such as Button, ToggleButton, RadioButton,
                Checkbox, etc. Any other element does not support Command out-of-the-box, and this is where
                EventToCommand can be useful. That said, even for this control that supports Commands, the Command will
                only be executed when the control is clicked. For any other event, such as MouseOver, there is no
                built-in way to execute a command. Here, too, the EventToCommand component can be used. Of course,
                because EventToCommand is an action, it can be triggered by any type of trigger, such as a Data Trigger.
                We will illustrate this with a demo a little bit later. The last scenario is when an event handler
                simply cannot be used. There are such cases, for example when the XAML control is placed in a file,
                which does not have code behind. This is a case for resource dictionaries. If you have a Data Template
                which is neatly placed in a Resource Dictionary, either in order to be reusable or to keep the XAML code
                clean, there is no way to execute an event handler from this Data Template. In this case, too,
                EventToCommand can be used.

                EventToCommand Demo 1: Handling MouseEnter Event

                Let's illustrate this with a few short demos. This is a WPF application, but the exact same demos can be
                done in any of the other XAML framework. Here we have a Button with the Command property data bound to a
                RelayCommand on the ViewModel. If I run the application and click on the Button, the command fires, no
                problem here; but if I want to handle the MouseEnter event, this won't work. So here I can add an
                EventToCommand. Let's do that in Blend. Because this application had MVVM Light installed, I can see the
                EventToCommand behavior in the Assets Library under Behaviors, here it is. Let's drag and drop it on the
                Button here. Then, in the Properties panel, we can customize it. First, we can choose a type of the
                trigger, which by default is set to EventTrigger; this is what we want. Then, we choose which event will
                trigger the action. Let's find the MouseEnter event, here it is. And finally, we need to set the Command
                which will be fired. Here I can use a Data Binding Editor, let's create a Data Binding. And because MVVM
                Light is set up properly, I can see that the DataContext is a MainViewModel and I can select the correct
                property, this SayHelloCommand. Let's click OK. Now if I run the application again, and I pass the mouse
                on the button without clicking, we see that the Command fires as soon as the mouse cursor enters the
                Button.

                EventToCommand Demo 2: Moving a Template to a ResourceDictionary

                Now let's show something different. This is a ListBox in a Silverlight application. Here, too, what I
                show is applicable also in WPF. In Windows 8, we would use a ListView or a GreetView, and in Windows
                Phone, a LongListSelector, but the principle is exactly the same. It has some design time data defined
                in a DataTemplate. If we switch to Visual Studio and in the XAML, we can see that the DataTemplate is
                defined directly in the UserControl.Resources. So I can add a MouseLeftButtonDown event to the Grid, and
                I can implement the Event Handler directly in the code behind. (Typing) If I run the application now and
                click one of the items, we see that the event handler fires and everything works well. However, I may
                want to clean up this XAML and move the DataTemplate inside a ResourceDictionary. So now I'm going to
                cut this out, and I'm going to go into the MainSkin.xaml ResourceDictionary, which is already merged
                into the UserControl.Resources. Let's do that. Here is MainSkin, and I'm going to paste the code that I
                copied just before. If I try to run the application now, I'm going to get an error, because the
                MouseLeftButtonDown event handler is not found. And, of course, there is absolutely no way to add this
                event handler inside the ResourceDictionary, because there is no code behind. Let's modify this example
                to use EventToCommand to select a Command defined on the item represented by this DataTemplate. So first
                I'm removing the event handler, and then let's show the Command itself, which is defined here inside the
                DataItemViewModel. So here we see the ShowItemCommand, which is going to show a MessageBox using the
                Model.Title. Here is how you would do this in Blend. First I'm going to edit the DataTemplate of the
                ListBox. (Typing) And then I'm going to take an EventToCommand in the Assets Library and drag it on the
                Grid. Then I'm going to go to the Properties panel and I'm going to configure the Command property using
                the Data Binding Editor, and here Blend knows that the DataContext of this DataTemplate is the
                DataItemViewModel, on which the ShowItemCommand is defined. Now if I run the application again, we can
                see that we can click on the item and then the Command is executed, which is just fine. If we want to
                move the Command to the MainViewModel, this is possible too. Here we are inside the MainViewModel class
                and we have such a Command here. This Command receives an item, this is a DataItemViewModel, and then it
                will create a message and use a MessageBox to show this message. Notice how we use item.Model.Title. In
                Blend, it is very easy to retarget the Command. Let's go and Edit the ItemTemplate. Then I will select
                the EventToCommand and open the Data Binding Editor. Because of the way that the MVVM Light Application
                is structured, I can see the ViewModelLocator as a data source, I can select it and see the
                MainViewModel property, and here, the ShowItemCommand. Notice that this Command expects a
                DataItemViewModel as parameter. So let's select it here. And after I press OK, I need to set up the
                CommandParameter property. I need to pass a reference to the DataItemViewModel itself. This is a little
                unusual, because the DataItemViewModel is the DataContext of the DataTemplate. Let's open the Data
                Binding Editor, and now we see that the DataContext of this Binding is a DataItemViewModel, which is
                just what I want. So I don't select any property, but instead I just press OK. Now I can run the
                application again. And this time if I select, we see that we are in the MainViewModel, and this is item
                #1, and here is item #2. Here is a syntax in XAML. Here we see the Interaction.Triggers, this is an
                attached property, just like before we had Interactions.Behaviors. Then we have the EventTrigger, which
                is configured to use a MouseLeftButtonDown event. Here is the EventToCommand itself, which is using the
                Command property data bound through the StaticResource Locator, to the Main.ShowItemCommand. And
                finally, we have the CommandParameter, which is a Binding to the DataContext itself, represented by this
                DataTemplate.

                EventToCommand Demo 3: DataTrigger and EventToCommand

                For the next sample, we will use a DataTrigger inside of an EventTrigger in the Windows Phone
                Application. In standard MVVM scenarios, it is actually quite rare to use DataTrigger, because most data
                operations can be done directly in the ViewModel. But here, I will show an example where we use two
                ViewModels located in a satellite assembly. We will pretend that both ViewModels cannot communicate with
                each other, and so we will use an EventToCommand coupled with a DataTrigger to do that. Here is the
                application in question. The MainViewModel and the SettingsViewModel are located in a referenced
                assembly here. The MainViewModel has one Command, called ValidateCommand. This command will simply set a
                text into the string property named Result. As for the SettingsViewModel, we have the Value property,
                which is an integer, and then we have the IncDecCommand, which we use to increment or decrement the
                Value. Both these ViewModels are exposing the ViewModelLocator as properties for easy access. Now let's
                open the MainPage in Blend. Here we see the Decrement and Increment buttons, which are using the
                corresponding command in the SettingsViewModel. The Value is shown below the buttons. The textbox below,
                which shows â€˜Waitingâ€¦' for the moment, is bound to the Result property on the MainViewModel. So really
                this view is a composite of two ViewModels, which is a little bit unusual, but which happens sometimes
                when you build larger applications. The scenario we want to fulfill is to listen to the Value property,
                and when it reaches a Value of 0, we want to trigger the ValidateCommand on the MainViewModel. There
                are, of course, multiple ways to solve that, and here for the illustration, I will solve this using a
                DataTrigger. Let's add an EventToCommand to the page from the Assets Library. As we saw before, the
                default TriggerType is an EventTrigger, but here we want to use a DataTrigger, so I will click on the
                New button. In the dialog, I will select a DataTrigger from the Microsoft.Expression.Interactions DLL,
                which is a library from the SDK. There are multiple other triggers, such as KeyTrigger for the keyboard,
                a TimerTrigger, etc. Here I select the DataTrigger and then I click OK. The DataTrigger requires a
                Binding, which we will set thanks to the Binding Editor. Let's navigate through the ViewModelLocator, as
                a data source, to the SettingsViewModel. And here we select the Value property, and I can click OK. You
                can verify that the Value is correct thanks to the Value -5 shown here. Then we will set the Trigger
                Value to 0. So when the Value property reaches 0, the trigger will fire. Know that you can use some
                Comparison operators, such as Equal, NotEqual, GreaterThan, LessThan, etc. Finally, let's configure the
                Command. And here we will make a Binding to the MainViewModel's ValidateCommand property. This way, we
                have established the connection between the SettingsViewModel and the MainViewModel without touching
                these two components, only through Data Binding. Now we can test the application. If I click on the
                Increment button, when it reaches 0, we see that the Command was executed, and the Result property is
                set, as expected.

                EventToCommand Demo 4: EventArgsConverter

                In this example, we will handle the MouseClick on the blue rectangle. We want the ViewModel to know
                where the MouseClick occurred, relatively to the top-left corner of TheRectangle itself. The
                MouseButtonEventArgs has a method called GetPosition, which allows us to do this calculation. If we set
                PassEventArgsToCommand to true, the MouseButtonEventArgs will be passed down to the Command as its
                parameter, but this is not a clean interaction, because ideally the ViewModel should not know about the
                objects at all. So let's see how we can set an EventArgsConverter up. Here is the EventArgsConverter,
                this is called MouseButtonEventArgsToPointConverter, and implements the IEventArgsConverter interface
                from MVVM Light. This interface requires only one method, called Convert. It has two arguments, the
                value and the parameter. Let's first set up the XAML markup. Here we have the EventToCommand code. We
                set the EventArgsConverter property to a StaticResource, which is defined in the page's resources. This
                is an instance of the MouseButtonEventArgsToPointConverter class that we just saw. As
                EventArgsConverterParameter, we set the Binding to the ElementName, TheRectangle, itself. Here we can
                see the Name of TheRectangle element. This is the actual element on which the EventToCommand is applied.
                And here in the page resources, we have the MouseButtonEventArgsToPointConverter, which is defined. Of
                course, as usual, this converter could also be defined in the application resources. Inside the
                converter, the MouseButtonEventArgs is received as a value and TheRectangle is a parameter. So we can
                cast these two elements and do the calculation here. The returned value, in this case a point, will be
                passed to the Command as a CommandParameter. Finally, here is a RelayCommand code inside the
                MainViewModel. Notice how the point, which is a result of the calculation of the EventArgsConverter, is
                received and how we can use it to format a message and then show this message in the MessageBox. Of
                course in a real-life application, we would probably use this point to do additional calculations. If we
                run the application now, we can click on TheRectangle and see the position relatively to the top-left
                corner of TheRectangle. Here I am very close from this corner, as you can see. We can also easily change
                the parameter to reference a page itself. Here, the page has a Name set to PageRoot. So if I go into the
                Parameter value here, I can change TheRectangle with PageRoot, and then if I run the application again,
                we will see that the position is now displayed in reference to the page's top-left corner; for example,
                here, the top-left point of TheRectangle itself. This example is quite clean, because the ViewModel only
                knows the point class, which is not directly related to the View. It is a level of abstraction, which is
                comfortable. We could, of course, imagine other examples; for example, with Drag & Drop. The
                EventArgsConverter is an advanced tool, but it is very convenient when you want to perform specific
                calculations inside the ViewModel.

                EventToCommand vs. InvokeCommandAction

                If you've used the Blend SDK before, you may have noticed an action named InvokeCommandAction. This
                action fulfills the same purpose in EventToCommand and can be used instead of EventToCommand in many
                scenarios; however, it does not have a way to pass the EventArgs to the Command or to convert them. This
                is why EventToCommand is still the recommended way to trigger commands in advanced scenarios. In Windows
                8.1, however, the Blend Team took our feedback and added a way to convert EventArgs and pass them to the
                Command. This is what the InputConverter and InputConverterParameter are for. Note that the
                InputConverter is an IValueConverter, so it is a slightly different implementation than in MVVM Light.
                Because the InvokeCommandAction is fulfilling the same features as EventToCommand in Windows 8.1, there
                are currently no plans to port EventToCommand to this version of the XAML framework. In Windows 8.0,
                there are no Blend behaviors at all; however, at this URL, you will find a workaround, which allows you
                to use something similar to EventToCommand, even if you cannot upgrade to Windows 8.1 for some reason.
                For reference, here is a XAML syntax in Windows 8.1 for InvokeCommandAction with a Command Binding, the
                InputConverter, and a Parameter. And again, in other XAML frameworks, InvokeCommandAction does not
                support the InputConverter, in which case you may want to use EventToCommand instead.

                Summary

                In this module, we talked about the architecture of an MVVM Light application and about the extra
                components of MVVM Light. We started this module with a discussion about DataContext and how it can be
                data bound to the View. We introduced the ViewModelLocator, an object which is not part of the MVVM
                Light assemblies, but rather introduced in typical MVVM Light applications as a place to set the
                application services up, to set up the IOC container, and to provide some binding points for the View in
                a way that is optimized for the Visual Designers. Then, we talked about the reasons for having a
                separate assembly for the SimpleIoc and the EventToCommand. We understood that it is because of the
                search party reference assemblies that these components use, and one thing to make it easier for
                everyone to use the core components. Then we had a long, in-depth study of SimpleIoc; an IOC container
                that is easy to use, but powerful enough to cover many of the needs for a client application. SimpleIoc
                is well suited for MVVM applications, and it works beautifully in DesignMode with Blend, so it is a good
                component to know when working closely with designers, which is a trademark of the MVVM Light Toolkit.
                The last component of MVVM Light that we studied is EventToCommand, an action that works coupled with a
                trigger, such as an EventTrigger or a DataTrigger. First, we understood what Blend behaviors are and how
                they can be added to an element and configured. Then we saw specifically how EventToCommand can be used
                to handle any event of any UI element and invoke a command when the event fires. We also saw how
                EventToCommand can be used with a DataTrigger instead. And finally, we discussed the EventArgsConverter,
                which is useful to cleanly handle event arguments in the Command directly at the ViewModel level. The
                next module will show how MVVM Light is installed on a machine, either as a standalone complete
                installation or with NuGet. Then we will review the Project Templates, Item Templates, and the Code
                Snippets; some important components that can get you started faster.

                Installing the MVVM Light Toolkit and Additional Components

                Introduction

                Welcome to Module 5 of the MVVM Light Toolkit reference course. In previous modules, we saw what the
                advantages are of an MVVM architecture over an event-based architecture for XAML-based applications. We
                understood what steps were needed to refactor an event-based app to an MVVM app. And we saw that some
                repetitive operations could benefit from some automation. This is when we introduce the MVVM Light
                Toolkit's components, starting with the Code DLL and then following up with the Extras DLL. This rounded
                up the presentation of the first-half of the toolkit's elements. In this module, we will introduce
                additional elements, such as project templates and code snippets. These additional tools are the reason
                why we don't talk of MVVM Light as a framework. In fact, it is a suite of tools, as well as a guidance
                to build applications, which is why the name toolkit is more appropriate. First, we will see how you can
                install MVVM Light in your application using NuGet, or, on your PC using an installer. We will
                understand the differences between these two approaches. Then, after the whole toolkit is installed, we
                will learn more about the additional components, starting with the code snippets. We will understand how
                they can help you to be more productive in Visual Studio, especially when writing repetitive code. Then,
                we will review a typical application created with an MVVM Light project template and see how it is
                structured and what are the advantages over a classic app. We will also talk about the item templates
                used to create new Views, new ViewModels, or a new ViewModelLocator.

                Using the Assemblies From Nuget

                First, let's talk about NuGet, the package manager that has become very popular in recent years to
                manage the dependencies of an application, notably of .NET applications. NuGet makes it convenient for
                application developers to find the most recent version of a library, and to make sure that all the
                dependencies are loaded correctly. Instead of adding references to a single assembly, the developer
                manages references to packages of assemblies, which in turn can reference other packages. When the
                package is referenced in the project, the NuGet system will load the newest version of all necessary
                dependencies. In addition, if later a newer version is found of the package itself or of a dependency,
                it is easy to get notified and to load the newer version if desired. NuGet is available as a command
                line tool, which makes it easy to integrate it with automated tools. It is also available as a more
                human-friendly Visual Studio extension, which is what we will use in this module. There are quite a few
                advantages in using NuGet to manage your project dependencies. First, a package can contain more than
                just binaries. When a package is installed, it is possible that it also adds files to the project. It is
                even possible to run a PowerShell script to modify the target project. In the case of MVVM Light, the
                user can optionally take advantage of this to create an almost fully-functional MVVM Light application
                just by referencing the NuGet package that we will see later in this module. Before NuGet, .NET
                developers often had to manage the dependencies either by referencing a series of single DLLs, which had
                to be committed to source control, or by installing an SDK on each developer machine. If the SDK was
                missing on the new machine, it was not possible to build the application after pulling it from source
                control. With NuGet, however, the whole packages are saved and can be committed to source control, too.
                This way, when the project is pulled on a new machine, it is immediately ready to be built. As we
                mentioned, NuGet makes it easy to handle updates to a package or to its references. Also, NuGet servers
                can be handled by a firm, a group of developers, etc. This makes it possible to deploy packages that are
                not for the whole world to see, but only to a restricted group of developers. In this module, we will
                use Microsoft's nuget.org server to load MVVM Light. There is one main disadvantage to NuGet, however.
                If the PC is not online when the package is added to the project, it cannot find the NuGet server and
                the process fails. Note that the PC must only be online at the moment of the addition of the NuGet
                package. Once the package has been added, the development can continue offline without problems. In the
                case of MVVM Light, we will see that an offline mechanism is also available to create new applications,
                even when the target PC is not online. On Visual Studio 2012 and 2013, NuGet is already available by
                default. In Visual Studio 2010, however, you need to install it manually. It is quite simple by using
                the integrated Extension Manager. Here is Visual Studio 2010. Now I can open the Extension Manager from
                the Tools menu, and here we see that NuGet is already installed. If that is not the case, I can search
                in the Online Gallery and install NuGet from there.

                A Quick Nuget Demo

                Let's see a quick demo about NuGet. Here we have a WPF application without any additional components.
                This application needs to load and parse a JSON file from a web server when the Main button is clicked.
                Here is a code, which is using the WebClient to connect to the web server and load the JSON file as
                text. And here is a small C# class, which will be used to contain the data parsed from the JSON file.
                Instead of writing the passing code ourselves, it is easier to use an existing package; for example, the
                popular Json.NET. This great library is available on NuGet, so let's look for it. Here I will
                right-click on the References folder and select â€˜Manage NuGet Packages'. Then, I make sure that the
                nuget.org option is selected on the left, and I search for JSON. I make sure to select the correct
                package and then I select Install. What just happened now is that Json.NET was downloaded from the NuGet
                servers and the assemblies were referenced in our application. Then we can close this dialog, and go
                back to the code. The last thing I need to do, is go back to my MainWindow.xaml and add the line which
                is going to deserialize the JSON text into an instance of MyClass. Let's inspect this line, and here we
                see the usage of the JsonConvert class, which comes from Json.NET. If I run the code now and click on
                the button, we see that the deserialization takes place and the properties were passed properly.
                (Typing)

                Libraries Only vs. Full

                When you search for MVVM Light in NuGet, you will see that there are three versions of MVVM Light there.
                Let's understand the differences. One of the packages is named libraries only. This is a package most
                suited for people who have a certain experience with MVVM Light already. It adds only the necessary
                DLLs, so that all the components we saw in previous modules can be used. But it doesn't modify the
                target project at all. Similarly, if you add MVVM Light to a class library in order to use its objects,
                you must select the libraries only. The library is loaded with Core and Extras elements of MVVM Light,
                as well as the System.Windows.Interactivity DLL required by EventToCommand. On platforms where it is
                available, it also adds a dependency to another NuGet package, named CommonServiceLocator. In addition
                to the libraries, the full version of MVVM Light available on NuGet also installs a ViewModelLocator and
                a MainViewModel. This version of the package is most suited for new applications that have just been
                created. It uses an Install script to add additional plumbing in App.xaml, so that the ViewModelLocator
                is loaded as a global resource, as we saw in the previous module. Note that in this version of the
                package, the libraries are added as a dependency through the "libraries only" NuGet Package. It makes it
                easier to handle the DLL. Notably, the application has a main application and some satellite assemblies,
                which also need MVVM Light. In that case, the DLLs are loaded only once from NuGet. Finally, there is
                also a portable class library version of MVVM Light, which is handled as a separate package.

                Adding MVVM Light to an App With Nuget (Demo)

                For the demo, I created an empty WPF application here. Then, I will add the MVVM Light Libraries using
                NuGet. We do the same things as we did before with Json.NET. First, we right-click on the References
                folder and select â€˜Manage NuGet Packages'. Once a dialog is loaded, we search online for MVVM Light.
                Here, I will add the libraries only package. Notice that you can see all the details on the right,
                including the description, the tags, dependencies, and the link to the license. Let's click on Install.
                After a short while, the MVVM Light libraries are installed. If I close the dialog and expand the
                References folder, I can see the DLLs here and here. From this moment on, I can use all the objects that
                we studied in the previous modules. For example, this is the MainPage. And here I can use the Messenger
                to send an initialization message when the MainPage has been loaded. (Typing) Now let's see what happens
                when we pull the Full MVVM Light through NuGet. First, I created a new empty Windows Phone application.
                I will, again, use NuGet, but this time I will select the Full MVVM Light package. Let's search here for
                mvvmlight. And this time I click Install on the first package here. (Typing) And once installation is
                complete, we notice what we mentioned before; the Full MVVM Light package also uses the libraries only.
                Now I can close this dialog. I see a new folder, named ViewModel. Inside it, we find the
                ViewModelLocator and the MainViewModel. Also, if I switch to App.xaml, I see that the ViewModelLocator
                has been added to the application's global resources, like we explained in the previous module. So now
                we can do the following. First, I'm going to open the MainViewModel and I'm going to add a property
                named Message. This is a simple string property. Now let's build the application. Then I can open the
                application's MainPage in Blend. If we switch to the Data pane and check the DataContext of the page, we
                see that it is not set. The NuGet version of MVVM Light does not set the MainPage's DataContext, because
                it would be too dangerous to tinker with an existing application's DataContext. But in Blend it is very
                easy to correct. Notice that on the Project, we can see the ViewModelLocator in the Resources. This is
                the content of the App.xaml's resources. The ViewModelLocator is visible to Blend, because the NuGet
                Install script took care of setting the IsDataSource attribute to true. So now it is possible to expand
                the ViewModelLocator and to drag the Main property, which is the MainViewModel, on the application page.
                Blend proposes to set the page's DataContext to the MainViewModel, which is what we want. And now the
                DataContext has been set. Note that in WPF the experience is just a little bit different, but the same
                steps can be followed and the end result is the same. Now that the DataContext has been set, we can
                expand the MainViewModel here and drag the Message property on the MainPage, which is going to create a
                TextBlock with the appropriate DataBinding.

                Installing the Whole Package in Visual Studio

                NuGet is great when you want to make sure that you have the latest version of the package, but it also
                has limitations. As we mentioned earlier, it only works when you are online. If not, the Package
                Explorer cannot connect to the server. Of course nowadays it is mostly not a problem, but I sometimes
                encounter situations, for example on a plane, where I cannot use NuGet. The other problem is that NuGet
                cannot install templates or snippets, at least not without some kind of workaround. These additional
                tools are very convenient. The project and item templates are creating projects, respectively items,
                which are already formatted to follow the MVVM Light recommendations. We will check these items more in
                details later. As for the code snippets, they are shortcuts adding code at the cursor location and allow
                easy replacement of certain tokens. For example, you can use the MVVM Light code snippets to add a
                RelayCommand or an observable property to your code easily, as we will see in just a moment. Note that
                because the installation process changes in the latest versions of MVVM Light, you should uninstall
                previous versions before you proceed with the installation of the most recent. To do this, please follow
                the steps on the page listed here. To add the full MVVM Light installation to your development
                environment, we are going to use another installation medium, also directly from within Visual Studio,
                the Extensions Dialog. Here we have a fresh new installation of Visual Studio without MVVM Light
                installed. We can see that, because if I select File, New, Project, we don't see the MVVM Light Project
                Templates here on the Visual C#. So now let's open the Extensions and Updates dialog from the Tools menu
                here. I'm going to select Online and then I'm going to type mvvmlight here. (Typing) Immediately we see
                the latest version of MVVM Light available, and we can install it by selecting Download. Here we need to
                Accept the license. And after the installation is complete, we need to restart Visual Studio, which can
                be done very easily. Now if I reopen the File, New, Project dialog, I can see the MvvmLight Project
                Templates. For example, on the Windows Store, Windows, Silverlight, Windows Phone, etc. Also, the code
                snippets have been installed. So, for example, if I create a new MvvmLight application for Silverlight 5
                here, I can open the MainPage.xaml, here is a code behind, and then I can type anywhere in the code,
                mvvm, and here we see the code snippets installed. We will talk much more about the code snippets in a
                moment, so don't worry if you don't see them yet after you install MVVM Light on your machine. So to
                recapitulate, in order to install the full-blown MVVM Light installation, first uninstall previous
                version. Then, from within Visual Studio, you can select Tools, Extensions and Updates, Online, and then
                Search for "mvvmlight". Or if you prefer, you can also navigate to mvvmlight.codeplex.com, and then
                download the Installer package from the Downloads page. However, make sure that you select the correct
                version of the VSIX Installer package; for example, there is a different one for Visual Studio 2012 and
                for Visual Studio 2013. If you are using Visual Studio Express, you cannot use a Visual Studio Gallery
                to install MVVM Light, unfortunately. There are a few technical restrictions in place. So here, what you
                want to do, after you install Visual Studio Express, is to navigate to mvvmlight.codeplex.com, and
                install the VSIX Installer from the Downloads page. Here, too, make sure to select the right version.

                Introducing the Code Snippets

                All MVVM Light code snippets start with the letters "mvvm". So like we saw earlier, if you place your
                cursor in the code and type "mvvm", you should see the list of all snippets shown in IntelliSense. Then
                you can expand the snippet by using the "Tab" key. Once a snippet is expanded, you can navigate from
                token to token in order to replace them by using the "Tab" key again. MVVM Light snippets are grouped by
                functions. For example, we have mvvminpc, which are all snippets used to add an "observable property".
                inpc is the abbreviation for INotifyPropertyChanged. Or, mvvmrelay are for RelayCommands, etc. Then, you
                can select the snippet that is adapted to your needs. For example, the mvvmrelaygeneric adds a
                RelayCommand with a generic parameter. In the demo later, we will review these snippets. Here we see the
                IntelliSense window with all the MVVM Light snippets. Note that each snippet is documented, so if you
                select it without pressing Enter, you will see what this particular snippet does. One small known issue,
                if you are using ReSharper, this tool has its own snippets, which are not compatible with the standard
                IntelliSense ones. This causes the MVVM Light code snippets to be invisible, just like any other Visual
                Studio snippets. So if you want to restore the standard IntelliSense, you need to change the ReSharper
                Settings, on the ReSharper, Options, IntelliSense, and then General. And then you can switch here, from
                ReSharper to Visual Studio, and press Save. (Typing)

                The "INPC" Code Snippets Demo

                Now let's see a few code snippets more in details. We cannot review all of them, because there are too
                many, but we will see the most important ones and then you can study the others on your own. Here is the
                ViewModel class, and I will add some properties to it. Because the ViewModel inherits a ViewModelBase
                class, I have access to some Utility methods like we saw in Module 3, but we also saw that adding an
                observable property requires quite a bit of typing; what we call boilerplate code. Note that because
                this snippet group uses methods defined in the ViewModelBase and ObservableObject classes, it will cause
                a compilation error if you add an inpc snippet in a class that doesn't inherit from these base classes.
                To automate adding a property, let's just type mvvm. In the inpc section, we have a few choices. Here,
                let's start with the basic mvvminpc. If I expand the snippet by typing Tab, we can see the expanded
                code. There are a few tokens that can be replaced. You can jump from token to token using the Tab key.
                The first token is a property's name. Let's type the name "Status" here. The second token is a
                property's type set to bool by default. Let's change that to a string. Then, we add the name of the
                private field. Let's use _status too, but with the attribute conventions. Of course, you can use
                anything you prefer. Finally, we type the initial value, in this case a _status message, such as
                "Initializing". Once you are done, press Escape and the snippet is complete. Notice that this snippet
                had the constant for the property's name, which can be useful when you are outside of this class and
                need to handle the PropertyChanged event. Here, there is a check of the new value and then we raise two
                events; PropertyChanging before the value is set, and PropertyChanged after the value is saved. Let's
                add another property for the user's first name. This time we will use another snippet; for example,
                let's select the one called mvvminpclambda. This snippet uses a RaisePropertyChanged method overload,
                which takes an expression instead of a string for the property's name. We mentioned some of the
                advantages of this approach, notably it makes it easier to refactor a property's name. Here, too, we can
                replace a token; FirstName for the name of the property, the type is a string, the private attribute is
                also called _firstName, and the initial value will be empty. And then we can see the result, which is
                almost the same as the previous example, but this time using Expressions instead of the string-based
                property name. Now, let's add the last name too. This time we can use a Set method. If you'll remember,
                we saw in Module 3 how this method simplifies the status code a bit. Let's replace a token; LastName for
                the name of the property, string for the type, _lastName for the private attribute, and no initial
                value. After we replace the tokens, we see that the setter is only one line of code, instead of seven
                like before. We saw the meaning of the Set method in Module 3 about the ViewModelBase and
                ObservableObject classes. This convenient method simplifies ViewModel code. As a reminder, it also
                returns true, if the event has been raised. Finally, let's see a special case. Sometimes it can be
                interesting to not only raise a PropertyChanged event, but also to send a message using the Messenger
                class that we studied earlier. There is an overload of the RaisePropertyChanged method for this. Here is
                how we can use it with a snippet. Add any of the mvvminpc snippets with a Name and with the letter msg.
                For example, here I will use mvvminpcsetlambdamsg, which is quite a long name. When the snippet is
                expanded and after we replace all the tokens, this is the Age property. Note that the Set method here
                takes a Boolean parameter set to true, which will call the Messenger to send a PropertyChangedMessage.
                This is one of the built-in types in MVVM Light. To illustrate that, I built a small UI here in Blend
                with the FirstName, the LastName, and the Age. These fields are data bound to the corresponding
                properties on the MainViewModel. Now, in Visual Studio, let's check this Emailer class that I added. We
                see that when it is created, it registers a handler for a PropertyChangedMessage of int. First, it will
                check the type of the Sender and the Name of the Property. If the Property is the Age, it sends an email
                here using the NewValue that it just received. In addition, just for test, it will show a MessageBox
                here. This example is a little bit silly, but it illustrates the youthfulness of the
                PropertyChangedMessage, which extends the concept of the PropertyChanged event. And to show that it
                works, after we run the application, we can change the Age here, and here is a MessageBox from the
                Emailer class.

                The "RELAY" Code Snippets Demo

                Another useful group of snippets is used to add a RelayCommand to your code. This snippet can be used in
                any class, though in general we use that in ViewModels too. Here, too, there are multiple variations of
                the snippet. The default one is called mvvmrelay, which adds a RelayCommand without any parameter. So
                let's go back to the MainViewModel. And I'm going to extend it with a new RelayCommand used to show the
                user's full name. First I'm going to Tab mvvmr and then I'm going to select the mvvmrelay snippet. Let's
                expand it. And then I can Tab to replace the tokens. The first token is the name of the field hosting
                the command. We are going to type _showFullNameCommand. And then Tab to the next one, which is the name
                of the property itself, again, ShowFullNameCommand. And now we are done already. So I can go back to the
                first token and type Enter, which is going to automatically place a cursor in the location where it
                makes the most sense to start typing code. Here I will cheat a little bit and use some code that I
                prepared already. And here we go, this code is going to use a MessageBox to show the user's full name.
                Let's get ready to build the application, here we are. Now I can build. Now I go back to Blend, where I
                added a button saying â€˜Show full name'. And what I'm going to do is bind the Command property of the
                button, to the command that we just added in the ViewModel, here we are. Here, too, I can run the
                application directly from Blend. Let's Enter my name, and now I can click on â€˜Show full name', which is
                going to show the full name as defined. This last snippet was a basic RelayCommand without the
                canexecute delegate and without a generic parameter. We can, however, use a full-blown RelayCommand with
                all the options, using the snippet called mvvmrelaygenericcanexecute. Let's consider this UI here. We
                have a textbox and a button. Now let's extend the MainViewModel and add the RelayCommand with a generic
                parameter and the canexecute method. So I'm typing mvvm and I'm going to select the
                mvvmrelaygenericcanexecute, here we go. Then I will replace the token. The first token is a type of the
                Command parameter. Here, I want to check the string entered by the user, so I set this parameter type to
                string, which is a default. Then I Tab to the next token, which is a field name for the command. Let's
                call that _sendEmailCommand. If I Tab again, I have the name of the property itself, SendEmailCommand,
                and then another Tab is going to enter the name of the Execute method's parameter; this is the
                emailInput. Finally, we Tab once more to enter the canexecute expression. Here I will enter a simple
                expression, just checking if the user entered some characters. Of course in production, you will want to
                validate the email address against a regular expression, etc. Let's build the application now to have
                everything up-to-date in Blend. Now we can do some data binding. I can bind the Command property of the
                button to the new Command that we just declared on the MainViewModel. Let's use a â€˜Create Data Binding'
                Editor, and here I can see the ShowEmailCommand. Then, I will bind the CommandParameter to the text
                value of the EmailTextBox. Let's go here and select ElementName, then EmailTextBox, and here I will
                choose the Text property, which is down there. Whenever the parameter changes, the canexecute delegate
                will be reevaluated. If the returned value is false, which is when the email field is empty, the button
                will be disabled, like we see now on the screen. Let's run the application to test what we just did. And
                here if I go to the email field and enter something, you see that the button is now enabled. If, on the
                other hand, I delete everything, the button is now disabled.

                'The "PROPDP" and "PROPA" Snippets Demo

                The few snippets that we just saw are the ones that are the most useful when implementing the ViewModel.
                There are a few other snippets that are less directly related to MVVM itself. In this category, we find
                the Dependency Property and Attach Property snippets. Dependency Properties are a specific feature of
                XAML-based frameworks, such as WPF, Silverlight, Windows 8, Windows Phone, that enable a lot of
                interesting features, especially in controls. In fact, if you use a default installation of Visual
                Studio, there are already two snippets available by default that allow you to declare a new dependency
                property and a new attach property. Let's see why MVVM Light also has such snippets, and how they are
                different. First, let's add a dependency property in a WPF application. Note that you cannot declare a
                dependency property in a ViewModel or in a plain old object. It needs to be a DependencyObject; for
                example, here, the application's MainWindow. I will use a default non-MVVM Light snippet. I simply type
                propdp and then I expand the snippet. We see the typical declaration of a DependencyProperty, including
                the type, the convenient getter and setter for the value, and the registration itself, with the
                property's name declared as a string, the property's type, the typeof the owner, which should be
                MainWindow, and the metadata instance that declares some value, such as here the default value of the
                DependencyProperty. This is quite complex, and I cannot go too deep into the details of the
                DependencyProperty System, but I encourage those of you who are not familiar with this system to study a
                WPF or Silverlight course. Now let's declare a DependencyProperty using the MVVM Light snippet; it is
                called mvvmpropdp. If we expand this snippet now, we see that there is one single difference; the
                property's name is declared as a constant, which is a much better practice. Notably, when an external
                object is listening to the DependencyProperty for changes, it will need to know the name of this
                property to analyze the change and verify that it is a correct property. Having this value declared as a
                constant, it's cleaner than the original version. Note that having a string-based id is not a very clean
                situation anyway, but this is the basis of the DependencyProperty System and there is not much that we
                can do about it. Here is a recapitulation. First we have the mvvmpropdp, which we just saw and which
                declares a dependency property in WPF, and there is also another snippet called mvvmpropa, which
                declares an attached property in WPF. Also, we have Silverlight versions of those two snippets,
                mvvmslpropdp, which you can use in Silverlight, Windows Phone, and Windows 8, and of course there is
                also mvvmslpropa. The differences to the built-in snippets are minor, but they can make the developer's
                life easier when you code a lot. Also, they don't really have to do with MVVM directly. In fact,
                dependency properties are almost never declared in ViewModels, but it is still a very common task for
                XAML developers to declare dependency properties, and as such, these snippets can be useful.

                Introduction and Demo of the Standard Project Template

                Now let's talk about the Project Templates. Once you install the MVVM Light Toolkit, as shown
                previously, you get a series of templates available in the File, New Project dialog. At this time, the
                Project Templates are available for Visual Studio 2012 and Visual Studio 2013. For Visual Studio 2010, I
                do not provide Project Templates at this time. However, I am considering creating a VSIX Installer for
                VS10 too. For now, if you use VS10, please use the NuGet method that I showed earlier in this module.
                The Project Templates are available for Silverlight 4, Silverlight 5, Windows Presentation Foundation
                3.5, 4.0, and 4.5, Windows Phone 7.1 and 8.0, and for Windows Store 8.0 and 8.1. Note that depending on
                your development environment, you might see only some of these templates. For example, Silverlight 4 is
                not supported in Visual Studio 2013, nor Windows Phone 7.1. Let's see now what you get when you create a
                new MvvmLight application. For this demo, let's select File, New, Project, and then on the Windows we
                will take a (WPF45) application. Let's click OK. Once this application is created, let's run it. We see
                a new window with the text, "Welcome to MVVM Light". This is not earth-shattering, but let's see what
                happens when we open the application in Blend. Here, when we open the MainWindow, notice that the text
                is different. We already saw before the power of design time data, and this is exactly what we witness
                here. The application is architected in a way that triggers Blend to run some of the code. This, coupled
                with the fact that we can know in the code if we are running in a Visual Designer, allows us to tailor
                the data to allow the best visual design experience possible. The most important point of a new
                MvvmLight application can be seen in the code. First, let's open App.xaml, and here we see that the
                ViewModelLocator is defined in the global resources. Then, in MainWindow.xaml, we see that the
                DataContext is set to the Main property of the ViewModelLocator. Let's open the ViewModelLocator itself.
                Here, it is configuring the SimpleIoc with a DataService. Of course, this is just basic scaffolding and
                the DataService will be expanded or replaced in your application, but this gives you a good starting
                point. Let's take a look at the DataService, which is located in the Model folder. It is very simple and
                only creates a dummy DataItem and then returns it. This is where you will connect to an actual data
                service, a database, a web service, etc. There is also a design time implementation of the
                DesignDataService in the Design folder, and this is where the text that we saw in Blend earlier is set.
                Of course, in your application, you are going to do a lot of operations in the DataService, and some of
                them will be asynchronous. Note that for now, I am not using the async and await keywords, mostly for
                reasons of code compatibility, but it would be easy to modify the DataService to support these keywords.
                Finally, let's open the MainViewModel to look at the code. Here, we see the DataService being injected
                inside the constructor and then we call it immediately. Here, too, in your production application, you
                will have some logic to handle user input and call the service on demand, refresh the data, etc. A few
                small details that are not critical, but interesting to note; here, in MainWindow.xaml.cs, we call the
                Cleanup method on the ViewModelLocator when the MainWindow is closed. This method is not doing anything
                at this point, but it would be a good place to put code to close database connections, save the
                application states, etc. Now let's open App.xaml.cs, and here we see that we Initialize the
                DispatcherHelper. The exact location of this line of code is different depending on the framework that
                you are using; for example, Windows Phone, Silverlight, WPF, etc. But you can be assured that the
                DispatcherHelper is initialized as soon as possible when the application starts, so this is one less
                thing to worry about. Using a Project Template to start a new MvvmLight Project is, of course, not
                compulsory, and the NuGet option is quite popular. But if you want to get started fast and without
                having to worry about the plumbing, File, New Project, MvvmLight is a great option.

                The Windows 8.1 Project Template

                For Windows Store 8.1, I tried a new concept for the Project Template and I added some meat, you could
                say, to the original template in the form of additional files in the custom folder. This is a little bit
                of an experiment and I am waiting for feedback from the community to know if it is considered as a good
                idea or not. When you create a Windows Store 8.1 application, here is what you get. Let's run the
                application in the Simulator first and see how it is built. The application starts with the MainPage and
                a few elements. There is, here, a button that does navigation. I decided to have a standard button in
                order to put the emphasis on the navigation service that it is using. If you press the button, the
                application navigates to the second page, as expected. Let's go back to the MainPage. Now you see that
                the label changed with the date of the last visit. This is done to demonstrate how you can save the
                state of a page, and you can find the corresponding code in MainPage.xaml.cs. At the bottom, we notice a
                red area. This is a user control. The purpose here is to show how you can handle the different page
                mode. For example, let's see what happens when we move the Simulator to Portray mode. Here, we see that
                the User Control turned to green. Let's go back to Landscape mode. And now it is red again. Now I will
                place the page in Split mode. At first nothing happens, but if we resize the slider here, after a stress
                hold, the page's layout changes again. The User Control turns purple and its layout is different. The
                Navigation button goes from top-right to bottom-centered; also, the page's title is using a smaller font
                now. Let's play the transition a few times to see what happens. (Typing) Most of the objects that make
                this happen are added here in the Common folder. The purpose is mostly educational, in order to show to
                MVVM Light users how certain operations are done in Windows 8. We handle storing and restoring state for
                a page, navigation, showing dialogs, handling Orientation and Split mode, etc. Let's see how the
                Orientation and Split mode are handled. I am using a behavior to do this. Remember that we already
                talked about behaviors earlier, when we learned about the EventToCommand component of MVVM Light. Here,
                we have the Behavior implementation for the User Control. There are a few properties used to enter the
                name of the visual states defining the control's appearance. Then we have the Attach method. This method
                will be called automatically by the system when the page is loaded and the behavior is attached. The key
                of the process here is that the Behavior registers to the MVVM Light Messenger, for an
                OrientationStateMessage. When this message is received, the HandleOrientation method is called. We use a
                VisualStateManager to go to the correct state. This Behavior can be attached to a User Control. For a
                page we use a slightly different one, called OrientationStateBehavior. Let's open this one. In fact, it
                is inheriting the one that we just saw. The main difference is that this Behavior is an additional
                property, called SnapViewMaximumWidth. This can be used to specify when the page should go from
                Landscape mode to Split mode. Further below, this is where we attach to the OrientationChanged event and
                to the SizeChanged event for the page. Finally, here is where the Messenger is used to send the
                OrientationStateMessage. This will be received by the Behaviors attached to User Controls and they, in
                turn, will go to the correct state. Let's open the second page in Blend and see how we can use this
                Behavior. First, I will add a new User Control to the project. (Typing) Now I build the User Control
                with three columns, a big button on the right, three buttons in the middle, and a blue rectangle on the
                left. Let's add the Behavior to the UserControl. In the Assets Library, I will select the
                OrientationStateControlBehavior and drag it on the UserControl itself. On the right-hand side, notice
                the name of the visual state. Here, you could change these names if you want to, but here in the demo
                I'm going to leave them by default. Now let's go and define the state. I have to do that in the States
                tab here. Let's add a StateGroup name, OrientationStates. And here, I will only handle two states, the
                Landscape mode and the Snap mode. Now I am in recording mode; this is shown by the red border around the
                designer area. So here I can specify how the Snap mode is going to look like. For example, let's select
                this big button, and I'm going to make it Invisible. I can also select Button #2 here and hide it as
                well. And finally, let's take this blue rectangle here and turn it red. Now let's exit the state
                recording mode and go back to the page. After I build the application, I can go to the Assets Library,
                and on the Project, I will see the UserControl that I just created. Let's add one to the page. When the
                page gets created, it already has an OrientationStateBehavior; this is in the Project Template by
                default. Notice that this is the other behavior, the OrientationStateBehavior, in the contrary of the
                one we used in the UserControl, which is called OrientationStateControlBehavior. And here on the right
                side, you can see, again, the Visual StateNames, as well as a SnapViewMaximumWidth for the page, which
                is set to 500 pixels by default. In the page, the states are already defined by the Project Template, so
                I don't need to redefine them. Now let's go to Snap mode, and what I'm going to do is take this
                UserControl and move it down here to this location. Let's run the code and navigate to the second page.
                If I resize the application in Snap mode, we will see that after a certain stress hold, the application
                is going to toggle to Snap mode, as well as the UserControl here.

                New View, New ViewModel and MVVMLOCATORPROPERTY Snippet

                The last component that MVVM Light installs are the Item Templates. When you have an existing project,
                like here a Windows Phone application, you can right-click the Project and select Add, New Item. In the
                dialog you will see a few MVVM Light Item Templates. Unfortunately, there is a bug in the way that items
                are filtered by Visual Studio, so you need to pay attention to the items that you add. Here, for Windows
                Phone, look for the (WP8) suffix. We can add a new View, a new ViewModel, and a new ViewModelLocator. In
                this case the application already has a ViewModelLocator, so it doesn't really make sense to add a new
                one. Instead, let's add an MvvmView and we can call that SettingsPage. This page has a few predefined
                attributes, notably the DataContext is set, by default, to the MainViewModel. Let's change that to a new
                ViewModel called Settings that we will create in a moment. Let's add the SettingsViewModel inside the
                ViewModel folder. Then I will select an MvvmViewModel and call that SettingsViewModel. Let's add a new
                observable property, called DefaultEmailAddress. Then, inside the ViewModelLocator, I will add a
                property for this ViewModel. Let's open it. And for this I can use a snippet that we didn't see yet,
                called mvvmlocatorproperty. Here we go. Let's replace a token, this is a SettingsViewModel, and the name
                for the property is going to be Settings, just like we added in the SettingsPage a moment ago. This
                snippet creates noncompilable code, because it adds a static constructor for the ViewModelLocator, but
                in fact we have one already. This is done this way so the developer can simply cut this line out, then
                I'm going to remove the ViewModelLocator here, go to the actual constructor that we had before, and here
                I can paste the line that I just cut. After I build the application and open the SettingsPage in Blend,
                we see that the DataContext is set to the SettingsViewModel as expected. So, for example, I can add a
                TextBox to the page, and then if I take the DefaultEmailAddress property and drag it, it's going to data
                bind the TextBox.Text property to this property in the ViewModel, and here we go, we have the
                DefaultEmailAddress that we defined just before.

                Summary

                In this module, we started by seeing how the MVVM Light Toolkit gets installed. There are two ways to
                get access to the MVVM Light Libraries, either by using the NuGet Package Manager or by using an
                Installer. In the case of NuGet, you can choose between the libraries only, most suited when you are
                developing a class library or when you have an application that is already in development. Or, you can
                select the Full MVVM Light Package, which also installs a ViewModel, a ViewModelLocator, and adds some
                markup to App.xaml in order to provide the basic plumbing for an MVVM application that is also
                designer-friendly. Then, we saw how the Full MVVM Light Toolkit can get installed using the VSIX
                Installer from within Visual Studio, using the Extensions Gallery, or from the mvvmlight.codeplex
                website. This led us to study the additional tools that get installed, in addition to the Components
                Library. We started with the code snippets. These allow the developer to work faster by adding pieces of
                boilerplate code and some tokens that can easily be replaced to create working code. We talked about the
                inpc family of snippets, which add an observable property to a ViewModel, then we saw the relay
                snippets, which add the RelayCommand with various options. Finally, we saw a few more snippets less
                directly related to MVVM, but that the XAML developer will find quite useful. We finished the module by
                talking about the project and item templates. We saw how a typical MvvmLight application created by one
                of those templates looks like. We also saw how the more complex Windows 8.1 project template installs
                additional components that are useful to build decoupled applications. Finally, we took a quick look at
                the item templates for review in the ViewModel. In the next and final module, we will see a lot of code
                examples and learn how MVVM Light can be used in some specific situations. For example, we will talk
                about adding MVVM Light to a plugin-based application, we will also see some practical usage for the
                Messenger and SimpleIoc, as well as see how unit tests can be created for the ViewModel layer.

                Advanced Examples With MVVM Light

                Introduction; Plug-Ins: Introducing the Interfaces

                The last module of this MVVM Light reference course will show a lot of samples. It will be code, code,
                code, and almost no slides. The goal here is to show some specific usage of the MVVM Light components,
                which are not totally usual, while in the rest of the course we showed samples that are rather common
                when using the Model-View-ViewModel Pattern in the MVVM Light Toolkit. First, we will show a large
                sample about building a plugin-based application. Building a plugin framework and adding functionality
                to an application in the form of plugins is a very popular approach, especially in Windows Presentation
                Foundation. This is quite typical for larger kinds of applications. It can be very convenient when
                working with multiple teams, where the need to define a common interface is crucial. In this sample, we
                will see how to build a plugin definition interface, then a Bootstrapper to load plugins from a folder,
                and how we can access the MVVM functionalities through Data Binding, Commands, the SimpleIoc, the
                Messenger, and more. We will also build two different plugins. Then we will see a practical usage of the
                MVVM Light Messenger, in order to build an expandable list for a Windows Phone Application. This is a
                very frequent UX Pattern in Windows Phone Apps, where elements in a list can be selected by tapping on
                the far-left of the item. This expands the list to reveal checkboxes. However, when the list is
                representing ItemViewModels, the interaction can be a little bit tricky to figure out without using a
                component, such as a Messenger. In the sample here, we will see how to build such an experience from
                scratch. Finally, we will talk about unit testing. One of the big selling points of the
                Model-View-ViewModel Pattern is that it can dramatically increase the testability of your applications.
                However, it is still relatively rare to see consistent unit testing of apps. With the samples shown
                here, we will show some techniques and tips to unit test a ViewModelLayer in MVVM Light Applications,
                and hopefully to promote the creation of unit tests for those apps. The first sample we will see is
                about â€˜Using MVVM Light in a Plug-in based Application'. MVVM Light's components are very useful to
                build decoupled applications. So far in this course, we saw how applications can be divided in layers
                that are loosely coupled. Of course, there are other kinds of decoupled applications. One very
                interesting example is a Plug-in based application. This is quite frequent in WPF to build extensible
                applications, where plug-ins are built after the MainApplication, the plug-in host is complete. Or, when
                the project is split in multiple teams and these teams want to work in an independent manner, with a
                minimal level of interaction in order to reuse the friction. Plug-ins are very decoupled, and in this
                case, too, MVVM Light can help you. In this sample, we will see how the RelayCommand, the Messenger, and
                the SimpleIoc components can help in a plug-in scenario. Here, we see the code for the MainApplication,
                which is also called the Host. Typically, a plug-in based application is separated in three types of
                components. The first one is where the definition of the plugin is hosted. For example, here, this is an
                interface called IPlugIn. It has one property and one method. The property is just for information, and
                returns a name of the plugin. Of course, this probably should be a unique name. The GetElement method
                returns a FrameworkElement, which can be anything that will be placed into the PlugInHost. In addition
                to these members, a PlugIn interface could host other information; for example, the desired position for
                the plugin inside the host, etc. The next interface is called IPlugInHost. It defines what the host
                needs to do in order to receive a new plugin. In our case, the host will be the WPF Application's
                MainWindow, but we could have other scenarios or multiple hosts, etc. Here we have two methods, clearing
                all the plugins, for example before we reload, and placing the PlugIn into the host. This method gets an
                instance of the IPlugIn interface that we saw just before and the second parameter is a plugIn's
                dataContext. In true Model-View-ViewModel form, the dataContext will host functionality and information
                that the plugin will use. Note that these interfaces are hosted in a separate assembly. This assembly
                must be implemented early, and must be quite stable during the lifetime of the project. Any change to
                this assembly will have an impact on every plugin and on the MainApplication, so this should be modified
                as seldom as possible.

                Plug-Ins: Preparing the View

                In the MainApplication, the Host, we have a reference to the Contracts assembly. Then, we have an
                important class, the Bootstrapper. This class will be responsible for inspecting and loading plugins, so
                let's check it out. First, the Path of the PlugInFolder is read from the Settings. This allows the path
                to change, even after the application is compiled, which is convenient. Then, we go further down, and we
                will use this foreach loop to load each DLL inside the folder. We will load all the assembly's types and
                check if one or more of these types are implementing the IPlugIn interface from the Contracts assembly.
                If that is the case, we use some Reflection to get the default constructor of the IPlugIn implementation
                and we invoke it to create a new instance of the plugin. Then, this instance is kept in the list. After
                the plugins have been loaded, the Host can call the GetElement method. Remember that the IPlugIn's
                GetElement method is returning a FrameworkElement, which can be placed into the user interface. Here,
                too, we are going to use some Reflection to invoke the PlugIn's GetElement method and to return the
                result casted to a Framework Element. Now let's discover more about the MainApplication's UI. First, we
                can open the ViewModelLocator. It is a pretty standard MVVM Light object, as we saw before many times in
                the course. Here, we register the Bootstrapper into the SimpleIoc in order to make it easily available
                to the application's objects that need it. Now let's see the object that will host the plugins. In this
                application, we use a MainWindow for that. Here is how it looks like in Blend. The orange and green
                borders will be where the plugins are placed. The button below will reload the plugins for the
                PlugInFolder. In the code behind, we see that the MainWindow implements the IPlugInHost interface. We
                already saw these kinds of things before; for example, when we implemented the IDialogService interface
                in order to show messages to the user. Here, the MainWindow registers itself in the IOC container when
                it is loaded. To keep things clean, the MainWindow also unregisters itself in the closing event handler.
                The Clear method is required by the IPlugInHost interface. We will first send a message to whomever is
                concerned, warning that it is time for cleanup. Typically, all the plugins are going to be interested in
                this message. Here, we use a standard NotificationMessage, which is an MVVM Light element. Then, we
                clear the UI by setting the orange and green borders' Child property to null. The PlacePlugIn method is
                also required by the IPlugInHost interface. It uses the IOC container to get the Bootstrapper. Then, it
                gets a FrameworkElement that is defined in the plugIn assembly using the Bootstrapper's GetElement
                method that we just saw. It sets the element's DataContext as required here. Then, it uses an algorithm
                to find out where to place a plugin into the UI. Here, this algorithm is very basic, but it could be
                much more complex; for example, the plugin might require to be placed in a specific location, for
                example a sidebar, a footer, a header, etc. Now let's open the MainViewModel. This will be the ViewModel
                for the application's MainWindow. It has an ObservableCollection of the IPlugIns. We will use this
                collection to show the PlugIn names into the window. Then we have the RelayCommand, which is going to be
                used to reload all the plugins from the PlugInFolder. To do this, we will get the PlugInHost from the
                IOC container and, of course, the MainViewModel doesn't know that this IPlugInHost is actually the
                MainWindow. Again, this is similar to what we did before with the IDialogService. The MainViewModel
                instructs the PlugInHost to Clear the PlugIns. Then it calls a Refresh method on the Bootstrapper and
                saves the PlugIns in the ObservableCollection. And finally, it instructs the PlugInHost to place the
                PlugIn elements in the user interface. Note that in this simple demo, the PlugIn's ViewModel is a
                MainViewModel itself. In a production application, we would have multiple ViewModels with various
                functionality. Later we will see that the PlugIn itself can also specify a separate ViewModel, etc.

                Plug-Ins: Databinding and Commanding

                Now that we saw how the PlugIn infrastructure works, let's add some functionality and see how the
                PlugIns can get access to that. First, I will add a Counter property in the MainViewModel. Let's use the
                MVVM Light's inpc snippet to do that; for example, inpcsetlambda, that we saw just before. I'm going to
                type the name of the property, Counter, and let's make that a string and the name of the field is also
                going to be _counter. And then I'm going to type the initial value, which I set to Initializing. So this
                is a simple string property, which raises a PropertyChanged event when it changes. Then I'm going to add
                a Command. This Command will be used to increment the Counter. I will use the mvvmrelay snippet that we
                saw before, so here we go, Tab. And then I'm going to call that _incrementCommand, and the name of the
                property itself, IncrementCommand, too. The implementation is going to be very simple; I'm simply going
                to take this value here and increment it, and then format the string. So far, this is just standard MVVM
                code. However, because the MainViewModel will be set as the PlugIn's DataContext when it is loaded, it
                means that the PlugIn has access to the Counter property and even to the IncrementCommand through
                Databinding. Here, in the MainWindow, I added a button to increment the Counter. So let's use a Binding
                Editor to bind the button's Command to the IncrementCommand that we just added before. Now it is time to
                work on the PlugIn itself. I have the project defined in another instance of Visual Studio. This is to
                show that we can work on the PlugIns in a totally separate manner. In the References folder, we will see
                a reference to the Contracts assembly that was precompiled before. We also added the MvvmLight
                assemblies. Here is the implementation of the IPlugIn interface. This is a PlugInManager, which is going
                to handle loading the PlugIn UserControl. The name is defined here, we simple return a string, and then
                we have the GetElement method. This creates a new instance of the PlugInControl, again in a very simple
                manner. In the UserControl.xaml, we see that the DataContext is not explicitly set. This will be the
                task of the Bootstrapper in the MainApplication. Remember that the MainViewModel will be used as a
                PlugIn's ViewModel as well, so in the real-life application, we would probably use another class. Here,
                we rely on some knowledge of the ViewModel, notably that there is a Counter property, which is used here
                in the Databinding. If we open this UserControl in Blend, we see that there is no design time data;
                however, this can be easily changed. Remember that we saw in earlier modules how we can use a
                design-time DataContext attribute to create design time data. In the real-life project, the design time
                data can be created by the team who is in charge of the MainViewModel and sent to all the PlugIn
                developers. This is also a contract between the MainApplication and the PlugIns, just like the IPlugIn
                interface. Let's add the design-time ViewModel class here, and of course we can do that either in Visual
                Studio or in Blend. And here, the DesignMainViewModel was sent to the PlugIn Team by the
                MainApplication's Team, so let's just add it. If we take a look at the code, we see the two properties
                that we decided to expose to the PlugIns. There is a Counter property, which in the real-life
                MainViewModel is an observable property, but here it just returns a string purely for design time
                purpose. There is also the IncrementCommand, which is defined here as an ICommand. Note that in this
                case, the Command is never even created, it doesn't matter because it is purely for design time purpose.
                So now we can instruct Blend to use this object at design time. First, let's build the application. And
                then I'm going to change into Expression Blend and go here to the Data panel. I'm going to set the
                design-time DataContext, and here I can select DesignInstance. This is going to show me all the objects
                in the application and, for example, I can look for DesignMainViewModel, which is here. We will also set
                the IsDesignTimeCreatable property to true, as we saw in earlier modules. Let's click OK, and
                immediately we saw that design time data appears on the screen, and if needed, we can easily make
                changes in Blend, for example, change the FontSize, change the Foreground, etc. In XAML, here is how the
                design-time DataContext looks like. Again, this is just like we demonstrated in earlier modules as one
                of the ways to set design time data in Blend. Then we are going to take advantage of the
                IncrementCommand. So I'm going to take a Button, add it here, and let's do just a little bit of design,
                Reset the Layout, and maybe add a little bit of margin. Now I'm going to bind the Button's Command
                property to the IncrementCommand itself. And again, I'm going to use a Binding Editor. And here, too,
                because we have design time data, we can simple select IncrementCommand and click OK. Now we are going
                to use this PlugIn in the application. So first I'm going to build the PlugIn assembly, and then I'm
                going to go into the Debug folder. Let's copy this DLL, and I'm going to place it in the PlugIns folder,
                which is located here. Now remember that the location of this PlugIns folder is set in the application
                Settings. So I can change the location of the folder at any time and then simply restart the application
                without recompiling. Now I can run the application, and let's reload the plug-ins. And here we go, we
                see that one plug-in was found in the Plug-ins folder and was successfully loaded. Now I can increment
                the Counter directly from the application, and here we see that the plug-in, through the Databinding,
                reacts to the PropertyChanged event. And finally, we can also invoke the Command directly from the
                Plug-in and we see that the Counter is also incremented.

                Plug-Ins: Sending a Message to the Plug-Ins

                The PlugIns can also define their own ViewModels. For example, here I added a PartialViewModel inside
                the PlugIn1. When the PartialViewModel is constructed, I'm going to register to the MVVM Light's
                Messenger. Remember earlier, we saw that when the PlugIns are unloaded by the PlugInHost, a
                NotificationMessage is sent through the Messenger. So here in the PlugIn's PartialViewModel, we can
                listen to that message. Then I can add the method that is going to handle the NotificationMessage. And
                here, if this is a CleanupNotification, we are going to Unregister this PlugIn from the Messenger in
                order to avoid memory leaks. Of course, in a real-life scenario, it is very useful for the PlugIn to be
                notified so, for example, files can be closed or database connections, maybe some logs can be recorded,
                etc. The Messenger can obviously be used for other purposes as well, such as sending a value to the
                PlugIns. The advantage of the Messenger is quite obvious here, since the sender does not have to know
                how many PlugIns, if any, are loaded. The Messenger can also be used to send values and objects; for
                example, a SelectedUser, etc. Let's add this feature to the MainViewModel and to the MainWindow, and
                then we will communicate this information to the interested PlugIns. Now I am back into the
                MainApplication's Window, into the Host, and we will use a Messenger in order to send an object to all
                the PlugIns. We will call that object, the User. So let's add this object into the Contracts assembly.
                Of course, this is important to add it to the contract, because everybody in the application must know
                about this user. Let's open the User class, and we see that it is quite simple; it just has two
                Observable properties, the FirstName and the LastName. Then I will use this object into the
                MainViewModel inside the MainApplication. First, I'm going to add an Observable property called
                CurrentUser and, of course, here, we could use the mvvminpc snippet that we saw before. Then a little
                bit further down, I'm going to add a Command, which is going to be used to send the CurrentUser to all
                the interested PlugIns. So let's check the code. What I'm going to do is send a new NotificationMessage
                <User>, so this is a special message type, which carries a notification and also a payload, in this case
                    the CurrentUser. For example, this could be a notification when a new user looks into the
                    application, etc. Now let's prepare the PlugIn to receive the message. First, I add a property,
                    which will display the UserFullName, according to a specific format. Then, inside the constructor, I
                    will add another registration to the MVVM Light Messenger. We will check if the Notification is a
                    NewUserNotification, and if that is the case, we will use a message.Content to create the
                    UserFullName according to a specific format. Now that the PartialViewModel is ready, let's use it in
                    the XAML. I will add a snippet of XAML here, this is a Grid containing a few elements. There is a
                    TextBlock here, which is data bound to the UserFullName property that we added to the
                    PartialViewModel. So now we need to set the DataContext of this Grid to the PartialViewModel, which
                    we can do in code behind. In the PlugInControl1.xaml.cs, I will use this line of code in the
                    constructor to set the PartialPanel's DataContext to a new PartialViewModel. Of course, because the
                    DataContext is set in the code behind, it means that we need a design-time DataContext for the
                    Visual Designer, in case we need it for design time data. This is easy to set up. So here in the
                    PartialViewModel, inside the constructor, I'm going to add some design time code, which is going to
                    detect the DesignMode, and in case the DesignMode is active, we are going to set the UserFullName to
                    a known value. Now I can build the application at this point. And if we take a quick look in Blend,
                    we can see that the design time data is working, and now we could use a Visual Designer to polish
                    the design of this PlugIn. Now I can test the feature in the MainApplication. I have copied the
                    updated version of PlugIn1 into the Plugins folder, so now I can reload the plug-ins, here we go,
                    and we see that the user has not been set yet. I also added this UI to the MainWindow, which is
                    going to allow me to send a message to the plugins using the Messenger, just like we saw before.
                    Here I can go in and enter any name, for example Albert Einstein. And then I can send this name to
                    the plugins, and here we see that the first plugin has actually received the name.

                    Plug-Ins: Using a Dataservice Inside the Plug-In

                    Now I would like to show how the PlugIns can get access to services, which are defined inside the
                    Main assembly, or any other assembly for this matter. So first I'm going to add some objects to the
                    Contracts assembly. Everything we want to share with the PlugIns must be added inside the Contracts
                    assembly, which is referenced everywhere. And here I'm going to add an IDataService interface and
                    the TestObject. Let's take a look at IDataService. This is a very simple interface, which has just
                    one method, and this method is going to be used asynchronously to retrieve a TestObject. The
                    TestObject itself has two properties. We already saw something like that in the previous module,
                    when we were demonstrating NuGet and the Json.NET assemblies. Now we are going to implement the
                    DataService inside the Main assembly, so let's add a New Class. I'm going to name that DataService.
                    Let's make it public. And I'm going to implement IDataService, which is defined inside the Contracts
                    assembly. And now I can add the implementation of the GetTestObject method, which is going to
                    retrieve the json file from the web server and use Json.NET to deserialize this into a TestObject.
                    Now I can register the DataService inside the ViewModelLocator, like we did multiple times during
                    this course. And I'm going to do this, here, inside the constructor. And, of course, just like
                    before, I could also go ahead and define a DesignDataService used at design time, but here for the
                    purpose of the demo, I'm not going to do that. Now let's go back to the PlugIn assembly. Here, I'm
                    going to start by adding a property to retrieve the DataService from the IOC container. This is the
                    same DataService that we just registered into the MainApplication's ViewModelLocator. Of course,
                    because we are using the IDataService abstraction, it could be any implementation; we don't need to
                    know about it. Now I can go ahead and add a RelayCommand here, so I'm going to use mvvmr, like
                    before, and I will call this, _callServiceCommand, here we go. And here, too, CallServiceCommand.
                    Let's implement this command now, so I'm going to drag the code here. And what we will do here is
                    call the DataService in order to get the TestObject. Of course, this is an asynchronous method so we
                    need to await that, and because this is awaited, I need to set this lambda expression to async. Once
                    a TestObject is retrieved, we are simply going to show a MessageBox for the demo, but of course in a
                    production application, we would actually use those values. In the user interface, I added a Button,
                    which is data bound to the Command that we just added. Now we are ready to test again. What I did
                    before is that I built the plugin and then I made sure to copy the latest version from the Bin,
                    Debug folder inside the Plugins folder so that the application can find the latest version. Now I'm
                    going to reload the plug-in. Here we see the new UI that we just created, and if I go ahead and call
                    the DataService, this will call the GetObject method and trigger the MessageBox to be shown. So even
                    though the DataService was implemented in the Main assembly, our plugin was able to use it thanks to
                    the IDataService interface, and of course through the IOC container.

                    Plug-Ins: Building a Second Plug-In

                    In this whole demo so far, we have used only one PlugIn, but of course it is very easy to build a
                    second one. So here is a new class library, in which I added a new user control. In the References
                    folder, I added a reference to the Contracts assembly, like just before. And here, I also
                    implemented the PlugInManager with a Name and, of course, a GetElement method. And I also added the
                    DesignMainViewModel, just like before. So let's go in Blend and do a little bit of design. First of
                    all, I'm going to set the design-time DataContext, just like before, let's select here
                    DesignInstance. I'm going to look for DesignMainViewModel, and set IsDesignTimeCreatable to true.
                    Then I'm going to take this Grid, and let's make it another color, for example green. I'm going to
                    take a TextBlock and then I'm going to put it in the middle. And, of course, we can do a little bit
                    of design here. First of all, let's do that quite a lot bigger and maybe white is nicer. Then I'm
                    going to do some Databinding, so let's take here, the Data Binding Editor, and I'm going to bind
                    this to the Counter property on the MainViewModel. Finally, we can be a little bit creative; this is
                    the beauty of Blend. Let's create, here, a new Storyboard, and what I'm going to say is that after 1
                    second, I want this element here to be rotated by 360 degrees. I'm going to select to stop here and
                    choose an Easing function; for example, Cubic. We can go ahead and test that directly to Blend. Ok.
                    And then finally, what I'm going to do is, select here the Storyboard, and set AutoReverse to true,
                    and set the RepeatBehavior to Forever, which means that the animation will go and then come back.
                    And this will continue forever during the lifetime of the application. So now we have our PlugIn
                    ready. I can build it, and now I'm going to copy the DLL into the Plugins folder. So let's go here
                    into the Explorer, bin, Debug. I'm going to take here just the PlugIn2 DLL, let's copy that. And
                    then I'm going to go into the Plugins folder, where I already have the PlugIn1, Paste this. And now
                    if we run the application without any modification to the Host, we can reload the plugin and we see
                    that now we have two plugins, and the functionality is still there. For example, if I increment the
                    Counter, we see that all the values change, just like it was expected. This complex demo shows the
                    power of the Model-View-ViewModel Pattern and, of course, of the MVVM Light Toolkit in the context
                    of a very, very decoupled application using Plug-ins. Now to be clear, not all applications need
                    Plug-ins and, in fact, in the context of WPF, this is probably best for relatively large
                    applications, but even for smaller apps, Plug-ins can be useful; for example, think about a Windows
                    Phone Application where you can have in-application purchase of new functionality implemented as
                    Plug-ins. Because of the high level of abstraction between the application's components, MVVM
                    Light's elements are very well suited to help you build the functionalities that you need in a much
                    easier manner.

                    Expandable List: Preparing the Infrastructure

                    In this second sample, we will see an application of the Messenger component of MVVM Light. This is
                    especially useful when you don't know in advance how many recipients will subscribe to a message,
                    from 0 to a large number. This can also be useful in the user interface layer, as we will see here.
                    In Windows Phone, there is a well-known user experience pattern, where List elements can be expanded
                    by tapping on the left-most side of the screen. They will slide to reveal a checkbox, which can be
                    used to select the items on which certain operations must be performed; for example, we see that
                    behavior in the Email Application in the Emulator. Here, we see the messages. In order to select
                    them, for example, for deletion, we can tap on the side of the screen here. Notice that the item
                    that we tapped is immediately selected. Also, we see that the sliding is done with an animation. We
                    can select multiple items like that. And now if I deselect them, we notice that when we deselect the
                    last item, the list will collapse back into place. In our application, we want to use MVVM, and so
                    the List is actually representing an ItemViewModel. So ViewModel will expose an IsSelected Boolean
                    property, as well as an IsExpanded property, which is also a Boolean. In order to manage these
                    properties and all the interaction, we can create a BaseViewModel that these items will _____; we
                    will name that the SelectableViewModel. Let's check the SelectableViewModel's code. First we see the
                    two properties that I just mentioned, IsExpanded and IsSelected. IsExpanded is a standard observable
                    property, which works because a SelectableViewModel inherits the MVVM Light ViewModelBase. The
                    IsSelected property is a little bit more complex; we'll come to that in a moment. Let's scroll down
                    for now. Here, we expose a Command, which is called ExpandCommand. This is what will be actuated by
                    the small button on the far left of the screen. What happened when this command is actuated is this;
                    first, the IsExpanded property is set to true, then the IsSelected value is also set to true,
                    because when the button is tapped, we want the corresponding item to be selected, just like we saw
                    in the Email Application. Then comes the important part, we use a Messenger to send an
                    ExpandMessage. This is because the other items in the list must also expand when one item gets
                    expanded. The ExpandMessage is here, and we see that it is a simple GenericMessage . It means that
                    it is sent carrying a simple Boolean value as payload. Because it has a specific type, however,
                    there can be no confusion as of the intent of the message. Back to SelectableViewModel, the next
                    interesting method is a constructor. Here, we register each item for two different message types.
                    The first one is the ExpandMessage that we just saw. First, we will check if the Sender is the item
                    itself. This is necessary, because the item can both send and receive ExpandMessages. In order to
                    avoid unwanted effects, we need to prevent the item from doing anything if the Message received was
                    sent by the item itself. The next message type that we'll register for is a little bit more tricky.
                    We use that to gather some information from all the items. What we want to know is if an item is
                    currently selected or not. If all items are unselected, we want the whole list to collapse. In order
                    to do this, we will use a different type of message, called IsItemSelectedMessage. Let's take a look
                    at the code. Here is a code of IsItemSelectedMessage. This message has an Action as payload, which
                    is a _callback. The _callback should immediately be executed when the message is received, in order
                    to inform the sender about the state of the item. To allow this, the message has an Execute method,
                    which is just a friendly way to execute the _callback. So here, back into the SelectableViewModel,
                    how do we use this message? First, in the item constructor, we register for this message type. When
                    it is received, the Execute method is called on the message. What it does is very simple; it just
                    returns a value of the IsSelected property to the sender. This way, the sender will know the state
                    of all the items in the list. Let's see who sent the IsSelected message. This happened here, all the
                    way up into the IsSelected property. Because this property will be data bound to the item's checkbox
                    in the user interface, we know when the user deselects one item. If the value is false, we need to
                    check all the other items, in order to know if the list should be collapsed. So we will ask all the
                    items by sending the IsItemSelectedMessage here. When an item executes a callback, we check the
                    result and we use this to compute the global value of all the items. Then, if all the items replied
                    that they are already unselected, we can collapse the list by sending an ExpandMessage with the
                    value of false. Now let's see how we can use this SelectableViewModel inside an application. So here
                    I create an ItemViewModel, which derives from SelectableViewModel. For the demo, it is very simple
                    and has just one Text property. Inside the MainViewModel here, I added an ObservableCollection of
                    ItemViewModel, and here inside the constructor, I create two initial items, which I add to the
                    collection. I also added a RelayCommand here, which is going to be used to add new items to the list
                    on the go. When an item is created and added to the list, I set the IsExpanded property according to
                    the state of the other items. Know that I could also use the IsItemSelectedMessage here if I wanted
                    to, but it is easy enough to use a query against the items in the Observable Collection instead.

                    Expandable List: Creating the UI and Testing

                    Let's look at the User Interface in Blend now. Right now it is not really what we want. We have a
                    Button, a checkbox, and the item's title. We see the two items created and available as design time
                    data. We already saw how to create design time data for an MVVM Light Application, so I don't go
                    further for now. Let's Edit the Template for the first item. (Typing) Let's hide everything except
                    the Expand button for now. We want this button to look very narrow and to be placed at the far left
                    of the screen. To do that, I created a Styling Blend that I'm going to apply to the button. (Typing)
                    In the normal state, the button is invisible, but let's see what happens in the Template. (Typing)
                    Here I have the States, and if I go to the Pressed State, we set the background color to the phone's
                    accent brush. In the Emulator it is set to red by default, but depending on your User Settings, it
                    can be a different color. Let's go back to the ItemTemplate now. The next element we want to handle
                    is a SelectionCheckBox. In the default state of the item, it should be collapsed, which means that
                    the width should be set to 0 pixels. Note that by default it is set to 68 pixels; remember this
                    value because we will use it later. For now, let's set that to 0 pixels, and in order to get a nicer
                    transition, I will also set the Opacity to 0%. Now I will define the transition, and for this I will
                    need the State Panel, which is selected here, and I'm going to define two states. So, here, let's
                    create a StateGroup and I'm going to call that ExpandStates. Then I create a new state, which I'm
                    going to call Expanded, and then another state, which I'm going to call Collapsed. The Collapsed
                    state is a default state for this item, so here I don't need to do anything. Let's record the
                    Expanded state. Notice that Blend is in recording mode, so everything I do now will be valid just
                    for the Expanded state. What we want to do is set the Opacity to 100%, and then I'm going to restore
                    the Width of the item to 68 pixels, like we had before. Of course, we want this transition to be
                    animated, so I'm going to set the transition time here to 0.3 seconds, and I'm also going to set the
                    acceleration here to a nice Cubic Transition, like so. Now we need to trigger the transition to
                    happen. Because we use MVVM, we can do that using a DataTrigger behavior, and a GoToStateAction. So
                    first of all, let's stop the recording here. Then I'm going to go to the Assets Library inside the
                    Behaviors and I'm going to take a GoToStateAction and drag it on the Grid here. Actually, I need two
                    GoToStateActions, one for the Expanded State and one for the Collapsed State. Let's take the first
                    one here. I'm going to change the TriggerType to a DataTrigger. And then I'm going to do a
                    Databinding using the Data Binding Editor here. And I'm going to trigger the GoToStateAction when
                    the value of IsExpanded changes. When the value is false, I want to go into the Collapsed State. And
                    for the other GoToStateAction, I will do the same; replace the EventTrigger by a DataTrigger, and
                    here, the Binding to the IsExpanded property. When the value is true, I want to go into the Expanded
                    State. I need to assert GoToStateAction for the initial value of the item. When a new item is added,
                    it needs to go to the correct state depending on the value of its IsExpanded property. This time,
                    instead of using a DataTrigger, I will use a default EventTrigger. I will handle the Loaded Event of
                    the item, and here I will add a Condition. What I will do here is Create a new Data Binding to the
                    IsExpanded property, and I will say that if the Condition is true, then I want to go into the
                    Expanded State without any transition, because this is an initial value, so I don't want the
                    animation to happen. Now that the States and Animations are defined, I just have to bind the UI
                    elements to the ItemViewModel's property. We already took care of the Title. For the checkbox, I'm
                    going to bind the IsChecked property to the IsSelected (Boolean) property here, with a TwoWay
                    DataBinding. And for the Button here, I will go and find the Command property and I will data bind
                    this to the ExpandCommand in the ItemViewModel. Now we can test the application, so here are the two
                    initial items. I can expand them by selecting the first one. Let's select the second item, unselect
                    the first one, and unselect the second one. And now if I expand the items and add a new item, we see
                    that it shows up in the correct state already. If I collapse everything, all three items are
                    collapsing, and I can expand all three items again. This user experience is very common in Windows
                    Phone and it can be tricky to realize if we don't use a decoupled tool, like the MVVM Light
                    Messenger. In that case, however, the Messenger makes it easy to get an undefined number of
                    ViewModels to communicate with each other.

                    Unit Test: Testing the SelectableViewModel's Expansion

                    For the next sample, we will see how we can unit test a ViewModelLayer of an MVVM Application. The
                    MVVM Light components can easily be used in Unit Test Scenarios, which allows the ViewModels to be
                    thoroughly tested automatically. There are multiple unit test frameworks available for .NET, each
                    with a crowd of followers. It is not the purpose here to show which unit test framework is the best
                    or the worst, but just to show some techniques used to unit test ViewModels with MVVM Light. For the
                    purpose of this course, we will use a unit test framework, which is integrated in Visual Studio. For
                    a starter, let's see how we can test the behavior of the SelectableViewModel that we implemented in
                    the previous sample. We can verify the following features. The first feature is that when one item
                    gets expanded, it must be selected too. In addition, all the items must be expanded. The second
                    feature of the ViewModel is that if the last item of the list gets unselected, then all the items
                    should collapse. To do this, we will create a new UnitTest Application in Windows Phone. Let's do
                    Add, New Project, and here on the Windows Phone, I will select a UnitTest Application. This creates
                    a special type of Windows Phone Application that gets integrated in the unit test framework that
                    Visual Studio offers. Now I can click OK. And now I know that to test our SelectableViewModel, we
                    need to add two references. The first one is a reference to MVVM Light, because SelectableViewModel
                    is a ViewModelBase. So we can do that using NuGet, like before. Here we go, and I'm going to select
                    here the â€˜libraries only'. (Typing) Then, of course, I need to reference from TestApp1 to
                    SelectableList, because this is the assembly in which the ViewModel that we want to test is
                    included. So let's do References, Add Reference. And then I'm going to take Solution,
                    SelectableList, and OK. Now let's see what was created in the project. When we created this unit
                    test project, the first test class was added automatically. In fact, it is a totally standard class,
                    which is decorated with a test class attribute. We also have one TestMethod also decorated with an
                    attribute, this time called TestMethod. You can have as many test classes and TestMethods as you
                    need. Let's just rename this one to TestExpansion. Then we can write the code for this method.
                    First, we will create a List of 5 SelectableViewModels. Then we will call the ExpandCommand on the
                    first item of the list. This simulates the interactions that the user has when he taps the small
                    Expand button on the far-left of the screen. Then we can Assert the result of the test. First, we
                    know that each item in the list should be expanded. Then, we also test that the first item, the one
                    that was tapped, IsSelected. Let's run that test using the Test Explorer. First I need to build the
                    application, and then I can click on Run All. And here we go, the test passed.

                    Unit Test: Testing the SelectableViewModel's Collapsing

                    The second test I want to write is to test what happens when all the items get unselected. Let's
                    call it TestCollapse. Here I will get the code, and here again, we create a list of 5
                    SelectableViewModels. Then I'm going to expand the list using the first item, just like before.
                    After that, though, we also select the second item in the list. So now we have two items, which are
                    selected. Now, let's unselect the first item. We can now Assert that all the items should still be
                    expanded because the second item is still selected and so the list may not collapse yet. Then I
                    unselect the second item in the list, and now I can Assert that all the items in the list should
                    collapse. After I build the application, let's run the second test. Here we see that the second test
                    passed as well, which is great. Now, however, let's write something else. If I run both tests
                    together, we see that the first one passes, but the second one fails. This is weird, because we know
                    that the second test passes when it is executed individually. So what happened here? Well the
                    problem is that the Messenger object is used in the implementation, and it has a state, it has kept
                    track of the previous operation. We had the list of SelectableViewModels created in the first test
                    and this had registered with the Messenger. When we register the second list too, in the second
                    test, the first list is still there, it is still registered, and it will respond to the query to
                    know if some items are still selected. This can be a little bit confusing, and this is why you
                    should always reset the Messenger before you create a unit test using it. To do this, we have a
                    static method called Messenger.Reset, that we should call in the beginning of each TestMethod. Let's
                    do that. And I'm going to add the same thing here in the first method as well. Now I can go back,
                    build the application, and run all the tests again. And this time, both tests pass, which is
                    correct. What we learned here are two things; first, we learned that when we use a Messenger, it is
                    better to unregister once you are done with an object. We saw earlier that the Messenger attempts to
                    keep only a weak reference to all the objects that register with it. This is a good protection, but
                    it is not totally foolproof. In case of doubt, you should always unregister the objects to avoid
                    unwanted behavior. In the case of the SelectableList, when the user navigates away from the Windows
                    Phone page, the developer should really unregister the items on the list in the OnNavigatingFrom
                    method. The second thing we learned is that when the unit test is using the Messenger, even behind
                    the cover, you should preventatively call the ResetMethod beforehand. Note that there is also a
                    ResetMethod available on the SimpleIoc component and the same rule applies. Make sure that you call
                    the ResetMethod before you test a piece of code that uses this component.

                    Unit Test: Creating and Using Test Services

                    For this next sample, we will see how we can use a SimpleIoc component of MVVM Light to mock a
                    DataService and to simulate a web service access in a unit test. Here I am starting with an MVVM
                    Light Application for Windows 8.1. The exact same thing can be done for WPF, Silverlight, Windows 8,
                    or Windows Phone, so it doesn't really matter which framework you use. The exact same principles
                    will work just fine. Let's review the application. I just created a new MVVM Light Windows Store
                    Application and then I changed a few things. First, I modified the DataItem and I added those two
                    properties, called Property1 and Property2. Then, in the DataService implementation, I added code
                    that we already saw before. It is getting the json file from my web server, deserializes it into a
                    DataItem, and returns it. Note that this code is asynchronous, like every web service code in
                    Windows Store, Windows Phone, etc. Let's open the MainViewModel now. Here in the MainViewModel, I
                    barely modified the default code that we studied in the previous module. So here we have the
                    NavigateCommand, which is going to navigate to the second page, and down here we have the
                    WelcomeTitle property, just like before. Here in the constructor, I call the Initialize method,
                    which is defined further below, and here I modify the default Initialize method slightly in order to
                    get the DataItem from the DataService, and then to set the WelcomeTitle based on this value. If we
                    want to test this MainViewModel with a unit test, we have a couple of challenges. First, the
                    asynchronous operation, which fetches a json file and turns it into an object, is hard to test. When
                    we test the MainViewModel, we don't really need to test the service operation itself. That can be
                    left to the team who implements a DataService class. For us, we can use a simulation of the
                    DataService, since the focus of our test is really on the ViewModel itself. The second challenge is
                    testing the navigation. The application's NavigationService will perform an actual navigation to a
                    different page, which we cannot, of course, use in a unit test. So here, too, we will need to use a
                    simulation. This will allow us to test this thing, which is critical to us, which is that the
                    RelayCommand is correctly implemented and does indeed call the NavigationService with the correct
                    arguments. So how do we do that? Well first I created a new UnitTest Application up here. Like
                    before, I added a reference to MVVM Light, which I did using NuGet. Then I also added another
                    reference, this time to the application that we want to test. This will give us access to the
                    MainViewModel, which is a TestObject. Let's open the UnitTest class here, and I'm going to implement
                    the first TestMethod. In order to create a new MainViewModel, if we check the constructor here, we
                    see that the MainViewModel requires an instance of IDataService and also an instance of
                    INavigationService, but we said we want to simulate those objects, so let's create two Test classes
                    here. Let's create the first class, the TestNavigationService. Here, I will implement the
                    INavigationService interface using ReSharper. Notice that I have, here, the CurrentPageType, which
                    exposes a property. And if I go down here, I have the Navigate method. I can test that the Navigate
                    method has been called correctly, by saving the new page type inside the CurrentPageType. Now I can
                    create the second test service class, which is a TestDataService. Here, too, I need to implement the
                    methods. There is only one method here. This TestDataService needs a little bit of infrastructure,
                    let's add this. And then I can easily implement the GetData method, like this. So what is happening
                    here? Well first I will call the Initialize method, which is going to allow me to Save the value of
                    Property1 and Property2. And then when I call GetData, I'm going to return a new DataItem with those
                    well-known properties, and then I'm going to be able to Assert that the correct values are passed
                    back to me. Now with those two Test services, I can implement my TestMethod, so let's go back to the
                    UnitTest class and I'm going to implement the TestMethod1 here. First, I'm going to create a
                    TestNavigationService and a TestDataService. Then I'm going to Initialize the TestDataService with
                    some known values. And finally, I'm going to create a new MainViewModel with those two well-known
                    DataServices. And then I'm going to Assert that the WelcomeTitle property has been set, according to
                    the format that we want to use. So here this is quite a simple test, but nonetheless it is using the
                    TestNavigationService and the TestDataService, which are needed in order to build the MainViewModel.

                    Unit Test: Testing the Navigation and the PropertyChanged

                    Let's create a new UnitTest, this time to test a NavigateCommand. So first, just like before, I add
                    a new UnitTest method, and here I create a new TestNavigationService and a new TestDataService.
                    Then, using those two objects, I'm going to create a new MainViewModel, which is my TestObject. Now
                    I'm going to execute the NavigateCommand. Here, I call Execute with a null parameter. And then I can
                    Assert that inside the TestNavigationService, the CurrentPageType is now set to the type of second
                    page. What we test here is that the NavigateCommand has been executed properly and that it calls the
                    NavigationService. Of course, the MainViewModel doesn't know that the Navigation has not actually
                    been executed; it doesn't matter, because the MainViewModel is just using an INavigationService. The
                    last test I will implement here is showing how you can test if an event was raised. For MVVM, we
                    typically want the PropertyChanged event to be raised when an observable property changes. So let's
                    test that for the WelcomeTitle property of the MainViewModel. First I'm going to create the new
                    TestMethod here; let's call that TestWelcomeTitle. Just like before, I create a new
                    TestNavigationService, a new TestDataService, and then I create the new MainViewModel, which is a
                    TestObject. What we will do then is handle the PropertyChanged event of the TestObject. We can do
                    that with a local event handler here defined as a lambda expression. When the event is raised, the
                    code will be executed and set the local variable accordingly. Then we can test the values with
                    Asserts. First, we Assert that the value is false, before the property is changed. Then we assign a
                    new string value to the WelcomeTitle property. And finally here, we test that the event has been
                    raised properly by asserting that the local value is set to true. Now we can run all the tests from
                    the Test Explorer window. Like before, we need to build the application first, and then let's select
                    here â€˜Run All'. And after a short delay, we see that the three tests are successful. If at a later
                    time the team was to modify the MainViewModel and to break these features, the unit test would
                    immediately show this, which is very valuable for the team. Unit tests are typically small and each
                    TestMethod tests one specific aspect of the code. Here, we succeeded in testing three separate
                    features of the MainViewModel by creating some known test implementations of the services. Because
                    of the INavigation and IDataService interfaces, the MainViewModel does not know or care how these
                    services are implemented, but it only knows what they do. Thanks to the Dependency Injection
                    provided by SimpleIoc, the RelayCommand, the PropertyChanged implementation, and all the decoupled
                    techniques that we saw in this course, we can also quite easily improve the testability of our
                    application, and by the same process, we improve its stability and its maintainability over time.

                    Summary and Conclusion

                    This last module of the MVVM Light reference course was rich in samples. We started by building a
                    plug-in based application in Windows Presentation Foundation. We saw how such an application is
                    typically constructed, with a Contracts assembly that has the interfaces needed for the plug-ins to
                    be located and built, and a Bootstrapper that loads the DLLs from a known folder and explores them
                    to find the plug-ins that will be placed in the UI. Then we saw how various components of MVVM Light
                    can be used to breach the decoupled elements. For example, the Messenger can send messages to all
                    the loaded plugins, whatever the number. The SimpleIoc can make services accessible, even though
                    they are not implemented in the same assembly. Databinding can be used from a plugin to a
                    MainViewModel for data and commands, etc. Plugins are the most decoupled way to build an
                    application. Many of the principles we saw in the Model-View-ViewModel Pattern apply to plugin-based
                    applications even more. And MVVM Light's components help to build these application too. In a second
                    sample, we built a well-known user experience in Windows Phone, where a list's items get expanded
                    when they are tapped on the side. This allows multiple selection of these items with checkboxes. If
                    all items get unselected, the list collapses back into place. If the list is based on MVVM and made
                    of ItemViewModels, the experience can be a little bit tricky to realize in the UI layer, unless we
                    take advantage of components, such as the Messenger. In this sample, we saw how to build this
                    experience from scratch. Finally, we saw a few examples and tips on building unit tests for your
                    ViewModels. We saw that some of the MVVM Light's objects can have a state from previous unit tests,
                    and that you should reset them. We also saw techniques to create test services, such as a
                    DataService or a NavigationService, with well-known behaviors that can be asserted, or to attach to
                    the PropertyChanged event to test if a property changes as expected. Hopefully, these examples,
                    combined with all the other samples that we saw throughout the course, will give you a good idea of
                    how you can take advantage of the MVVM Light Toolkit, to build applications of all sizes and
                    purposes. MVVM Light is relatively easy to get started with if you already know XAML, because it
                    promotes the core techniques that the XAML teams imagined. I want to finish this course by giving
                    you a few resources that can be useful as you continue your learning. First, here is MVVM Light's
                    homepage. This is a starting point for any exploration. Here is a place where you can see the code,
                    get new versions of the installers, see discussions and known issues; it's all there on codeplex.
                    Then, my blog with the MVVM category, where I write articles and give news about the MVVM Light
                    Toolkit's development. If you want to learn more about the specific components, this is probably a
                    good place to check. In case you are not totally up-to-date with the Model-View-ViewModel Pattern
                    yet, or if you want a refresher, these videos should help. They present MVVM techniques from the
                    ground up. Also, make sure to check Pluralsight's own videos talking about MVVM. For technical
                    support, I recommend checking Stackoverflow, where many questions have been answered already. Make
                    sure to tag your question with the mvvm-light's tag. There is a great team there, very eager to
                    answer more questions. And finally, you are welcome to chat with me on Twitter. I am always happy to
                    get messages from MVVM Light users, and I try my best to answer questions if I can. The MVVM Light
                    community is full of very constructive people and it is a great, great pleasure to engage with all
                    of you guys. MVVM Light got an incredible success in the past few years, with more than 300,000
                    downloads. And I am convinced that it is in great part because it is not too ambitious, but it tries
                    to stick to the basics. It actively promotes the same techniques and tools that the XAML teams have
                    imagined, so you don't have to learn everything from scratch again. It also allows you to use the
                    same techniques and to reuse code between the XAML platforms, which gives you a head start. This all
                    contributes to its incredible success, with a large number of applications based on it in WPF,
                    Windows Phone, Windows Store, and even Xbox. And hopefully for you, too, in the future. I tried to
                    show examples in all the popular XAML platforms, but in the end the techniques used are the same,
                    and if you get started in one of them, you will be able to pick up another platform very easily.
                    Because of its affinity with XAML, MVVM Light gives you a great design time experience, which is a
                    huge advantage in today's world, where the user experience is so important for your apps. And it
                    also improves the testability of your applications for more consistency and a better
                    maintainability. In conclusion, I hope that this course has been helpful for you all. It was a huge
                    undertaking and I am proud to finally have a great platform at Pluralsight to help all MVVM Light
                    users to learn how to use this Toolkit. I am also very eager to hear your feedback and to create
                    more courses showing advanced techniques with the MVVM Light Toolkit. Thank you, and happy coding!

