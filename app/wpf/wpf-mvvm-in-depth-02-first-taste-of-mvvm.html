<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>First Taste of MVVM</h2>
            </div>
            <div class="panel-body">
                <h2>Introduction</h2>
                <p>Welcome back to the second module of WPF MVVM in Depth. In this module I want to give you a quick
                    exposure or taste of how using MVVM changes some coding patterns for a simple input screen in WPF
                    application that you may already be used to.
                </p>
                <p>I'll do this by stepping through three variants of the same simple application in demos.</p>
                <ul>
                    <li>The first will have no MVVM nor data binding in it.</li>
                    <li>The second will at least leverage data binding but have no MVVM.</li>
                    <li>The third will evolve into showing the same view with MVVM and a quick look at some of the
                        communication between View and ViewModel that we'll get into in more detail later in the course.
                    </li>
                </ul>
                <h2>Async in MVVM</h2>
                <p>
                    Before we jump into the demos for this module I want to touch quickly on the concept of async. More
                    and more client applications need to deal with with Async and parallelism to provide a good user
                    experience. No longer is it acceptable to just put a spinning cursor in the users face and make it
                    stop responding to input every time the app goes and does some fairly long lasting thing like a
                    service call, computation or query.
                </p>
                <p>
                    In .Net we now have task based async as a pattern for how to deal with these things. For MVVM this
                    means that the ViewModel is often the initiator of calls that can take a long time in the big scheme
                    of computation. Those calls should be made async to keep the UI responsive. As a result often the
                    methods you expose on a client services layer should be async themselves because they will be
                    calling async methods to get the real work done. So you will see in all my demos that the client
                    services expose async methods based on tasks for doing the data access for the demo. This is done so
                    that the same repository interface exposed to the ViewModel could also be used even if the data
                    access was done via service calls. All the nuances of how async works, why you use it, and how you
                    use it go way beyond what I have time computation. These are the types of calls that should be made
                    async to keep the UI responsive. to cover in this course.
                </p>
                <p>For more info on async and await checkout Pause and Play with Await and the TPL Async course by Ian
                    Griffiths from Pluralsight.
                </p>
                <h2>Demo: Simple View with No MVVM or Data Binding</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\2WPFMVVMInDepth\ZzaDashboard-NoDataBinding</p>
                <p>
                    In this first demo we're going to start with a very simple app that does not do any MVVM nor any
                    data binding. First let's see it running so you can visualize what we're going to build up to:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-001.png"/>
                <p>This terribly unsophisticated app loads up some data at the beginning, puts it into a data entry
                    form, we could then go in and edit any of those fields and click on Save to Save the changes back
                    down to the database.
                </p>
                <p>Now let's talk about the structure of this app. The ZzeDashboard here is the WPF application project
                    itself:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-002.png"/>
                <p>Now the Zza comes from the fact that the sample data that I'll be using throughout the course is
                    based on a pizza ordering domain. So there is a database with tables for Customers, Products, and
                    Orders etc. There is a Data Layer (Zza.Data) which is pre-populated using Entity Framework DbContext
                    and a set of Model objects including Customers, Products, and Orders etc.
                </p>
                <p>
                    In addition to the raw data access in Zza.Data in the Client Services layer you can see we have two
                    repositories - a Customers repository and an Orders repository:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-003.png"/>
                <p>And if you look at the methods on these repositories they return Tasks for their invocation so these
                    are setup for doing the Task based Async of .Net using the async and await keywords.
                </p>
                <p>They are also Interface based in the vein of testability of MVVM. The idea is that your ViewModels
                    should only depend on the interface of their dependencies and have a substitution path so that you
                    can pass in mock objects that implement that same interface for unit testing purposes.
                </p>
                <p>The implementation of these repositories is basic CRUD data access through Entity Framework</p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-004.png"/>
                <p>We have a DbContext, we're doing queries with the ToListAsync to get the Task based Async, we're
                    doing adds and SaveChanges
                </p>
                <p>The key thing is that we have repositories that expose a Task based interface for the ViewModel
                    consumption.
                </p>
                <p>Now in terms of the functional code for the very simple screen that you saw. We have a MainWindow
                    that has an instance of a User Control in it:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-005.png"/>
                <p>For demo purposes here we're hard coding up a CustomerId that we're loading from the database.
                    Obviously in a real app you'd have to have some navigation or selection mechanism to pass that as
                    context into the View. We'll see how that works later with MVVM in other demos.
                </p>
                <p>The View implementation is down in this Customers folder:</p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-006.png"/>
                <p>It's really just a simple user control with some layout using a grid:</p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-007.png"/>
                <p>And then some inputs that have Labels and TextBoxes and you can see each of the inputs has a name to
                    it:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-008.png"/>
                <p>Likewise, our Save Button down at the bottom has a Click handler, so it's traditional WPF User
                    Control development where you have to put all the support in the code-behind of the User Control.
                    Here you can see we are newing up an instance of the repository:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-009.png"/>
                <p>And when the Loaded event fires we go out and get our Customer asynchronously:</p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-010.png"/>
                <p>Notice the async and await keywords here. Because this returns a Task you can await on that Task and
                    the execution of this method will be sequential from the code's declaration perspective but this
                    method:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-011.png"/>
                <p>but this method will go and potentially execute on a separate thread and then return the value back
                    on to the UI thread since that's where it was called from. So it makes it so all the execution
                    within the context of the View or the ViewModel stays on the UI thread.
                </p>
                <p>Now, if you don't use data binding, you can see it gets very mundane. You have to go and grab
                    discrete values out of properties on your model objects and stuff them into properties on individual
                    elements that you're referencing by name here in the code-behind of your view:
                </p>
                <img src="app/wpf/images/wpfmvvmindepth/Fig02-012.png"/>
                <p>And then when you go to save you have to pull those discrete values out, put them back on the model
                    object and then you can go ahead an try to persist with that model object or call some business
                    rules, do validation, whatever's appropriate. So you get this kind of grundgy push pull code that
                    you have to do without data binding. In the next demo we'll quickly see how this evolves by using
                    data binding.
                </p>
                <h2>Demo: Simple View with Data Binding</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\2WPFMVVMInDepth\ZzaDashboard-DataBindingNoMVVM</p>
                <p>
                    In this next variant     provides the same functionality but implements data-binding to
                    clean up the code a
                    bit. Now the individual input controls are using Two-way databinding where they bind to their
                    DataContext and expose that DataContext to expose a LastName, FirstName and Phone property. The Save
                    button is just using a click handler to get to an OnSave() method in the code-behind.
                </p>
                <p>
                    The code-behind is somewhat cleaner than the previous example. In the OnLoaded method we still call
                    GetCustomerAsync from the repository layer but then we can just push that to the DataContext:
                </p>
                <pre><code class="cs hljs">DataContext = _customer;</code></pre>
                <p>
                    The individual bindings in the View then have two-way data-binding against the properties exposed on
                    the Model object. Two-way databinding means any changes made by the user get written directly into
                    that object. So, when it is time to Save we don’t have to gather any values from the input controls
                    (as we did in the previous example) because the data has already been transferred into that bound
                    model object.
                </p>
                <h2>Demo: Simple View Transformed to MVVM</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\2WPFMVVMInDepth\ZzaDashboard-SimpleMVVM</p>
                <p>Now we want to move relevant code out of the code-behind of the View. We need to break up our View
                    into a View and ViewModel.
                </p>
                <p>
                    Firstly, in MainWindow.xaml we are still placing an instance of our View (CustomerEditView) into the
                    container. We have removed the Customer Id property as the data manipulation will be at the
                    ViewModel level.
                </p>
                <p>
                    In CustomerEditView.xaml the Loaded event has been removed. In terms of MVVM we are newing up an
                    instance of our CustomerEditViewModel in the XAML parsing process. The individual data bindings
                    reference Customer.FirstName etc. We are expecting our ViewModel to expose a single object called
                    Customer.
                </p>
                <p>The Save button no longer performs click handling into the code behind. Instead it uses a Command
                    object. So the Command property is bound to another property exposed by our ViewModel called
                    SaveCommand. We expect that to be an ICommand object. It will be invoked whenever the button is
                    clicked. It can also be used to enable and disable the button.
                </p>
                <p>At the top of the CustomerEditView.xaml file we define a Behaviour. It uses a behaviour from the
                    Blend SDK called CallMethodAction which is able to call a method on some object. In this scenario,
                    we want to handle the Loaded event and despatch it as a method call invocation against a method
                    named LoadCustomer which is on our ViewModel. The binding specified in the TargetObject:
                </p>
                <pre><code class="cs hljs">“{Binding}”</code></pre>
                <p>Gives you a reference to the whole DataContext object or ViewModel.</p>
                <figure>

                    <img src="app/wpf/images/wpfmvvmindepth//Fig02-01.png"/>
                    <figcaption>Fig 02-01</figcaption>
                </figure>
                <p>
                    The ViewModel’s main job is to expose data. We are implementing the INotifyPropertyChanged event
                    because we are not going to set that Customer until our LoadCustomer method (this is being called
                    from the Loaded event) gets invoked. By that point construction is already done, the XAML parsing is
                    done, all the Bindings have been evaluated so we need to be able to signal to the View that it
                    should refresh its data binding. That happens by firing the PropertyChanged event which is part of
                    the INotifyPropertyChanged interface.
                </p>
                <p>Next we can see our SaveCommand property that we exposed publicly and bound to:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig02-02.png"/>
                    <figcaption>Fig 02-02</figcaption>
                </figure>
                <p>That gets hooked up in the Constructor which points it to the actual handling method itself (OnSave).
                </p>
                <p>Note that both the OnSave() and LoadCustomer() methods use task based async with the async/await
                    keywords.
                </p>
                <h2>Summary</h2>
                <p>
                    Data binding really lays the groundwork for MVVM. MVVM moves the data management interaction logic
                    into the ViewModel. View-First construction (where the ViewModel is constructed in the XAML through
                    the mark-up) works out fine when you have static child Views inside a container.
                </p>
            </div>
        </div>
    </div>
</div>