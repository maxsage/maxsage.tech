<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Applied MVVM Part 2 – Validation and Dependency Injection</h2>
            </div>
            <div class="panel-body">
                <h2>Overview</h2>
                <p>
                    In this final module we continue to build out use cases surrounding Customers in our Pizza Order Management Application. This will include
                    fleshing out some data entry for adding and editing Customers by leveraging the Scaffolding of data-centric Views that is available in
                    Visual Studio. We also look at validation in the context of MVVM.
                </p>
                <p>
                    When ViewModels take dependencies on client services you will want to make sure those dependencies are loosely coupled. We will cover
                    dependency injection.
                </p>
                <p>Finally, we will cover some of the toolkits and frameworks that can assist when writing applications that adhere to the MVVM pattern.</p>
                <h2>Visual Studio Designer and Data Sources</h2>
                <p>
                    Now we will implement add and edit Customer use cases. We will use the Visual Studio Data Sources and Designer Windows. These Visual Studio
                    features make it very easy to:
                </p>
                <ul>
                    <li>Quickly scaffold data bound forms</li>
                </ul>
                <p>The downside is that the auto generated code does not adhere to the MVVM pattern:</p>
                <ul>
                    <li>
                        The generated code makes the assumption that you will be hooking things up in the XAML's code behind file.
                    </li>
                </ul>
                <p>The upside is:</p>
                <ul>
                    <li>It is fairly straightforward to morph the code into something more MVVM friendly.</li>
                </ul>
                <h2>Demo: Scaffolding an Edit View in Visual Studio</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\6WPFMVVMInDepth\ZzaDesktop-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\6WPFMVVMInDepth\ZzaDesktop-End</p>
                <p>
                    Previously we created the AddEditCustomerView.xaml and the navigation to it from the CustomerListView.xaml. We will now continue to flesh
                    out the AddEditCustomerView.xaml and put the data entry form together by leveraging the Data Sources window in Visual Studio which allows
                    you to drag and drop into the designer to scaffold out your data views.
                </p>
                <p>In Visual Studio switch to the Designer tab and select View>Other Windows>Data Sources:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-01.png"/>
                    <figcaption>Fig06-01</figcaption>
                </figure>
                <p>
                    Click Add New Datasource either with the hyperlink or the icon at the top left of the Data Sources window. From the next dialog select the
                    Object Data Source Type. Drill down to the Customers model object definition under Zza.Data> Zza.Data >Customers. From the Datasources
                    window click on the Dropdown list next to the Customer Datasource you just generated.
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-02.png"/>
                    <figcaption>Fig06-02</figcaption>
                </figure>
                <p>This drop allows you to select the output generated:</p>
                <ul>
                    <li>ListView</li>
                    <li>Details – in effect a data entry form</li>
                    <li>Select the Details option and expand the result. Now trim the fields down by selecting None from the drop down next to each field you
                        don’t require:
                    </li>
                </ul>
                <p>
                    Once you have done this, drag out the Customer object onto the Designer at which point Visual Studio will auto generate XAML for the
                    remaining fields (Email, FirstName, LastName and Phone):
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-03.png"/>
                    <figcaption>Fig06-03</figcaption>
                </figure>
                <p>
                    Remove the Loaded event handler and the associated method in the Code Behind. Also, remove the CollectionViewSource that was auto generated
                    in UserControl.Resources. Modify the DataContext of the Grid so it Binds to a Customer property that we will expose from our ViewModel:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-05.png"/>
                    <figcaption>Fig06-05</figcaption>
                </figure>
                <p>
                    When Visual Studio autogenerates the code it will put the properties in alphabetical order by Property Name. Re-arrange the property order
                    in the XAML to the following order (don’t forget to change the Grid numbers):
                </p>
                <ul>
                    <li>First Name</li>
                    <li>Last Name</li>
                    <li>Email</li>
                    <li>Phone</li>
                </ul>
                <p>Now when you run the application and Add or Edit a Customer you will see a data entry form.</p>
                <h2>Demo: Wrapping Model Objects</h2>
                <p>
                    So, now we have to expose a Customer as a property to satisfy the binding for our input fields. We won't expose the Customer Model object
                    directly. You can't guarantee that your model objects will be in the right shape to handle data-binding from your View and ViewModel. For
                    example, at a minimum you need an object that implements INotifyPropertyChanged fully (we can now do this by inheriting from BindableBase).
                    You might not have the option of changing the base class for your model objects.
                </p>
                <p>
                    One way round this dilemma is to create a Wrapped Model Object or a ViewModel Helper. Add a new class to the Customers folder called
                    SimpleEditableCustomer.cs that inherits from BindableBase and add the Id, FirstName, LastName, Email and Phone properties ensuring they
                    adhere to the pattern specified in BindableBase for setting the property:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-06.png"/>
                    <figcaption>Fig06-06</figcaption>
                </figure>
                <p>Back in AddEditCustomerViewModel we can now add a property of type SimpleEditableCustomer:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-07.png"/>
                    <figcaption>Fig06-07</figcaption>
                </figure>
                <p>We must populate this property when the Customer object is being passed in from the Parent ViewModel.</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-08.png"/>
                    <figcaption>Fig06-08</figcaption>
                </figure>
                <p>The two methods shown below achieve the following:</p>
                <ul>
                    <li>We take the customer and hold onto it so that when we save we do so to the right Customer</li>
                    <li>Create a new SimpleEditableCustomer object</li>
                    <li>Use the CopyCustomer helper method to copy the relevant values to the Customer.</li>
                </ul>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-09.png"/>
                    <figcaption>Fig06-09</figcaption>
                </figure>
                <p>
                    Not all the properties are set unless we are in EditMode (as you will see later this is to avoid triggering validation). We do need to at
                    least set the Id so that we have an Id for the Customer when we start editing. That Id, if you remember, was being set in
                    CustomerListViewModel when it was first firing the event that says it is time to add a new Customer.
                </p>
                <p>Now if you run the application, click on Customers, click on Edit for a Customer and you will see the data for our Customer in our data entry
                    form:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-10.png"/>
                    <figcaption>Fig06-10</figcaption>
                </figure>
                <p>If we navigate to add Customer we will be presented with a blank data entry from to start adding to:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-11.png"/>
                    <figcaption>Fig06-11</figcaption>
                </figure>
                <h2>Demo: Command Handling and Converters</h2>
                <p>Now we need to wire up the actual command handling to Add or Save an edited Customer as well as cancelling.</p>
                <p>
                    Modify the Grid so that it has two rows – one for the data entry fields, the other for the command buttons. The second row will host another
                    Grid which contains three buttons:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-12.png"/>
                    <figcaption>Fig06-12</figcaption>
                </figure>
                <p>
                    Only one of the buttons applies depending on which mode you are in (Edit/Add). So we need to hide or show one of these Buttons. One thing
                    that may immediately occur to you is why don’t we just have one Button and dynamically populate what the Button says from the ViewModel
                    based on our edit mode. While this may seem like a perfectly viable thing to do it brings up an important concept about MVVM and the
                    appropriate roles. If you remember from module 1 we said it was the Views job to dictate what the User sees on the screen and the ViewModel
                    just provides the interaction logic and the data manipulation to support that. If your ViewModel is trying to push text to drive the content
                    of a Button that violates those principles. What if, down the line, you bring a designer into the mix and he decides to use icons instead of
                    text – should you then be pushing Icons to the View from the ViewModel? No that’s pure presentation which is the Views job. So to protect
                    against that we will go ahead and put the two Buttons in there and we will drive their visibility from a property exposed on our ViewModel.
                </p>
                <p>
                    Then you may say - we can just expose a property of type Visibility (note Visibility) from our ViewModel and we can set the Visibility with
                    a Binding like this:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-13.png"/>
                    <figcaption>Fig06-13</figcaption>
                </figure>
                <p>
                    Once again, if you look at it from a separation of concerns perspective, Visibility is a pure presentation aspect which is a responsibility
                    of the View. You really shouldn’t be exposing Visibility properties from your ViewModel either.
                </p>
                <p>
                    So what's a poor MVVM developer to do? You can easily expose flags or booleans from your ViewModel that are decoupled from how that flag
                    drives the presentation. So we still want to bind the Visibility property but we want it to be driven by boolean flag.
                </p>
                <p>
                    There is a built in boolean to visibility converter that we could use but unfortunately that one doesn't let you negate what that flag means
                    and it also is hard coded to always use collapsed as the false state. As a result, we will create a CustomConverter to deal with these kinds
                    of situations.
                </p>
                <p>
                    We will drive the visibility of the buttons from a property exposed on the ViewModel. We will use a flag or Boolean that is decoupled from
                    how the flag drives the presentation by implementing a Custom Converter.
                </p>
                <p>
                    Add a new Folder called Converters and a class called NegatableBooleanToVisibilityConverter.cs. The class should inherit from
                    IValueConverter. The class exposes two additional properties that can be set when you create an instance of this class from your XAML
                    resource dictionary – one to set whether or not the Boolean flag is negated and the other to drive what the FalseVisibility is. Usually this
                    will be set to either Collapsed or Hidden – we will default to Collapsed:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-14.png"/>
                    <figcaption>Fig06-14</figcaption>
                </figure>
                <p>
                    In the Convert method there is a chunk of logic that combines the boolean flag that comes in from the binding and the negate flag to say
                    whether we should be Visible or whatever the Visibility of our false Visibility property is.
                </p>
                <p>Next in the AddEditCustomerView add a XAML namespace for the Converters child namespace:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-15.png"/>
                    <figcaption>Fig06-15</figcaption>
                </figure>
                <p>Define two instances of the VisibilityConverter (one where we set negate to true and one where we don’t):</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-16.png"/>
                    <figcaption>Fig06-16</figcaption>
                </figure>
                <p>
                    Now set the Visibility of the Buttons using our existing EditMode flag on our ViewModel and the appropriate instance of our
                    VisibilityConverter (VisConverter or NegVisConverter).
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-17.png"/>
                    <figcaption>Fig06-17</figcaption>
                </figure>
                <p>
                    When in Edit mode the Save Button should be Visible. With the Add Button we negate the meaning of that Edit Mode in order to hide the Add
                    Button when we are in EditMode.
                </p>
                <p>Now let's hook up Command Handling for our SaveCommand and our CancelCommand. In the ViewModel</p>
                <p>Declare the Commands as properties you can bind to:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-18.png"/>
                    <figcaption>Fig06-18</figcaption>
                </figure>
                <p>Construct our Commands in the ViewModel's Constructor pointing to the handling methods.</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-19.png"/>
                    <figcaption>Fig06-19</figcaption>
                </figure>
                <p>In the case of the SaveCommand we will be implementing validation so we had a CanSave handler.</p>
                <p>Stub out the OnCancel(), OnSave and CanSave() methods:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-20.png"/>
                    <figcaption>Fig06-20</figcaption>
                </figure>
                <p>
                    Similar to the CustomerListView we need to be able to signal our Parent ViewModel when we are done adding, editing or if we cancel. We do
                    this by adding an Event called Done which we can raise from the ViewModel and the Parent can handle to drive navigation:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-21.png"/>
                    <figcaption>Fig06-21</figcaption>
                </figure>
                <p>In the handling methods, for the moment, just call Done() in each method:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-22.png"/>
                    <figcaption>Fig06-22</figcaption>
                </figure>
                <p>Now in the Parent ViewModel (MainWindowViewModel in this case) add an event handler for the Done event:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-23.png"/>
                    <figcaption>Fig06-23</figcaption>
                </figure>
                <p>
                    Now add the handler method (NavToCustomerList()) that sets the current ViewModel back to the desired ViewModel when we are finished editing
                    (_customerListViewModel in this case):
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-24.png"/>
                    <figcaption>Fig06-24</figcaption>
                </figure>
                <p>
                    No if we run the application, click Customers, edit a selected Customer, make a change, click Save and the changes do not show up! This is
                    because we have not yet wired up any save handling. This will be covered in a later module.
                </p>
                <h2>Validation in MVVM</h2>
                <p>As soon as you start accepting data input from end users you need to consider validation.</p>

                <ul>
                    <li>Data entry forms can still leverage WPF data binding validation features.</li>
                    <li>Validation logic belongs in the Model or the ViewModel, not the View.</li>
                    <li>You can still use all of the ways of expressing validation that are supported by WPF databinding including:
                    </li>
                    <ul>
                        <li>Exceptions</li>
                        <li>IDataErrorInfo</li>
                        <li>INotifyDataErrorInfo</li>
                        <li>Validation Rules</li>
                    </ul>
                </ul>
                <p>
                    In general, the recommendation is to use INotifyDataErrorInfo. This was introduced to WPF in .Net 4.5 and it supports querying the object
                    for errors associated with properties. It fixes a couple of deficiencies that exist in all the other options:
                </p>
                <ul>
                    <li>It allows asynchronous validation</li>
                    <li>It allows properties to have more than one error associated with them</li>
                </ul>
                <h2>Demo: Adding Validation to an Input View</h2>
                <p>
                    Now we want to add validation support to our data entry form. Validation can be useful in a number of places in your application (Views,
                    ViewModels, Helper Objects). This makes it a good candidate for a common base class that we can inherit from in those scenarios. We want the
                    base class to support INotifyDataErrorInfo and we want it to integrate nicely so that the validation gets triggered when properties change.
                    Since we already have a base class for Property change handling (BindableBase) it’s a natural step to derive from that class.
                </p>
                <p>Create a new class called ValidateableBindableBase which inherits from BindableBase and implements INotifyDataErrorInfo:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-25.png"/>
                    <figcaption>Fig06-25</figcaption>
                </figure>
                <p>
                    After we stub the INotifyDataErrorInfo interface out you can see we have a GetErrors method that gets queried with the propertyName and is
                    expected to return a collection of errors for that property. We need to raise the ErrorsChanged event whenever new errors are added for a
                    property so that the binding can re-query and call this again. Then we have to have a boolean flag (HasErrors) that indicates whether there
                    are any errors on the class. It has to stay in sync with the state of the errors for all the properties on the object.
                </p>
                <p>
                    We can support this interface pretty simply by having a Dictionary as our underlying data store that has a key of string which is the
                    property name and a list of string per property which are the errors associated with that property:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-26.png"/>
                    <figcaption>Fig06-26</figcaption>
                </figure>
                <p>Now we just need to integrate the use of that Dictionary with the members down below:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-27.png"/>
                    <figcaption>Fig06-27</figcaption>
                </figure>
                <p>
                    We look into the Dictionary when we are queried for a property. If there are any errors in there return them as a list of strings. If not
                    return null. We drive the HasErrors flag by checking if there is anything in the Dictionary or not.
                </p>
                <p>Next we need to add a trigger to say when does this thing evaluate errors:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-28.png"/>
                    <figcaption>Fig06-28</figcaption>
                </figure>
                <p>
                    Since we are inhereting from BindableBase we can override the SetProperty method. We will still want to call the base so that the
                    INotifyPropertyChange handling occurrs but then we can call a method (which we are about to implement) to trigger the validation because a
                    property has been set.
                </p>
                <p>
                    No we could wire into this ValidateProperty method any number of approaches to validation but the most promonent approach nowadays is to use
                    Data Annotations:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-29.png"/>
                    <figcaption>Fig06-29</figcaption>
                </figure>
                <p>
                    Data Annotations contain the concept of a data validation context. You can point at a given object, say what member or property on that
                    object is being validated and then call a method (TryValidateProperty) to evaluate that object. When this method is called it will go to
                    that propety on that object and see if there is any Data Annotation attributes for validation. If so it will execute them and get their
                    results and return them in the results collection.
                </p>
                <p>
                    If there are any results we set those results as the errors for that property name. If there are not any errors then we can remove that
                    property from our Dictionary because there are no longer any errors associated with that property.
                </p>
                <p>Next we raise the ErrorsChanged event so that the binding can go and requery for errors.</p>
                <p>Back in our AddEditCustomerView we can look at the bindings that were generated from our earlier drag and drop operations:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-30.png"/>
                    <figcaption>Fig06-30</figcaption>
                </figure>
                <p>
                    We can see they already have Validation and Mode flags on them already. We will replace those flags with the minimum we need to support
                    NotifyDataErrorInfo:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-31.png"/>
                    <figcaption>Fig06-31</figcaption>
                </figure>
                <p>
                    On each one of the bindings we have added ValidatesOnNotifyDataErrors=True. That causes that binding to look when it first hooks up to its
                    data bound object, see if it implements INotifyDataErrorInfo and if so start querying it whenever it gets PropertyChanged notifications for
                    that property.
                </p>
                <p>If there are errors returned, then it will set certain Attached Properties on the associated Control such as:</p>
                <ul>
                    <li>Validation has errors</li>
                    <li>Validation errors collection</li>
                    <li>Raising Validation events</li>
                </ul>
                <p>Now we need to add some Data Annotation attributes to SimpleEditableCustomer we will make the FirstName and LastName required:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-32.png"/>
                    <figcaption>Fig06-32</figcaption>
                </figure>
                <p>Then we will use the built in Email and Phone annotations:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-33.png"/>
                    <figcaption>Fig06-33</figcaption>
                </figure>
                <p>Now we just need to make the base class ValidatableBindableBase instead of BindableBase:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-34.png"/>
                    <figcaption>Fig06-34</figcaption>
                </figure>
                <p>Now if we run the application, edit a Customer, try to Edit by clearing the FirstName field and we will see it gets red boxed:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-35.png"/>
                    <figcaption>Fig06-35</figcaption>
                </figure>
                <p>Unfortunately, WPF doesn’t have much in the way of validation indications so we will add two enhancements:</p>
                <ul>
                    <li>The Save Button should disable when a validation error occurs</li>
                    <li>We will add a ToolTip on the Control that will display the validation error</li>
                </ul>
                <p>To support disabling the SaveCommand we need to go to the AddEditCustomerViewModel and modify the SetCustomer method:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-36.png"/>
                    <figcaption>Fig06-36</figcaption>
                </figure>
                <p>
                    Now when the Customer is set we subscribe to the ErrorsChanged event and trigger the RaiseCanExecuteChanged. We will also put a check in to
                    unsubscribe an existing Customer to avoid memory leaks.
                </p>
                <p>Next we change our CanSave method to check the HasErrors flag of the Customer object:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-37.png"/>
                    <figcaption>Fig06-37</figcaption>
                </figure>
                <p>
                    Now run the application and edit a Customer. When you remove the FirstName text you will see the field is red boxed again and the Save
                    Button is disabled.
                </p>
                <p>Adding a ToolTip for the validation error is as simple as defining a style for it to the AddEditCustomerView:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-38.png"/>
                    <figcaption>Fig06-38</figcaption>
                </figure>
                <p>
                    In the style we will implicitly target the TextBox within this scope, we will setup a Style Trigger that watches the Attached Property
                    Validation.HasError. When that is set to true then we will set the ToolTip property of the TextBox. The Value Binding is a little complex
                    but you can see that it is basically going to the Validation.Errors Attached Property which is a Collection for this Control, moves to the
                    CurrentItem and gets the ErrorContent which is the string. It then uses that value to set the ToolTip.
                </p>
                <p>Now if we run the application and cause a validation error we will see a ToolTip when we hover over the invalid field:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-39.png"/>
                    <figcaption>Fig06-39</figcaption>
                </figure>
                <p>
                    Check out the WPF Data Binding in Depth Pluralsight course by Brian Noyes for examples of adding Icons to indicate validation errors and
                    other techniques.
                </p>
                <p>Now we need to wire up the Save handling. For that we need to discuss Dependency Injection.</p>
                <h2>Dependency Injection</h2>
                <p>
                    Now let’s talk a little bit about Dependency Injection. We have already seen that data binding decouples Views and ViewModels from each
                    other and allows them to communicate without knowing explicitly what is on the other end of the communication pipeline. Now we need
                    something similar to decouple or ViewModels from our Client Services. So far in the demos you have seen that we have hard coded the
                    construction of a Client Service or Customers repository and newing it up explicitly within the ViewModel and holding onto a reference to
                    it. That isn’t a bad thing if you are not worried about Unit Testing and if that is the only ViewModel that is going to use that Client
                    Service. As soon as you want to start having some shared state in your Client Services that multiple ViewModels see and as soon as you want
                    to write Unit Tests against your ViewModel logic that uses that Client Service you will have problems with how we have been structuring
                    things. The solution is to use Dependency Injection and Interfaces on our Services. Those will provide the decoupling we need and you will
                    see that we can easily wire things together using that.
                </p>
                <p>
                    When you start talking Dependency Injection the subject of containers usually comes up pretty quickly. You can do manual Dependency
                    Injection but that only gets you so far. Typically, you are going to want to use a container to help you out here.
                </p>
                <p>
                    Inversion of Control (IoC) and Dependency Injection (DI) are two design patterns that are closely related. A “Container” is a chunk of
                    infrastructure code that does both of those patterns for you. The IoC pattern is about delegating responsibility for construction and the
                    Dependency Injection pattern is about providing dependencies to an object that has already been constructed.
                </p>
                <p>They can both be treated as a two phase approach to constructing. When you use a container the container takes several responsibilities:</p>
                <ul>
                    <li>It constructs an object when asked. Instead of newing up objects yourself you will go to the container and ask it to produce an object
                        for you.
                    </li>
                    <li>As part of the process the container will determine what that object depends on. Depending on the container used it can do that based on
                        parameterized constructors, properties or methods.
                    </li>
                    <li>To provide those dependencies the container will then construct those dependencies and will inject them into the object being
                        constructed
                    </li>
                    <li>The dependencies being constructed may have dependencies of their own and so on. So the process is recursively repeated until an entire
                        object graph is built up from the object you asked for down through all its dependencies.
                    </li>
                </ul>
                <p>
                    A container can also handle different instancing patterns and produce singleton objects where it constructs them on the first try and then
                    just hands out a reference to them each other time some object takes a dependency on them.
                </p>
                <p>There are many Containers to choose from:</p>
                <ul>
                    <li>Unity</li>
                    <li>AutoFac</li>
                    <li>Ninject</li>
                    <li>StructureMap</li>
                </ul>
                <p>
                    Let’s take a look at how we can use Dependency Injection to break the coupling that we have between the ViewModels and the Client Services
                    at this point in our code.
                </p>
                <h2>Demo: Adding Dependency Injection for Client Services</h2>
                <p>
                    So in this demo we want to wire up the Save handling from our Add/Edit form and see how we can use Dependency Injection related to that. The
                    initial straightforward way to do the Save handling would be to drop into the AddEditCustomerViewModel and new up an instance of our
                    CustomersRepository.:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-40.png"/>
                    <figcaption>Fig06-40</figcaption>
                </figure>
                <p>
                    Then drop down to the OnSave handling method and call UpdateCustomer or AddCustomer methods of that repository. There are a couple of issues
                    with this approach:
                </p>
                <ul>
                    <li>Testability – this is a hard coded, not exposed, dependency that the AddEditCustomerViewModel now has. Any method that touches this
                        object is going to be really hard to Unit Test because it is going to actually try and go out to the database. We don’t want that in a
                        Unit Test environment. We want to be able to substitute a mock object.
                    </li>
                    <li>Another problem is that this ViewModel is newing up its own instance of the CustomersRepository and if you remember over in the
                        CustomerListViewModel it is newing up a different instance of the CustomersRepository. So the objects that get read in by those two can
                        be completely separate objects that really represent the same rows under the covers. When you are doing that kind of thing you really
                        want a Singleton model for that repository so that you are exposing shared state to the multiple ViewModels that are going to use it.
                        That is where Dependency Injection comes in.
                    </li>
                </ul>
                <p>The first thing we want to do is change the code in our ViewModel to take in a reference to an ICustomersRepository:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-41.png"/>
                    <figcaption>Fig06-41</figcaption>
                </figure>
                <p>
                    Now you can see this type is not coupled to the concrete type at all just the interface and provides a path for passing in a mock object in
                    a Unit Test environment. We can go and make a similar change to our CustomerListViewModel and now likewise our CustomerListViewModel just
                    takes in the interface reference and is no longer coupled to the concrete type.
                </p>
                <p>
                    For the above code to work we would need to move up to the parent ViewModel and pass that in. So we go to the MainWindowViewModel and new up
                    the instance of the CustomersRepository here:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-42.png"/>
                    <figcaption>Fig06-42</figcaption>
                </figure>
                <p>Then change the construction of those child ViewModels to pass it in through the constructor:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-43.png"/>
                    <figcaption>Fig06-43</figcaption>
                </figure>
                <p>
                    So this fixes the problem for our child ViewModels in that they get passed in the appropriate thing at runtime but can have an alternate
                    thing passed in when in a Unit Test environment and they are only coupled to the interface now.
                </p>
                <p>
                    However, now our parent type has been somewhat corrupted because it now depends on a concrete type that it doesn’t even use directly itself.
                    How do we fix that? That leads us to using a Container to do the resolution of all dependencies. We are going to use the Unity container.
                </p>
                <p>Firstly, get Unity from NuGet:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-44.png"/>
                    <figcaption>Fig06-44</figcaption>
                </figure>
                <p>
                    Now when using a container, you generally have a singleton model for the container itself so we will wire up a simple helper for the
                    singleton pattern here that we will call ContainerHelper. The ContainerHelper class exposes a singleton instance of an IUnityContainer
                    container through a static property. It can also be the place where you do your centralized registration of any types that you want the
                    container to be responsible for creating:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-45.png"/>
                    <figcaption>Fig06-45</figcaption>
                </figure>
                <p>
                    In the API of Unity what we do here is basically say whenever someone asks for an ICustomersRepository give them the CustomersRepository as
                    the concrete type. The ContainerControlledLifetimeManager indicates to Unity to make the type a singleton. So when someone tries to get an
                    ICustomersRepository from the Container it will new up a CustomersRepository and satisfy any dependencies it has. Any subsequent time it
                    will just return the reference to the singleton.
                </p>
                <p>To use this, we go back to MainWindowViewModel and add a namespace for the Unity namespace:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-46.png"/>
                    <figcaption>Fig06-46</figcaption>
                </figure>
                <p>Next we will change the way the child ViewModels are created so that they use the Container:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-47.png"/>
                    <figcaption>Fig06-47</figcaption>
                </figure>
                <p>
                    We use a Resolve method in Unity specifying the type that we want to create. When it goes to construct that object it will satisfy its
                    dependencies based on its parameterized constructor. So it will be able to construct and inject a singleton instance of
                    ICustomersRepository. Now this parent ViewModel doesn’t even have to know about this dependency so we can delete the line:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-48.png"/>
                    <figcaption>Fig06-48</figcaption>
                </figure>
                <p>
                    Now finally we can wire up the Save handling in our AddEditCustomerViewModel. So now when we call Save we will first copy the contents of
                    our editing Customer back into the original object that we held a reference to with another helper method called UpdateCustomer that pushes
                    and pulls the relevant properties:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-49.png"/>
                    <figcaption>Fig06-49</figcaption>
                </figure>
                <p>
                    You could use a tool like AutoMapper for doing this kind of thing. Then depending on our mode we either call UpdateCustomerAsync or
                    AddCustomerAsync on our repository. Finally, we signal that we are done. In a production environment we would add error handling in case
                    those methods threw exceptions.
                </p>
                <p>
                    Now if we run the application, select a customer and click Edit, change their name and click Save. You will see the change has been made
                    successfully. If you stop and restart the application, you will see the change persists.
                </p>
                <p>Now we have Dependency Injection and Validation wrapped up we will cover one more use case scenario – searching and filtering the Customer
                    list.
                </p>
                <h2>Demo: Searching and Filtering Data</h2>
                <p>
                    The one last use case that we will look at is searching the Customers list and filtering the list based on your search. Go to the
                    CustomerListView and take the Grid that we had at the top which contains the AddCustomer button and I will add a
                </p>
                <ul>
                    <li>A StackPanel that contains</li>
                    <ul>
                        <li>A Search Label</li>
                        <li>A TextBox to accept search criteria</li>
                        <li>An X Button to clear out the search criteria</li>
                    </ul>
                </ul>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-50.png"/>
                    <figcaption>Fig06-50</figcaption>
                </figure>
                <p>That means our ViewModel needs to support two new things:</p>
                <ul>
                    <li>A property called SearchInput that we want to be set every time a keystroke happens so we use the UpdateSourceTrigger on the binding and
                        set that to PropertyChanged
                    </li>
                    <li>We also need a ClearSearchCommand to clear out the search term</li>
                </ul>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-51.png"/>
                    <figcaption>Fig06-51</figcaption>
                </figure>
                <p>
                    In our CustomerListViewModel we define that SearchInput property so when the property gets set we need to trigger filtering of the Customers
                    that are being presented. That means we are going to need another Customer collection. One that contains all Customers and then the exposed
                    one that is data bound to that contains just the Customers that are to be presented at the current time. Once we have that and the
                    FilterCustomers gets called we are going to check and see if there is anything as a search term and if there is we will apply a Where clause
                    to check to see if the FullName property of the Customer contains our search term. We will use the results of that LINQ query to populate
                    our Customers property with the filtered list triggering a property change and therefore the screen will update.
                </p>
                <p>So we just need to add the _allCustomers collection and we need to populate that when we load our Customers:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-52.png"/>
                    <figcaption>Fig06-52</figcaption>
                </figure>
                <p>
                    We declare the list of _allCustomers, we can await and hold onto that and then we can do our initial population of the Customers property
                    with _allCustomers. Then we just need to support the ClearSearchCommand using the standard three steps for Command handling:
                </p>
                <p>Expose a property for the Command:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-53.png"/>
                    <figcaption>Fig06-53</figcaption>
                </figure>
                <p>Construct the Command and point it to its handling method:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-54.png"/>
                    <figcaption>Fig06-54</figcaption>
                </figure>
                <p>And define that handling method in this case nulling out the SearchInput:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig06-55.png"/>
                    <figcaption>Fig06-55</figcaption>
                </figure>
                <p>
                    Now if we run the application, go to the Customers view, put in a search term and you can see the list tailoring to your search criteria.
                    Clicking the clear Button will take you back to the full list of Customers.
                </p>
                <h2>MVVM Toolkits</h2>
                <p>
                    So before we wrap up this module and course let’s talk about some toolkits and frameworks that are out there that you can leverage so that
                    you don’t have to write a bunch of repetitive code to implement the MVVM pattern yourself.
                </p>
                <h3>Prism</h3>
                <p>
                    This was first developed by Microsoft Patterns and Practices. Currently this is an open source project of which Brian Noyes is one of the
                    authors.
                </p>
                <h3>MVVM Light</h3>
                <p>MVVM Light is developed by Laurent Bugnion and there is a Pluralsight course on MVVM Light.</p>
                <h3>Caliburn Micro</h3>
                <p>Another a small open source framework that helps you implement the MVVM pattern and also supports a number of things out of the box.</p>
                <h3>Prism</h3>
                <p>
                    Now we will go back to Prism and look at it in more depth. Prism has a number of things out of the box. It has a BindableBase class similar
                    to the one we implemented earlier in the course.
                </p>
                <p>
                    It has a flexible ViewModelLocator that has conventions to it but also lets you override those conventions and declaratively hook up your
                    Views and ViewModels in a loosely coupled way.
                </p>
                <p>
                    Modularity – the ability to break up your code into totally loosely coupled class libraries and parts and bring them together at runtime
                    into a cohesive whole for the end user while the code remains decoupled.
                </p>
                <p>
                    Prism also supports the notion of UI Composition and Regions. The ability to plug Views into Containers without the View that is doing the
                    plugging needing to have an explicit reference to the UI Container itself.
                </p>
                <p>
                    Prism has navigation features that layer on top of regions that give you things like forward and back navigation and the navigation stack
                    and allowing your ViewModels to participate in the navigation process directly.
                </p>
                <p>
                    Prism has Commands. So they have a Delegate Command that is very similar to the RelayCommand that we have been using throughout the course
                    except it’s got some extra robustness to protect you from memory leaks if you're Views and ViewModels have different lifetimes. There is
                    also a separate Command implementation called CompositeCommand that lets you do Commanding in a more loosely coupled way across components.
                </p>
                <p>
                    Finally, Prism has support for Pub/Sub Events. These are loosely coupled events where the publisher and subscriber can have different
                    lifetimes and do not have to have specific references to each other to communicate through events.
                </p>
                <p>Brian Lagunas, one of the co-authors of the Prism framework has written a number of Pluralsight courses on the subject.</p>
                <h2>Summary</h2>
                <p>
                    We have completed our journey through MVVM as a pattern. In this module we saw the Visual Studio Data Designer can quickly scaffold out your
                    data-centric Views but you can still wire them up easily in an MVVM fashion.
                </p>
                <p>
                    You saw the validation logic belongs on the Model or ViewModel properties but the good news is that in MVVM we are always binding to those
                    properties so it is very easy to setup the infrastructure for validation and reuse that across your ViewModel and Model objects.
                </p>
                <p>
                    We looked at Dependency Injection and saw that it makes it so that your ViewModels are only coupled to your Client Services via the
                    Interfaces that they implement and that you can use a Container to Dependency Inject those references at runtime for you.
                </p>
                <p>Finally, we talked about MVVM frameworks and Toolkits out there and you should look into these and use one to help you implement MVVM.</p>

                <script src="bundle.js"></script>
            </div>
        </div>
    </div>
</div>

