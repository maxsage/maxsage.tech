<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>The Extras</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>Welcome to Module 4 of the MVVM Light course. In the previous module, we talked about the core
                    components of MVVM Light, the ObservableObject, ViewModelBase, RelayCommand, Messenger, and the
                    DispatcherHelper.
                </p>
                <p>We'll start this module with a discussion of how Views are bound to their respective ViewModels, and
                    we'll discuss various strategies that we recommend using in MVVM Light applications. There are two
                    more components that I would like to study in this module; the SimpleIoc and the EventToCommand.
                    These two components are placed in a separate assembly called Extras.
                </p>
                <p>First we will start with an introduction to the Extras assembly, and why it is even there. Then, we
                    will have a detailed study of the SimpleIoc component, an IOC container that is well suited for MVVM
                    applications.
                </p>
                <p>Later, we will talk about the EventToCommand behavior and understand what behaviors are and what this
                    particular element does.
                </p>
                <p>At the end of this module, you will understand the standard structure of an MVVM Light application
                    and understand how the Views are bound to the ViewModels. You will also understand why MVVM Light
                    comes in two separate assemblies, and you will know how to use a SimpleIoc and the EventToCommand
                    components.
                </p>
                <h3>Setting the DataContext</h3>
                <p>At this point, I would like to take a moment to talk about the way that the ViewModel is data bound
                    to the Views in a typical MVVM application. First let's recapitulate what the DataContext is. It is,
                    in fact, a shortcut; it's a way to say, everything that happens here is in reference to this
                    DataContext, unless explicitly specified otherwise. So we don't need to write the fully-qualified
                    Binding expression, like we have here:
                </p>
                <figure>
<pre><code class="xml">&lt;TextBox
    Text="{Binding SearchQuery,
        Source={StaticResource Main},
        Mode=TwoWay}" /&gt;</code></pre>
                    <figcaption>Fig04-001</figcaption>
                </figure>
                <p>in different places in this document. Instead, we can define the DataContext; for example, here:</p>
                <figure>
<pre><code class="xml">&lt;Page.DataContext&gt;
	&lt;Binding Source="{StaticResource Main}" /&gt;
&lt;/Page.DataContext&gt;</code></pre>
                    <figcaption>Fig04-002</figcaption>
                </figure>
                <p>
                    directly in the XAML. And then we can have tighter XAML expressions, which is much more comfortable;
                    for example, here in the document:
                </p>
                <figure>
<pre><code class="xml">&lt;TextBox
	Text="{Binding Search, Mode=TwoWay}" /&gt;</code></pre>
                    <figcaption>Fig04-003</figcaption>
                </figure>
                <p>and here:</p>
                <figure>
<pre><code class="xml">&lt;Button
	Content="{Binding SearchText,
		Source={StaticResource Strings}}"
	Command="{Binding FindCommand}" /&gt;</code></pre>
                    <figcaption>Fig04-004</figcaption>
                </figure>
                <p>and here:</p>
                <figure>
<pre><code class="xml">&lt;ItemsControl
	ItemsSource="{Binding Results}" /&gt;</code></pre>
                    <figcaption>Fig04-005</figcaption>
                </figure>
                <p>Of course we can still use fully-qualified expressions; for example, here:</p>
                <figure>
<pre><code class="xml">&lt;Button
	Content="{Binding SearchText,
		Source={StaticResource Strings}}"
	Command="{Binding FindCommand}" /&gt;</code></pre>
                    <figcaption>Fig04-006</figcaption>
                </figure>
                <p>When we're referred to a property, defined in another resource named Strings.</p>
                <p>So in summary, the DataContext is really just a shortcut. It can be set in XAML, like in the previous
                    slide, which works great with visual designers, such as Blend or the Visual Studio Designer, because
                    these tools parse the XAML code when they render an element. So, of course, a DataContext is taken in
                    to account by the designer, and the built-in helpers take advantage of this knowledge.
                </p>
                <p>Sometimes, however, it is more convenient to set the DataContext in the code behind directly; for
                    example, in the Master-Detail scenario, if we pass an object to the DetailsPage, it is quite
                    frequent to set the DataContext to this object in the OnNavigatedTo method, such as shown here in
                    Windows 8:
                </p>
                <figure>
<pre><code class="csharp">protected override void OnNavigatedTo(NavigationEventArgs e)
{
	DataContext = e.Parameter as DetailsViewModel;
	base.OnNavigatedTo(e);
}</code></pre>
                    <figcaption>Fig04-007</figcaption>
                </figure>
                <p>These are the two main ways to set the DataContext, either in XAML through a resource or in the code
                    behind. One thing to consider is that when the DataContext is set in code behind and not in XAML,
                    the Visual Designer Tools do not run this code. In fact, they never run any code behind because,
                    like this, we avoid some issues, for example with animations or other things that are typically
                    triggered in this code.
                </p>
                <p>In the earlier demos, we saw the advantage of having Blend run some of the application's code, like
                    this we can create some design time data. If, however, if we set the DataContext in code behind, we
                    need to come up with another strategy to create the design time data.
                </p>
                <p>Thankfully the XAML Tooling Team thought of that and created a design time data context, which is
                    very convenient. Here is an example:
                </p>
                <figure>
<pre><code class="xml">&lt;Page x:Class="App1.MainPage"
	xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation
	xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
	xmlns:d=http://schemas.microsoft.com/expression/blend/2008
	xmlns:mc=http://schemas.openxmlformats.org/markup-compatibility/2006
	xmlns:app1="using:App1"
	mc:Ignorable="d"
	d:DataContext="{d:DesignInstance,
		Type=app1:DetailsViewModel,
		IsDesignTimeCreatable=True}"&gt;</code></pre>
                    <figcaption>Fig04-008</figcaption>
                </figure>
                <p>First, we declare an xmlns, pointing to the namespace in which the ViewModel is declared. We add
                    another xmlns used by Blend in the Visual Studio Designer, typically with a prefixed "d", like
                    design. This prefix is declared Ignorable. This indicates to any XAML parser that it should ignore
                    any attribute prefixed by "d"; however, the Visual Designers look for these "d" prefixes and will
                    use them for design time tasks. For example, here:
                </p>
                <figure>
<pre><code class="xml">d:DataContext="{d:DesignInstance,
	Type=app1:DetailsViewModel,
	IsDesignTimeCreatable=True}"&gt;</code></pre>
                    <figcaption>Fig04-009</figcaption>
                </figure>
                <p>the design time DataContext is set to an instance of the DetailsViewModel, which will be created at
                    design time.
                </p>
                <p>Right now the MainViewModel is defined as a global resource in App.xaml. This is not very satisfying,
                    because it forces the MainViewModel to be created as soon as the application starts, when the
                    corresponding XAML line is parsed. If we have a lot of ViewModels, it means that all of them will be
                    created when the application starts, which can slow down the starting time and is really not ideal.
                </p>
                <p>This is why MVVM Light proposes an additional degree of flexibility, with the addition of the
                    ViewModelLocator. The ViewModelLocator provides some additional flexibility to control the lifetime
                    of services and of ViewModels. In MVVM Light applications, we declare the ViewModelLocator in the
                    global resources in App.xaml.
                </p>
                <p>The ViewModelLocator declares the most important ViewModels of the application as public properties,
                    for example, here, the MainViewModel:
                </p>
                <figure>
<pre><code class="csharp">public class ViewModelLocator
{
	public MainViewModel Main
	{
		get;
		private set;
	}

	// ...
}</code></pre>
                    <figcaption>Fig04-010</figcaption>
                </figure>
                <p>so that it is easy to bind to them, for instance, using a visual tool such as Blend.</p>
                <p>Not all ViewModels are declared by the ViewModelLocator, however. It depends on how long they will be
                    alive, when they are created, and so on. In MVVM Light, here is how the ViewModelLocator is declared
                    in the App.xaml file:
                </p>
                <figure>
<pre><code class="xml">&lt;Application.Resources&gt;
	&lt;vm:ViewModelLocator x:Key="Locator" /&gt;
&lt;/Application.Resources&gt;
</code></pre>
                    <figcaption>Fig04-011</figcaption>
                </figure>
                <p>and here is how you can bind to the Main property of type MainViewModel in the view:</p>
                <figure>
<pre><code class="xml">DataContext="{Binding Main,
	Source={StaticResource Locator}}"&gt;</code></pre>
                    <figcaption>Fig04-012</figcaption>
                </figure>
                <p>Of course, if you have multiple ViewModels, you will have multiple properties with different names.
                </p>
                <h3>Binding to a ViewModel (Demos)</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-001" type="text" value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\view-viewmodel\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-001">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-002" type="text" value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\view-viewmodel\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-002">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Let's implement these changes in our application. Again, I want to stress that this application is a
                    Windows Phone app, that the toolkit and all the implementation works exactly the same on every other
                    XAML framework, such as WPF, Silverlight or Windows 8.
                </p>
                <p>We will use a NavigationService, which is closer from the one we use in Production Windows Phone
                    applications. It has one more method, which we add in INavigationService:
                </p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Helpers
{
	public interface INavigationService
	{
		void GoBack();
		void NavigateTo(Uri uri);
		void NavigateTo(Uri uri, object state);
	}
}</code></pre>
                    <figcaption>Fig04-013</figcaption>
                </figure>
                <p>This method allows to navigate to a URI and pass an object, a user state, to the page that we
                    navigate to. Let's remove the primitive NavigationService we were using until now. And replace it
                    with another one, which implements the new method:
                </p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Helpers
{
    public class NavigationService : INavigationService
    {
        private const string QueryUriKey = "userstate";

        private static Dictionary&lt;string, object&gt; _userStates;
        private PhoneApplicationFrame _mainFrame;

        public void GoBack()
        {
            if (EnsureMainFrame()
                && _mainFrame.CanGoBack)
            {
                _mainFrame.GoBack();
            }
        }

        public void NavigateTo(Uri pageUri)
        {
            if (EnsureMainFrame())
            {
                _mainFrame.Navigate(pageUri);
            }
        }
</code></pre>
                    <figcaption>Fig04-014</figcaption>
                </figure>
                <p>This NavigationService implements the new NavigateTo method, it will save the state, and it also
                    provides a new method, GetAndRemoveState:
                </p>
                <figure>
<pre><code class="csharp">public static object GetAndRemoveState(IDictionary&lt;string, string&gt; query)
        {
            lock (_userStates)
            {
                if (query.ContainsKey(QueryUriKey)
                    && _userStates.ContainsKey(query[QueryUriKey]))
                {
                    object state = _userStates[query[QueryUriKey]];
                    _userStates.Remove(query[QueryUriKey]);
                    return state;
                }

                return null;
            }
        }</code></pre>
                    <figcaption>Fig04-015</figcaption>
                </figure>
                <p>which is static and that every page can use to easily retrieve the state when it is navigated to.</p>
                <p>
                    Then we will take care of the ViewModelLocator. Let's add this class in the ViewModel folder. This
                    is a plain object, which we will make public, and it exposes one public property, which is the
                    MainViewModel:
                </p>
                <figure>
<pre><code class="csharp">public class ViewModelLocator
{
    public MainViewModel Main
    {
        get;
        private set;
    }
}</code></pre>
                    <figcaption>Fig04-016</figcaption>
                </figure>
                <p>This property is exposed for data binding purposes.</p>
                <p> Then, let's add a constructor, which will take care of creating all the services, as well as a
                    MainViewModel:
                </p>
                <figure>
<pre><code class="csharp">public ViewModelLocator()
{
    IFriendsService friendsService;

    if (ViewModelBase.IsInDesignModeStatic)
    {
        friendsService = new DesignFriendsService();
    }
    else
    {
        friendsService = new FriendsService();
    }

    IDialogService dialogService = new DialogService();
    INavigationService navigationService = new NavigationService();

    Main = new MainViewModel(friendsService, dialogService, navigationService);
}</code></pre>
                    <figcaption>Fig04-017</figcaption>
                </figure>
                <p>As you can see here:</p>
                <figure>
<pre><code class="csharp">if (ViewModelBase.IsInDesignModeStatic)
{
    friendsService = new DesignFriendsService();
}
else
{
    friendsService = new FriendsService();
}</code></pre>
                    <figcaption>Fig04-018</figcaption>
                </figure>
                <p>we use a DesignMode detection to create the correct FriendsService, either the DesignFriendsService
                    or the runtime FriendsService here:
                </p>
                <figure>
<pre><code class="csharp">if (ViewModelBase.IsInDesignModeStatic)
{
    friendsService = new DesignFriendsService();
}
else
{
    friendsService = new FriendsService();
}</code></pre>
                    <figcaption>Fig04-019</figcaption>
                </figure>
                <p>We also create a dialogService, a navigationService, and we pass those to the MainViewModel
                    constructor:
                </p>
                <figure>
<pre><code class="csharp">IDialogService dialogService = new DialogService();
INavigationService navigationService = new NavigationService();

Main = new MainViewModel(friendsService, dialogService, navigationService);</code></pre>
                    <figcaption>Fig04-020</figcaption>
                </figure>

                <p>The ViewModelLocator should be exposed as a global resource in App.xaml, let's open this file. And
                    here we see the MainViewModel that we were using until now
                </p>
                <figure>
                    <pre><code class="xml">&lt;vm:MainViewModel x:Key="Main" /&gt;</code></pre>
                    <figcaption>Fig04-021</figcaption>
                </figure>
                <p>We can replace this with ViewModelLocator, and change the Key for clarity to name it Locator:</p>
                <figure>
                    <pre><code class="xml">&lt;vm:ViewModelLocator x:Key="Locator" /&gt;</code></pre>
                    <figcaption>Fig04-022</figcaption>
                </figure>
                <p>
                    As we mentioned, this is an additional level of flexibility in the creation and lifetime management
                    of the services and of the ViewModels. For convenience we can add a static property in the
                    ViewModelLocator class:
                </p>
                <figure>
<pre><code class="csharp">public static ViewModelLocator Instance
{
    get
    {
        return Application.Current.Resources["Locator"] as ViewModelLocator;
    }
}</code></pre>
                    <figcaption>Fig04-023</figcaption>
                </figure>
                <p>which retrieves this instance from the application's resources and exposes it to other objects. Then
                    let's take a look at the MainViewModel. The default constructors that we had created were here as a
                    kind of a hack to allow the creation of the MainViewModel in XAML. However, now we don't need this
                    anymore because the creation is taken care of by the ViewModelLocator, so we can simply remove this
                    default constructor:
                </p>
                <figure>
<pre><code class="csharp">  public MainViewModel()
            : this(
                (DesignerProperties.IsInDesignTool
                    ? (IFriendsService)new Design.DesignFriendsService()
                    : new FriendsService()),
                new DialogService(),
                new NavigationService())
        {
#if DEBUG
            if (DesignerProperties.IsInDesignTool)
            {
                Refresh();
                SelectedFriend = Friends[0];
            }
#endif
        }
    }
}</code></pre>
                    <figcaption>Fig04-024</figcaption>
                </figure>
                <p>As such, we have delegated the creation of the MainViewModel to another object, the ViewModelLocator,
                    thus implementing a common design pattern, named Inversion of Control, or IoC.
                </p>
                <p>For design time, let's just add the call to the Refresh method in the unit constructors that we have
                    now:
                </p>
                <figure>
<pre><code class="csharp">#if DEBUG
            if (IsInDesignMode)
            {
                Refresh();
            }
#endif</code></pre>
                    <figcaption>Fig04-025</figcaption>
                </figure>
                <p>Then, we will remove the SelectedFriend property:</p>
                <figure>
<pre><code class="csharp">public Friend SelectedFriend
{
    get
    {
        return _selectedFriend;
    }

    set
    {
        Set(() => SelectedFriend, ref _selectedFriend, value);
    }
}
</code></pre>
                    <figcaption>Fig04-026</figcaption>
                </figure>
                <p>While it is not wrong to have the MainViewModel hold a SelectedFriend, it is cleaner to pass this
                    object to each page and to let the page set its own DataContext in code. This way, each page is
                    responsible for its own state. Also, this minimizes the risks of memory leaks by letting the page
                    handle the SelectedFriend's lifetime.
                </p>
                <p>So we can just remove this property, and then in the ShowDetailsCommand, instead of saving the
                    SelectedFriend here, we will remove this line here:
                </p>
                <figure>
<pre><code class="csharp">public RelayComman&lt;Friend&gt; ShowDetailsCommand
{
    get
    {
        return _showDetailsCommand
            ?? (_showDetailsCommand = new RelayCommand&lt;Friend&gt;(
                                  friend =&gt;
                                  {
                                      SelectedFriend = friend;
                                      _navigationService.NavigateTo(
                                          new Uri("/DetailsPage.xaml", UriKind.Relative));
                                  }));
    }
}</code></pre>
                    <figcaption>Fig04-027</figcaption>
                </figure>
                <p>and we will pass the Friend to the new NavigationService that we just added:</p>
                <figure>
<pre><code class="">friend =&gt;
    {
      _navigationService.NavigateTo(new Uri("/DetailsPage.xaml", UriKind.Relative));
    }));</code></pre>
                    <figcaption>Fig04-028</figcaption>
                </figure>
                <p>The Friend will be passed as a state to the page that we navigated to. Let's take care of the XAML
                    now.
                </p>
                <p>First, in MainPage.xaml, we need to modify the DataBindings, which we are going to the MainViewModel:
                </p>
                <figure>
                    <pre><code class="xml">DataContext="{Binding Source={StaticResource Main}}"&gt;</code></pre>
                    <figcaption>Fig04-029</figcaption>
                </figure>
                <p>Instead, we use the Main property of the Locator that we declared as a global resource:</p>
                <figure>
                    <pre><code
                            class="xml">DataContext="{Binding Main, Source={StaticResource Locator}}"&gt;</code></pre>
                    <figcaption>Fig04-030</figcaption>
                </figure>
                <p>The rest remains the same. Then, in Styles.xaml, we are going to do the same to locate the
                    ShowDetailsCommand on the MainViewModel. So here, I'm using the dot syntax in order to drill into
                    the MainViewModel and to locate the command inside it:
                </p>
                <figure>
<pre><code class="xml">&lt;i:Interaction.Triggers&gt;
    &lt;i:EventTrigger EventName="Tap"&gt;
        &lt;i:InvokeCommandAction Command="{Binding Main.ShowDetailsCommand, Mode=OneWay, Source={StaticResource Locator}}"
                               CommandParameter="{Binding Mode=OneWay}" /&gt;
    &lt;/i:EventTrigger&gt;
&lt;/i:Interaction.Triggers&gt;></code></pre>
                    <figcaption>Fig04-031</figcaption>
                </figure>
                <p>Of course this is in reference, here, to the Locator, which is exposed as a global resource:</p>
                <figure>
                    <pre><code class="xml">{Binding Main.ShowDetailsCommand, Mode=OneWay, Source={StaticResource Locator}}</code></pre>
                    <figcaption>Fig04-032</figcaption>
                </figure>
                <p>
                    Finally, let's open the DetailsPage. And here I need to retrieve the state from the
                    NavigationService and to assign this object as a DataContext of the page. So let's add an
                    OnNavigatedTo method, which is going to take care of this:
                </p>
                <figure>
<pre><code class="csharp">protected override void OnNavigatedTo(NavigationEventArgs e)
{
    var state = Helpers.NavigationService.GetAndRemoveState(NavigationContext.QueryString);
    DataContext = state;
    base.OnNavigatedTo(e);
}</code></pre>
                    <figcaption>Fig04-033</figcaption>
                </figure>
                <p>We also need to modify the SaveClick Event Handler to retrieve the MainViewModel from the
                    ViewModelLocator, and to execute the SaveCommand:
                </p>
                <figure>
<pre><code class="csharp">private async void SaveClick(object sender, EventArgs e)
{
    UpdateBinding();

    var mainVm = ViewModelLocator.Instance.Main;
    mainVm.SaveCommand.Execute(DataContext);
}</code></pre>
                    <figcaption>Fig04-034</figcaption>
                </figure>
                <p>In the XAML, we will remove the DataContext from the XAML here:</p>
                <figure>
                    <pre><code class="xml">DataContext="{Binding Source={StaticResource Main}}</code></pre>
                    <figcaption>Fig04-035</figcaption>
                </figure>
                <p>because it is now taken care of in the code behind. Then we need to remove the mention of
                    SelectedFriend in every Binding, since the reference for the Binding is now the Friend itself:
                </p>
                <figure>
<pre><code class="xml">&lt;TextBox x:Name="FirstNameTextBox"
	Text="{Binding SelectedFriend.FirstName, Mode=TwoWay}"/&gt;</code></pre>
                    <figcaption>Fig04-036</figcaption>
                </figure>
                <p>
                    Now we can run the application and see that we have the exact same functionality, but with a cleaner
                    architecture. We can load the Friends list, navigate to a friend, edit and save changes, etc. The
                    only small different now is the design time experience in the DetailsPage. If we go to Blend, we see
                    that the fields are empty:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-037.png"/>
                    <figcaption>Fig 04-037</figcaption>
                </figure>
                <p>This is because, as mentioned earlier, Blend does not run the code behind where the DataContext is
                    assigned. What we can do now is specify a design time experience for the Friends class in the
                    default constructor. So let's do this in Visual Studio. I will open the Friend class, and add a
                    default constructor, which is going to take care of creating design time data here:
                </p>
                <figure>
<pre><code class="csharp">#if DEBUG
    public Friend()
    {
        FirstName = "FirstName";
        LastName = "LastName";
        PictureUri = new Uri("http://www.galasoft.ch/logo/LogoHead128.png");
    }
#endif</code></pre>
                    <figcaption>Fig04-038</figcaption>
                </figure>
                <p>Then, using the design time DataContext that we introduced in the slides, we instruct Blend to use
                    that constructor at design time:
                </p>
                <figure>
                    <pre><code class="xml">d:DataContext="{d:DesignInstance Type=model:Friend, IsDesignTimeCreatable=True}"&gt;</code></pre>
                    <figcaption>Fig04-039</figcaption>
                </figure>
                <p>After we build the project, we can switch back to Blend and we will see that we now have some design
                    time data appearing in the details page:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-040.png"/>
                    <figcaption>Fig 04-040</figcaption>
                </figure>
                <p>In MainPage.xaml, however, the design time experience remains exactly the same as before. With these
                    changes, we are getting much closer to the MVVM Light application architecture, which offers a
                    clean, decoupled structure, as well as a great design time experience.
                </p>
                <h3>Why an Extras Assembly?</h3>
                <p>As we mentioned, MVVM Light components come in two separate assemblies, named GalaSoft.MvvmLight and
                    GalaSoft.MvvmLight.Extras. Many people have asked why there are two different assemblies. The reason
                    is that the components in the Extras DLL require external references. The SimpleIoc container needs
                    a reference to the Microsoft.Practices.ServiceLocation assembly. As for the EventToCommand behavior,
                    it needs a System.Windows.Interactivity assembly. We will understand a bit later why these external
                    references are needed.
                </p>
                <p>For some users, adding external references can cause problems, for reason of Licenses, or because of
                    the Procurement process. In order to allow the maximum number of people to use MVVM Light without
                    issues, I split the components in these two assemblies. If the external references are a problem,
                    the user can nonetheless use a Core DLL and leave the Extras aside.
                </p>
                <h3>Introducing Dependency Injection and Inversion of Control</h3>
                <p>Now let's talk about the SimpleIoc container. Before we start, it is interesting to recapitulate two
                    important concepts of modern programming -- What is dependency injection and what is an IoC
                    container?
                </p>
                <p>Dependency Injection is a programming concept. It delegates the creation of services that an object
                    consumes outside of this object. For example, it is quite common to do something like this:
                </p>
                <figure>
<pre><code class="csharp">public class MainViewModel
{
	private IDataService _dataService;
	public MainViewModel()
	{
		_dataService = new DataService();
	}
}</code></pre>
                    <figcaption>Fig04-041</figcaption>
                </figure>
                <p>We have a DataService and we create the DataService inside the object that uses it; for instance,
                    here in the constructor. Of course, this causes a number of questions:
                </p>
                <ul>
                    <li>What happens if multiple objects use a DataService; does it need to be created multiple times?
                    </li>
                    <li>What if we want to switch to a different implementation of the IDataService interface? For
                        example, in order to test the MainViewModel class.
                    </li>
                    <li>Who is responsible for the lifetime of the DataService, etc.?</li>
                </ul>
                <p>
                    On the other hand, let's consider this code:
                </p>
                <figure>
<pre><code class="csharp">public class MainViewModel
{
	private IDataService _dataService;
	public MainViewModel(IDataService dataService)
	{
		_dataService = dataService;
	}
}</code></pre>
                    <figcaption>Fig04-042</figcaption>
                </figure>
                <p>
                    Here, the IDataService is injected inside the MainViewModel constructor, which then Saves it. As a
                    consequence, the MainViewModel is kept completely ignorant from the IDataService implementation. It
                    is much easier to swap the IDataService implementation for another one, without the MainViewModel
                    being aware of it.
                </p>
                <p>So Dependency Injection is a way for an object to say, I want to consume a service, but I don't want
                    to be responsible for the creation of this service. Instead, the dependency is injected inside the
                    consumer. Here is an example:
                </p>
                <figure>
<pre><code class="csharp">public class Startup
{
	// ...
	public void Start()
	{
		IDataService service;
		if(condition)
		{
			service = new DataService();
		}
		else
		{
			service = new AnotherService();
		}
		var viewModel = new MainViewModel(service);
	}</code></pre>
                    <figcaption>Fig04-043</figcaption>
                </figure>
                <p>where an external class, named Startup, takes care of creating the correct implementation of
                    IDataService based on a condition. Then, this service is injected inside the MainViewModel
                    constructor.
                </p>
                <p>
                    Now let's talk about another modern application development topic, IOC Containers. The abbreviation
                    IOC stands for Inversion Of Control; in the sense that instead of creating the object within the
                    consumer class, like we saw before in the MainViewModel, the creation is delegated to someone else,
                    thus passing the control to that external instance.
                </p>
                <p>An IOC container is an object responsible for a few things.</p>
                <ul>

                    <li>It will create services on demand.</li>
                    <li>It is responsible for composing objects together by resolving dependencies and injecting the
                        correct instances.
                    </li>
                    <li>It is also responsible for caching the created objects and providing an access to them.</li>
                </ul>
                <p>There are multiple IOC containers available to .NET developers. In fact, many of them are available
                    as open-source projects. Here is a non-exhaustive list of a few well-known IOC containers:
                </p>
                <ul>
                    <li>Unity (Microsoft)</li>
                    <li>Ninject</li>
                    <li>StructureMap</li>
                    <li>CastleWindsor</li>
                    <li>And more..</li>
                </ul>
                <h3>
                    Registering Classes with SimpleIoc</h3>
                <p>
                    MVVM Light provides another IOC container, called SimpleIoc. You might ask yourself, with all the
                    available IOC containers on the market, why is another one needed? Well first of all, SimpleIoc is
                    very well suited to MVVM applications, because it has been developed specifically for them. It works
                    also in Blend and in the Visual Studio Designer, which is great to create design time data for your
                    ViewModels. Also, consider that many developers have never used an IOC container before, and many
                    don't know the concept. On another hand, many developers do have a favorite IOC container, and it is
                    almost impossible to select one which works for everybody.
                </p>
                <p>So instead, I decided to provide a very simple one with basic functionality, a little bit like a
                    "gateway drug" to Inversion Of Control and Dependency Injection. Once the developers get familiar
                    with the concept, they may be interested to check more advanced components, and of course it is
                    possible to replace the SimpleIoc of MVVM Light with another IOC container later. Because of these
                    considerations, SimpleIoc was born and integrated into MVVM Light.
                </p>
                <p>An IOC container always has two important phases:</p>
                <ul>
                    <li>the registration</li>
                    <li>getting instances</li>
                </ul>
                <p>
                    In SimpleIoc, this is how you register a class with a container:
                </p>
                <figure>
                    <pre><code class="csharp">SimpleIoc.Default.Register&lt;MainViewModel&gt;();</code></pre>
                    <figcaption>Fig04-044</figcaption>
                </figure>

                <p>Simply use a Register method, like here using it with a class. Another even more frequent case is
                    registering an interface and specifying which implementation to use; like here:
                </p>
                <figure>
                    <pre><code
                            class="csharp">SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();</code></pre>
                    <figcaption>Fig04-045</figcaption>
                </figure>
                <p> the IDataService interface and its DataService implementation. This allows for conditional
                    registration; for example, here, based on the condition:
                </p>
                <figure>
<pre><code class="csharp">if(condition)
{
	SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
}
else
{
	SimpleIoc.Default.Register&lt;IDataService, AnotherService&gt;();
}</code></pre>
                    <figcaption>Fig04-046</figcaption>
                </figure>
                <p>One typical usage for this is a detection of design time mode, when the application runs within the
                    Designer, such as Blend. In that case, we can register a design time DataService, and then at
                    runtime, rather use the actual DataService implementation.
                </p>
                <p>Note that when the class is registered, it still does not mean that any instance is created. The
                    creation is on demand, only when the GetInstance method is called for the first time. Also, the
                    created objects are cached and can be accessed as many times as needed. The SimpleIoc acts as a
                    global cache for the application, which can be very convenient. However, if an object must be
                    removed from the cache because it is not needed anymore, this must be done explicitly.
                </p>
                <p>Another way to register a class is to use a Factory. This is a delegate that returns an instance of
                    the given class:
                </p>
                <figure>
<pre><code class="csharp">var myService = new DataService();
SimpleIoc.Default.Register&lt;IDataService&gt;(() =&gt; myService);</code></pre>
                    <figcaption>Fig04-047</figcaption>
                </figure>
                <p>
                    Typically, factories are expressed as lambda expressions, like here:
                </p>
                <figure>
                    <pre><code class="csharp">SimpleIoc.Default.Register&lt;IDataService&gt;(() =&gt; myService);</code></pre>
                    <figcaption>Fig04-048</figcaption>
                </figure>
                <p>These can be useful, for example, if we want to return an instance that had been created earlier, or
                    like here:
                </p>
                <figure>
<pre><code class="csharp">var param1 = true;
var param2 = "Hello world";
SimpleIoc.Default.Register&lt;MainViewModel&gt;(
	() =&gt; new MainViewModel(param1, param2);</code></pre>
                    <figcaption>Fig04-049</figcaption>
                </figure>
                <p>if we need to pass parameters to the MainViewModel constructor. Here too, the execution of the
                    factory delegate does not happen immediately when the registration occurs. It is only executed on
                    demand when the first instance is retrieved from the SimpleIoc. The factory is executed once only,
                    and the result is cached just like before.
                </p>
                <p>There are a few options that can be used when registering to SimpleIoc. First, the option to
                    immediately create an instance as soon as the class or the interface has been registered by using a
                    Boolean as shown here:
                </p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IDataService, DataService>(true);
SimpleIoc.Default.Register&lt;MainViewModel&gt;(true);</code></pre>
                    <figcaption>Fig04-050</figcaption>
                </figure>
                <p>This can be useful if you want to guarantee that the class exists as early as possible. For instance,
                    imagine that you have a service that needs to listen to a web socket in order to receive messages
                    from a server and to cache them. Of course, it is good if this object can be created as soon as the
                    application starts. Or, imagine a Settings object, which needs to load the saved settings from the
                    file system as soon as the application starts.
                </p>
                <p>Note that it is also possible to force the immediate creation of the instance when a factory is used,
                    like here:
                </p>
                <figure>
<pre><code class="csharp">var myService = new DataService();
SimpleIoc.Default.Register&lt;IDataService&gt;(() =&gt; myService, true);</code></pre>
                    <figcaption>Fig04-051</figcaption>
                </figure>
                <p>or here:</p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;MainViewModel&gt;(
	() =&gt; new MainViewModel(param1, param2), true);</code></pre>
                    <figcaption>Fig04-052</figcaption>
                </figure>
                <p>Another very useful option is the possibility to register a class or an interface with a Key:</p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;MainViewModel&gt;(
	() =&gt; new MainViewModel(), "MyUniqueKey");

SimpleIoc.Default.Register&lt;IDataService&gt;(
	() =&gt; new DataService(), "AnotherUniqueKey");</code></pre>
                    <figcaption>Fig04-053</figcaption>
                </figure>

                <p>This allows having multiple instances of the same class or interface inside the IOC container. Of
                    course, the corresponding instance needs to be retrieved with the same Key, so there must be some
                    kind of contract between the class responsible for the registration and the consumers that will get
                    the instances later. A little bit later in this module, we will see how to recreate instances using
                    a Key.
                </p>
                <h3>Creating and Getting Instances from SimpleIoc</h3>
                <p>This is where the GetInstance method is useful. It is quite straightforward for example, here:</p>
                <figure>
<pre><code class="csharp">var instance
	= SimpleIoc.Default.GetInstance&lt;MainViewModel&gt;();
var service
	= SimpleIoc.Default.GetInstance&lt;IDataService&gt;();</code></pre>
                    <figcaption>Fig04-054</figcaption>
                </figure>
                <p>retrieving the Default instance of MainViewModel, or of IDataService.</p>
                <p>During registration, it was possible to pass a key to the Register method:</p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IDataService&gt;(
	() =&gt; new DataService(), "UniqueKey");</code></pre>
                    <figcaption>Fig04-055</figcaption>
                </figure>
                <p>
                    Back then, we mentioned that it was useful in order to have more than one instance of the same class
                    or interface inside the IOC container. Now we can also use the same key to retrieve the registered
                    instance. Of course, it means that the same key must be used during the registration, and by the
                    consumer. On the other hand, if the instances are registered without a key:
                </p>
                <figure>
                    <pre><code
                            class="csharp">SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();</code></pre>
                    <figcaption>Fig04-056</figcaption>
                </figure>
                <p>it is possible to use a key anyway to retrieve an instance:</p>
                <figure>
<pre><code class="csharp">var keyedInstance
	= SimpleIoc.Default.GetInstance&lt;IDataService&gt;("key1");</code></pre>
                    <figcaption>Fig04-057</figcaption>
                </figure>
                <p>In that case, one specific instance per UniqueKey is created and cached. This can be useful if you
                    need a number of instances of the same type for some reason. However, be aware that all created
                    instances are cached. If you want to remove the instance from the cache in order to free memory, you
                    need to explicitly unregister the instance using the same key. We will talk about unregistering a
                    little bit later.
                </p>
                <p>One of the advantages of using SimpleIoc to create instances is that it will also take care of
                    creating the necessary dependencies and to compose them. For example, consider the following
                    MainViewModel constructor:
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel(
	IDataService dataService,
	INavigationService navigationService)
{
	_dataService = dataService;
	_navigationService = navigationService;
}</code></pre>
                    <figcaption>Fig04-058</figcaption>
                </figure>
                <p>It requires two services, one instance of IDataService and one instance of INavigationService. In
                    MVVM Light, typically the registration to SimpleIoc takes place in an object, called
                    ViewModelLocator, that we discovered earlier in this module:
                </p>
                <figure>
<pre><code class="csharp">static ViewModelLocator()
{



}</code></pre>
                    <figcaption>Fig04-059</figcaption>
                </figure>
                <p>Inside the constructor, we can register the services, like shown here:</p>
                <figure>
<pre><code class="csharp">static ViewModelLocator()
{
	SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
	SimpleIoc.Default.Register&lt;INavigationService&gt;(
		() =&gt; new NavigationService())
}</code></pre>
                    <figcaption>Fig04-060</figcaption>
                </figure>
                <p>Then, we take care of registering the MainViewModel itself:</p>
                <figure>
<pre><code class="csharp">static ViewModelLocator()
{
	SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
	SimpleIoc.Default.Register&lt;INavigationService&gt;(
		() =&gt; new NavigationService())
	SimpleIoc.Default.Register&lt;MainViewModel&gt;();
}</code></pre>
                    <figcaption>Fig04-061</figcaption>
                </figure>
                <p>
                    Later, when the GetInstance method is called for the MainViewModel:
                </p>
                <figure>
<pre><code class="csharp">public MainViewModel Main
{
	get { return SimpleIoc.Default.GetInstance&lt;MainViewModel&gt;(); }
}</code></pre>
                    <figcaption>Fig04-062</figcaption>
                </figure>
                <p>the SimpleIoc will check if it already has an instance of this class in the cache. If not, it will
                    create one, but of course in order to create the MainViewModel, SimpleIoc needs an instance of
                    IDataService. Again, same story; it checks if it has an instance of IDataService registered, if not,
                    it will create one. Then, the same scenario happens again with the INavigationService. And finally,
                    when all the parameters are ready, the MainViewModel can be created, cached, and returned.
                </p>
                <p>Let's take a moment to talk about two ways to do Dependency Injection in a class:</p>
                <figure>
<pre><code class="csharp">public class MainViewModel : ViewModelBase
{
	private readonly IDataService _dataService;

	public MainViewModel(IDataService dataService)
	{
		_dataService = dataService;
	}
}</code></pre>
                    <figcaption>Fig04-063</figcaption>
                </figure>
                <p>
                    Of course, we already mentioned the injection in the constructor, which we use in various examples.
                    This is convenient when the service is created in the IOC container and never changes. When the
                    MainViewModel is created here, the instance is retrieved and stored as a private attribute for
                    convenience.
                </p>

                <p>There is, however, another way to inject a dependency in a class, through a property:</p>
                <figure>
<pre><code class="csharp">public class MainViewModel : ViewModelBase
{
	public IDialogService DialogService
	{
		get
		{
			return SimpleIoc.Default.GetInstance&lt;IDialogService&gt;();
		}
	}

	private readonly IDataService _dataService;

	public MainViewModel(IDataService dataService)
	{
		_dataService = dataService;
	}
}</code></pre>
                    <figcaption>Fig04-064</figcaption>
                </figure>
                <p>
                    Here, every time that the property is accessed, it is retrieved from the IOC container. This way of
                    doing is useful if the instance of IDialogService may change during the application lifetime. In
                    this case, it is not safe to inject the instance in the constructor and to save it as an attribute.
                </p>
                <h3>Unregistering Classes from SimpleIoc</h3>
                <p>Of course, since we can register to the SimpleIoc component, there is also a way to unregister. This
                    is pretty straightforward using the Unregister method. A few things to take in consideration,
                    though.
                </p>
                <p>When you unregister a class or an interface, you also remove all the instances from the cache
                    automatically. If that was not the desired effect, you must take care of retrieving the instance
                    before you go Unregister and to save it separately.
                </p>
                <p>Unregister can take a parameter, or not. If we call the method without any parameter, like here:</p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Unregister&lt;MainViewModel&gt;();
SimpleIoc.Default.Unregister&lt;IDialogService&gt;();</code></pre>
                    <figcaption>Fig04-065</figcaption>
                </figure>
                <p>
                    the class or interface is completely removed from SimpleIoc. Any subsequent call to GetInstance will
                    cause an exception to occur. It is, however, possible to pass a parameter to the Unregister method:
                </p>
                <figure>
<pre><code class="csharp">SimpleIoc.Default.Unregister&lt;IDialogService&gt;(this);
SimpleIoc.Default.Unregister&lt;IDataService&gt;("key1");</code></pre>
                    <figcaption>Fig04-066</figcaption>
                </figure>
                <p>
                    The parameter can be an instance itself. In that case, the instance passed as parameter, like here
                    the (this) keyword, is removed from the cache. However, the IDialogService interface itself is not
                    removed completely from the IOC container. Calling GetInstance again, at this point, will force the
                    creation of a new instance, which will then be cached again.
                </p>
                <p>Similarly, the key can also be passed to the Unregister method to identify an instance with the same
                    result:
                </p>
                <figure>
                    <pre><code class="csharp">SimpleIoc.Default.Unregister&lt;IDataService&gt;("key1");</code></pre>
                    <figcaption>Fig04-067</figcaption>
                </figure>
                <p>Note that even if you try to Unregister a class, an interface, a key or an instance that do not exist
                    in SimpleIoc, there are no side effects. So really, it is a good clean policy to think about
                    unregistering your objects, once you don't need them anymore, in order to optimize memory usage.
                </p>
                <h3>A Typical Scenario with SimpleIoc</h3>
                <p>In Navigation Applications, like in Windows Phone and Windows 8, a typical scenario involves
                    navigating away from the current page and to a new page. In that case, it can be interesting to add
                    and remove services from the IOC container.
                </p>
                <p>For example, a custom dialog may be displayed to the user, using an IDialogService interface, which
                    is implemented by each page. So each page, when it is displayed, becomes a current IDialogService,
                    and the page that was previously displayed needs to unregister. This is how we do it.
                </p>
                <figure>
<pre><code class="csharp">public sealed partial class MainPage : IDialogService
{
	// ...

	protected override void OnNavigatedTo(NavigationEventArgs e)
	{
		SimpleIoc.Default.Register&lt;IDialogService&gt;(() => this);
		base.OnNavigatedTo(e);
	}

	protected override void OnNavigatedFrom(NavigationEventArgs e)
	{
		SimpleIoc.Default.Unregister(this);
		base.OnNavigatedFrom(e);
	}</code></pre>
                    <figcaption>Fig04-068</figcaption>
                </figure>
                <p>In the OnNavigatedTo method, we add the page itself in the IOC container as the IDialogService.
                    Notice how we use a factory to do this and how the factory returns a this keyword, the current page
                    itself. For the consumer, which is typically a ViewModel, this is a good way to access
                    functionalities of the View in an abstracted manner. The functionality is exposed in the
                    IDialogService interface. At no time does the ViewModel know that it is, in fact, using the page
                    itself; this is a clean, decoupled implementation. When we navigate away from the page, we
                    Unregister the page, like this.
                </p>
                <figure>
<pre><code class="csharp">protected override void OnNavigatedFrom(NavigationEventArgs e)
{
	SimpleIoc.Default.Unregister(this);
	base.OnNavigatedFrom(e);
}</code></pre>
                    <figcaption>Fig04-069</figcaption>
                </figure>
                <p>
                    Because we passed the (this) keyword as parameter, the instance only is removed from the IOC
                    container.
                </p>
                <h3>SimpleIoc's Utility Methods and Properties</h3>
                <p>In addition to the core methods, SimpleIoc proposes a set of Utility Methods. For example, sometimes
                    it is useful to know which classes or interfaces have been registered to SimpleIoc. Also, we might
                    be interested to know if a given class or interface has been not only registered, but also created
                    and cached. This is what the IsRegistered and the ContainsCreated methods do. Consider this code
                </p>
                <figure>
                    <pre><code class="csharp">SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();</code></pre>
                    <figcaption>Fig04-070</figcaption>
                </figure>
                <p>If we register an interface, in this case IDataService, the call to IsRegistered will return true:
                </p>
<figure>
<pre><code class="csharp">var test1 = SimpleIoc.Default.IsRegistered&lt;IDataService&gt;();
// true</code></pre>
<figcaption>Fig04-071</figcaption>
</figure>
                <p>
                    As expected. However, a call to ContainsCreated will return false:
                </p>
<figure>
<pre><code class="csharp">var test2 = SimpleIoc.Default.ContainsCreated&lt;IDataService&gt;();
// false</code></pre>
<figcaption>Fig04-072</figcaption>
</figure>
                <p>
                    because even though IDataService has been registered, the cache does not contain any instance yet.
                    If, after that, a call to GetInstance is made:
                </p>
<figure>
<pre><code class="csharp">var instance = SimpleIoc.Default.GetInstance&lt;IDataService&gt;();</code></pre>
<figcaption>Fig04-073</figcaption>
</figure>
                <p>the SimpleIoc will create an instance of DataService and cache it.</p>
                <p>This is why the next call to ContainsCreated returns, this time, true:</p>
<figure>
<pre><code class="csharp">var test3 = SimpleIoc.Default.ContainsCreated&lt;IDataService&gt;();
// true</code></pre>
<figcaption>Fig04-074</figcaption>
</figure>
                <p>Another useful method is GetAllCreatedInstances. Because the cache can contain multiple instances of
                    the same class by using key, this method allows retrieving them all. Note, however, that this method
                    only retrieves instances that have already been created at the time where it is called. If a class
                    is registered, but GetInstance has never been called yet, the GetAllCreatedInstances method will
                    return an empty list. Let's illustrate this with some code:
                </p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();
var allInstances
	= SimpleIoc.Default.GetAllCreatedInstance&lt;IDataService&gt;();
	// Zero instance</code></pre>
<figcaption>Fig04-075</figcaption>
</figure>
                <p>Right after registration, GetAllCreatedInstances returns an empty list. If later we call GetInstance
                    twice with different keys:
                </p>
<figure>
<pre><code class="csharp">var instance1
	= SimpleIoc.Default.GetInstance&lt;IDataService&gt;("key1");
var instance2
	= SimpleIoc.Default.GetInstance&lt;IDataService&gt;("key2");</code></pre>
<figcaption>Fig04-076</figcaption>
</figure>
                <p>two instances are created and cached. The next call to GetAllCreatedInstances:</p>
<figure>
<pre><code class="csharp">allInstances
	= SimpleIoc.Default.GetAllCreatedInstances&lt;IDataService&gt;();
	// Two instances</code></pre>
<figcaption>Fig04-077</figcaption>
</figure>
                <p>will, this time, return them both.</p>
                <p>On the other hand, the GetAllInstances method acts differently, so do not get confused. Calling
                    GetAllInstances does force the creation of instance per class, if that was not already the case.
                    This is what we call the default instance of each registered class. For example, here:
                </p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IDataService, DataService&gt;();</code></pre>
<figcaption>Fig04-078</figcaption>
</figure>
                <p>we register the IDataService interface. Even though GetInstance has never been called, the next call
                    to GetAllInstances returns one instance.
                </p>
<figure>
<pre><code class="csharp">var allInstances
	= SimpleIoc.Default.GetAllInstances&lt;IDataService&gt;();
	// One instance</code></pre>
<figcaption>Fig04-079</figcaption>
</figure>
                <p>The creation of this Default instance of IDataService has been triggered by the call to
                    GetAllInstances.
                </p>
                <h3>The ServiceLocation Assembly and SimpleIoc</h3>
                <p>In the beginning of this module, I mentioned that an additional reference is needed by SimpleIoc. The
                    Microsoft.Practices.ServiceLocation DLL. This assembly contains a ServiceLocator class, as well as a
                    few helper classes, which are quite useful to standardize the usage of IOC containers.
                </p>
                <p>
                    Indeed, there are quite a few IOC containers available on the market. Choosing which one to use
                    depends on many factors. During the course of the lifetime of an application, it is not
                    inconceivable that the Development Team decides to swap their IOC container with another one. This
                    is especially plausible in the case of SimpleIoc, which is very easy to use, but has limited
                    functionality compared to more powerful offerings.
                </p>
                <p>
                    In order to facilitate the swapping, the makers of the most popular IOC containers agreed on an
                    abstraction model. First, the user can define which IOC container instance should be used
                    everywhere. In the case of SimpleIoc, the Default instance is named SimpleIoc.Default. You should
                    register this instance with a ServiceLocator class, as shown here:
                </p>
<figure>
<pre><code class="csharp">ServiceLocator.SetLocatorProvider(() => SimpleIoc.Default);</code></pre>
<figcaption>Fig04-080</figcaption>
</figure>
                <p>
                    Following this initialization, it is possible to interchange SimpleIoc.Default and
                    ServiceLocator.Current. For example, the GetInstance method can be called here:
                </p>
<figure>
<pre><code class="csharp">ServiceLocator.Current.GetInstance&lt;IDataService&gt;();</code></pre>
<figcaption>Fig04-081</figcaption>
</figure>
                <p>
                    on ServiceLocator.Current. This is exactly the same as calling:
                </p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.GetInstance&lt;IDataService&gt;();
</code></pre>
<figcaption>Fig04-082</figcaption>
</figure>
                <p>Of course, the advantage is that ServiceLocator is a standard, and so, if at a later point the
                    Development Team decides to use another IOC container using the same standard, all the
                    ServiceLocator methods can be left unchanged in the code, which reduces greatly the number of lines
                    of code to modify.
                </p>
                <h3>SimpleIoc Demos</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-003" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\simpleioc\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-003">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-004" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\simpleioc\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-004">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>The WhyMvvm application that we built in the previous modules of this course runs fine without an IOC
                    container, but adding SimpleIoc to it brings some advantages. Most importantly, it will make it
                    easier to extend the application with new features when the time comes.
                </p>
                <p>
                    In a typical MVVM Light application, the IOC setup is done in the ViewModelLocator. Of course, this
                    is not compulsory and objects can be registered in other parts of the application too. It is a good
                    practice to keep the registration instructions somewhat centralized in order to make it easier to
                    make changes to the IOC container when needed. Here we are in the ViewModelLocator class in the
                    ViewModel folder:
                </p>
<figure>
<pre><code class="csharp">public ViewModelLocator()
{
	IFriendsService friendsService;

	if(ViewModelBase.IsInDesignModeStatic)
	{
		friendsService = new DesignFriendsService();
	}
	else
	{
		friendsService = new FriendsService();
	}

	IDialogService dialogService = new DialogService();
	INavigationService navigationService = new NavigationService();

	Main = new MainViewModel(friendsService, dialogService, navigationService);
}</code></pre>
<figcaption>Fig04-083</figcaption>
</figure>
                <p>
                    We will initialize a SimpleIoc in the static constructor of the ViewModelLocator. First, we will let
                    the IOC container create the friendsService on demand. So we can replace the creation of the service
                    here and here
                </p>
<figure>
<pre><code class="csharp">if(ViewModelBase.IsInDesignModeStatic)
{
	friendsService = new DesignFriendsService();
}
else
{
	friendsService = new FriendsService();
}</code></pre>
<figcaption>Fig04-084</figcaption>
</figure>
                <p>
                    with a registration instead. Let's start with a DesignFriendsService and the runtime service:
                </p>
<figure>
<pre><code class="csharp">if(ViewModelBase.IsInDesignModeStatic)
{
	SimpleIoc.Default.Register&lt;IFriendsService, DesignFriendsService&gt;();
	friendsService = new DesignFriendsService();
}
else
{
	SimpleIoc.Default.Register&lt;IFriendsService, FriendsService&gt;();
	friendsService = new FriendsService();
}
</code></pre>
<figcaption>Fig04-085</figcaption>
</figure>
                <p>Now of course I can remove the creation of the service here:</p>
<figure>
<pre><code class="csharp">public ViewModelLocator()
{
	IFriendsService friendsService;</code></pre>
<figcaption>Fig04-086</figcaption>
</figure>
                <p>here:</p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IFriendsService, DesignFriendsService&gt;();
friendsService = new DesignFriendsService();</code></pre>
<figcaption>Fig04-087</figcaption>
</figure>
                <p>and here:</p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IFriendsService, FriendsService&gt;();
friendsService = new FriendsService();</code></pre>
<figcaption>Fig04-088</figcaption>
</figure>
                <p>Then, there is a registration for the DialogService and the NavigationService:</p>
<figure>
<pre><code class="csharp">IDialogService dialogService = new DialogService();
INavigationService navigationService = new NavigationService();</code></pre>
<figcaption>Fig04-089</figcaption>
</figure>
                <p>
                    Here, we don't use a conditional registration, but if needed, it would be easy to change. Let's add
                    the registration here:
                </p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;IDialogService, DialogService&gt;();
SimpleIoc.Default.Register&lt;INavigationService, NavigationService&gt;();
</code></pre>
<figcaption>Fig04-090</figcaption>
</figure>
                <p>Finally, the MainViewModel, which uses all these services:</p>
<figure>
<pre><code class="csharp">Main = new MainViewModel(friendsService, dialogService, navigationService);</code></pre>
<figcaption>Fig04-091</figcaption>
</figure>
                <p>
                    can also be registered:
                </p>
<figure>
<pre><code class="csharp">SimpleIoc.Default.Register&lt;MainViewModel&gt;();</code></pre>
<figcaption>Fig04-092</figcaption>
</figure>
                <p>
                    In order to trigger the creation of the MainViewModel and all the associated services, the
                    GetInstance method needs to be called at some point, but we also need the Main property, which is
                    located here:
                </p>
<figure>
<pre><code class="csharp">public MainViewModel Main
{
	get;
	private set;
}</code></pre>
<figcaption>Fig04-093</figcaption>
</figure>
                <p>
                    because this is what is used by the DataBinding in XAML. So let's replace the Main property by a
                    property with only a getter, and call GetInstance from here:
                </p>
<figure>
<pre><code class="csharp">public MainViewModel Main
{
	get
	{
		return ServiceLocator.Current.GetInstance&lt;MainViewModel&gt;();
	}
}</code></pre>
<figcaption>Fig04-094</figcaption>
</figure>
                <p>
                    To illustrate how easy it is to get the MainViewModel instance or any other cached instance from
                    anywhere in the application, let's move to the DetailsPage. Here, we are getting the MainViewModel
                    instance from the ViewModelLocator through a static property, which is not very elegant:
                </p>
<figure>
<pre><code class="csharp">var mainVm = ViewModelLocator.Instance.Main;</code></pre>
<figcaption>Fig04-095</figcaption>
</figure>
                <p>We can replace this by a more decoupled approach using the IOC container. Effectively, the instance
                    of the MainViewModel is the same, but we are not using the ViewModelLocator anymore, which is
                    cleaner:
                </p>
<figure>
<pre><code class="csharp">var mainVm = ServiceLocator.Current.GetInstance&lt;MainViewModel&gt;();</code></pre>
<figcaption>Fig04-096</figcaption>
</figure>

                <p>This was just a small example of how to use SimpleIoc, and there are many other scenarios where this
                    class is very useful. Because it is Blendable, that is to say that it works just fine in Blend and
                    in the Visual Studio Designer, it facilitates a creation of design time code or can be used in a
                    similar manner to execute unit tests without having to modify the ViewModel classes. It is a very
                    handy component of the MVVM Light Toolkit.
                </p>
                <h3>Introduction to Behaviors</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-005" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-005">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-006" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-006">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Now let's discuss the last component of MVVM Light Version 4, the EventToCommand. This is a so-called
                    behavior, or like we sometimes hear, Blend Behavior. First, let's understand what Behaviors are.
                    Initially, behaviors are a modified version of a pattern that the WPF community came up with, called
                    Attached Behaviors, and based on attached properties that are available in all XAML-based
                    frameworks. For more information about Attached Behaviors, see the link
                    <a href="http://galasoft.ch/s/attbehaviors">here</a>.
                </p>

                <p>I won't go deeper in the details of Attached Behaviors, because this is off topic for this course,
                    but it is enough to say that these are very powerful and useful in certain situations. The behaviors
                    we are using here are sometimes called Blend Behaviors, because they were developed initially by the
                    Blend Team. Mostly, they are a response to the problem that the original Attached Behaviors were not
                    easy to use in a tool such as Blend and had to be added in XAML manually.
                </p>
                <p>
                    On the other hand, the so-called Blend Behaviors worked great in Blend, as you would expect. However,
                    they are not directly related to Blend, and you can use them, even if you never start blend in your
                    life, which of course would be a pity.
                </p>
                <p>
                    Behaviors are small pieces of code behind that are encapsulated and very easy to redistribute, for
                    example, as part of a DLL. When Visual Studio gets installed, you also get all the necessary pieces
                    to use a set of behaviors as part of the SDK, especially now that Blend gets installed for free.
                    With Visual Studio 2012 and 2013, you have all you need to use behaviors and clean your code behind.
                </p>
                <p>
                    Behaviors attach to a UI element. As mentioned, you don't need Blend to work with Behaviors, but if
                    you do use Blend, it makes it much easier to find behaviors, place them in your XAML, and configure
                    them.
                </p>
                <p>
                    Here we see the Blend Assets Library:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-097.png"/>
                    <figcaption>Fig 04-097</figcaption>
                </figure>
                <p>
                    and we see, for example, the MouseDragElementBehavior that we will drag and drop on the rectangle
                    and then configure. Let's see a quick demo. This is a Windows Presentation Foundation Application
                    created in Blend. Now I will add a rectangle to this window, let's make it blue:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-098.png"/>
                    <figcaption>Fig 04-098</figcaption>
                </figure>
                <p>
                    and in many applications we need to implement dragging of an element. This is quite repetitive and
                    honestly quite annoying, because we need to handle multiple mouse events and do some calculations to
                    see by how much the mouse moved. The first time we implement this, it is interesting, but after the
                    second time we already wish we had something better. Thankfully someone encapsulated this code in a
                    behavior named MouseDragElement.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-099.png"/>
                    <figcaption>Fig 04-099</figcaption>
                </figure>
                <p>
                    Once we find this element in the Assets Library, we can drag it on the rectangle and drop it. Then
                    we can run the application, and immediately the rectangle can be dragged around the window:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-100.png"/>
                    <figcaption>Fig 04-100</figcaption>
                </figure>
                <p>
                    This particular behavior has one property, so if I select it in the object and timeline:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-101.png"/>
                    <figcaption>Fig 04-101</figcaption>
                </figure>
                <p>
                    I see the property here called ConstrainToParentBounds:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-102.png"/>
                    <figcaption>Fig 04-102</figcaption>
                </figure>
                <p>If I check this property and run the application again, we will see that the rectangle is not
                    constrained to the Window's boundaries.
                </p>
                <p>So in Blend, it is really easy to just drag and drop the behavior on the element and then to
                    configure it. Here is how the code looks like in XAML:
                </p>
        <figure>
<pre><code class="xml">&lt;Rectangle Fill="Blue"
    Height="100"
    Width="150"&gt;
    &lt;i:Interaction.Behaviors&gt;
        &lt;ei:MouseDragElementBehavior ConstrainToParentBounds="True"/&gt;
    &lt;/i:Interaction.Behaviors&gt;
&lt;/Rectangle&gt;</code></pre>
        <figcaption>Fig04-103</figcaption>
        </figure>
                <p>Notice how the behavior is neatly attached to the rectangle using the Interaction.Behaviors
                    construct:
                </p>
<figure>
<pre><code class="xml">&lt;Rectangle Fill="Blue"
	Height="100"
	Width="150">
	&lt;i:Interaction.Behaviors&gt;
		&lt;ei:MouseDragElementBehavior /&gt;
	&lt;/i:Interaction.Behaviors&gt;
&lt;/Rectangle&gt;</code></pre>
<figcaption>Fig04-104</figcaption>
</figure>
                <p>
                    Also, note the usage of two namespaces here:
                </p>
<figure>
<pre><code class="xml">xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
xmlns:ei="http://schemas.microsoft.com/expression/2010/interactions"</code></pre>
<figcaption>Fig04-105</figcaption>
</figure>
                <p>
                    the interactivity namespace, which is where the base classes for all the behaviors are found, and
                    also the interactions namespace, which contains a MouseDragElementBehavior itself that we just used.
                </p>
                <h3>Introduction to EventToCommand</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-007" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-007">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-008" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-008">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>In addition to Behaviors, there is another group of elements we can use in a similar manner, named
                    Actions. There are differences between Behaviors and Actions. Behaviors are standalone and
                    self-sufficient. On the other hand, Actions are always attached to a trigger to be useful. In
                    hardware terms, you can think of the action as an actuator, an element that will perform an
                    operation. On the other hand, the trigger is a kind of a sensor.
                </p>
                <p>One trigger can have one or multiple actions. When the trigger fires, it will execute all the actions
                    that are attached to it. There are multiple kinds of triggers; for example, the most common one is
                    the Event Trigger, which triggers when an event is fired on the attached element. For example, you
                    could use a SelectionChanged event of a ListBox to execute a series of actions.
                </p>
                <p>Or, another trigger is a Data Trigger, which is great in case of MVVM. The trigger will fire when a
                    certain property reaches a certain value, which is set in the Trigger's properties.
                </p>
                <p>Of course, you can also develop your own behaviors, triggers, and actions. I highly recommend any
                    client developer to take a good look at behaviors. In MVVM Light, there is one action which is very
                    useful in relationship with RelayCommands; the EventToCommand. In fact, EventToCommand is not a very
                    good name, and in retrospect, I wish I would have chosen a better one. It is really an action,
                    meaning that it can be attached to *any* trigger, not just Event triggers.
                </p>
                <p>
                    The intent of EventToCommand is rather simple; every time that it is triggered, it will execute a
                    Command. Because a Command property is a dependency property, it can be set by DataBinding:
                </p>
<figure>
<pre><code class="">&lt;Rectangle Fill="Blue"
			Height="115"
			VerticalAlignment="Top"&gt;
            &lt;i:Interaction.Triggers&gt;
                &lt;i:EventTrigger EventName="MouseLeftButtonDown"&gt;
                    &lt;mvvm:EventToCommand Command="{Binding ShowPointCommand}"
							CommandParameter="a parameter" /&gt;
                &lt;/i:EventTrigger&gt;
            &lt;/i:Interaction.Triggers&gt;
        &lt;/Rectangle&gt;</code></pre>
<figcaption>Fig04-106</figcaption>
</figure>
                <p>
                    which allows a nice decoupling of the View and the ViewModel. In addition to the Command property,
                    there is, of course, a CommandParameter property, which can also be data bound. If it is set, this
                    parameter will be passed to the command. Remember from our study of ICommand and RelayCommand in an
                    earlier module that the ICommand's methods have a parameter, which can easily be set or left null.
                </p>
                <p>
                    So which are the scenarios in which you may want to use EventToCommand? Well one frequent scenario
                    is whenever you want to execute the command from an element which doesn't support them. In fact, in
                    .NET, only the ButtonBase class supports a Command property. It means that the UI elements, which
                    derive from ButtonBase, will support Command, such as Button, ToggleButton, RadioButton, Checkbox,
                    etc. Any other element does not support Command out-of-the-box, and this is where EventToCommand can
                    be useful.
                </p>
                <p>
                    That said, even for this control that supports Commands, the Command will only be executed when the
                    control is clicked. For any other event, such as MouseOver, there is no built-in way to execute a
                    command. Here, too, the EventToCommand component can be used.
                </p>
                <p>
                    Of course, because EventToCommand is an action, it can be triggered by any type of trigger, such as
                    a Data Trigger. We will illustrate this with a demo a little bit later. The last scenario is when an
                    event handler simply cannot be used. There are such cases, for example when the XAML control is
                    placed in a file, which does not have code behind. This is a case for resource dictionaries. If you
                    have a Data Template which is neatly placed in a Resource Dictionary, either in order to be reusable
                    or to keep the XAML code clean, there is no way to execute an event handler from this Data Template.
                    In this case, too, EventToCommand can be used.
                </p>
                <h3>EventToCommand Demo 1: Handling MouseEnter Event</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-009" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-009">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-010" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-010">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Let's illustrate this with a few short demos. This is a WPF application, but the exact same demos can
                    be done in any of the other XAML framework. Here we have a Button with the Command property data
                    bound to a RelayCommand on the ViewModel:
                </p>
<figure>
<pre><code class="xml">&lt;Button Content="Button"
    Command="{Binding SayHelloCommand}"
    HorizontalAlignment="Left"
    VerticalAlignment="Top"
    Width="270"
    Margin="10,10,0,0"
    Height="130" /&gt;</code></pre>
<figcaption>Fig04-107</figcaption>
</figure>
                <p>If I run the application and click on the Button, the command fires, no problem here:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-108.png"/>
                    <figcaption>Fig 04-108</figcaption>
                </figure>
                <p>
                    but if I want to handle the MouseEnter event, this won't work. So here I can add an EventToCommand.
                    Let's do that in Blend. Because this application had MVVM Light installed, I can see the
                    EventToCommand behavior in the Assets Library under Behaviors:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-109.png"/>
                    <figcaption>Fig 04-109</figcaption>
                </figure>
                <p>
                    here it is. Let's drag and drop it on the Button here. Then, in the Properties panel, we can
                    customize it. First, we can choose a type of the trigger, which by default is set to EventTrigger;
                    this is what we want:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-110.png"/>
                    <figcaption>Fig 04-110</figcaption>
                </figure>
                <p>
                    Then, we choose which event will trigger the action. Let's find the MouseEnter event, here it is:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-111.png"/>
                    <figcaption>Fig 04-111</figcaption>
                </figure>
                <p>
                    And finally, we need to set the Command which will be fired. Here I can use a Data Binding Editor,
                    let's create a Data Binding:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-112.png"/>
                    <figcaption>Fig 04-112</figcaption>
                </figure>
                <p>
                    And because MVVM Light is set up properly, I can see that the DataContext is a MainViewModel and I
                    can select the correct property, this SayHelloCommand. Let's click OK:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-113.png"/>
                    <figcaption>Fig 04-113</figcaption>
                </figure>
                <p>Now if I run the application again, and I pass the mouse on the button without clicking, we see that
                    the Command fires as soon as the mouse cursor enters the Button.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-114.png"/>
                    <figcaption>Fig 04-114</figcaption>
                </figure>
                <h3>EventToCommand Demo 2: Moving a Template to a ResourceDictionary</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-011" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-011">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-012" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-012">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>Now let's show something different. This is a ListBox in a Silverlight application</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-115.png"/>
                    <figcaption>Fig 04-115</figcaption>
                </figure>
                <p>Here, too, what I show is applicable also in WPF. In Windows 8, we would use a ListView or a
                    GridView, and in Windows Phone, a LongListSelector, but the principle is exactly the same. It has
                    some design time data defined in a DataTemplate.
                </p>
                <p>If we switch to Visual Studio and in the XAML, we can see that the DataTemplate is defined directly
                    in the UserControl.Resources.
                </p>
<figure>
<pre><code class="xml">&lt;UserControl.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;ResourceDictionary.MergedDictionaries&gt;
                &lt;ResourceDictionary Source="Skins/MainSkin.xaml" /&gt;
            &lt;/ResourceDictionary.MergedDictionaries&gt;

            &lt;DataTemplate x:Key="DataTemplate1"&gt;
                &lt;Grid Height="138"
                      Width="272"&gt;
                    &lt;Grid.Background&gt;
                        &lt;LinearGradientBrush EndPoint="0.5,1"
                                             StartPoint="0.5,0"&gt;
                            &lt;GradientStop Color="#FF646464"
                                          Offset="0" /&gt;
                            &lt;GradientStop Color="#FFA6A6A6"
                                          Offset="1" /&gt;
                        &lt;/LinearGradientBrush&gt;
                    &lt;/Grid.Background&gt;

                    &lt;TextBlock HorizontalAlignment="Left"
                               TextWrapping="Wrap"
                               Text="{Binding Model.Title, Mode=OneWay}"
                               VerticalAlignment="Top"
                               Foreground="White"
                               FontFamily="Arial"
                               FontSize="24"
                               Margin="10" /&gt;
                &lt;/Grid&gt;
            &lt;/DataTemplate&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/UserControl.Resources&gt;</code></pre>
<figcaption>Fig04-116</figcaption>
</figure>
                <p>So I can add a MouseLeftButtonDown event to the Grid:</p>
<figure>
<pre><code class="xml">&lt;Grid Height="138"
      Width="272"
      MouseLeftButtonDown="ItemMouseLeftButtonDown"&gt;
    &lt;Grid.Background&gt;
</code></pre>
<figcaption>Fig04-117</figcaption>
</figure>
                <p>and I can implement the Event Handler directly in the code behind.</p>
<figure>
<pre><code class="csharp">private void ItemMouseLeftButtonDown(
	object sender, MouseButtonEventArgs e)
{
	var element = (FrameworkElement)e.OriginalSource;
	var item = (DataItemViewModel).element.DataContext;

	MessageBox.Show(item.Model.Title);
}
		</code></pre>
<figcaption>Fig04-118</figcaption>
</figure>
                <p>
                    If I run the application now and click one of the items, we see that the event handler fires and
                    everything works well:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-119.png"/>
                    <figcaption>Fig 04-119</figcaption>
                </figure>
                <p>
                    However, I may want to clean up this XAML and move the DataTemplate inside a ResourceDictionary. So
                    now I'm going to cut this out:
                </p>
                <figure>
<pre><code class="xml">
            &lt;DataTemplate x:Key="DataTemplate1"&gt;
                &lt;Grid Height="138"
                    Width="272"
                    MouseLeftButtonDown="ItemMouseLeftButtonDown"&gt;
                    &lt;Grid.Background&gt;
                        &lt;LinearGradientBrush EndPoint="0.5,1"
                                             StartPoint="0.5,0"&gt;
                            &lt;GradientStop Color="#FF646464"
                                          Offset="0" /&gt;
                            &lt;GradientStop Color="#FFA6A6A6"
                                          Offset="1" /&gt;
                        &lt;/LinearGradientBrush&gt;
                    &lt;/Grid.Background&gt;

                    &lt;TextBlock HorizontalAlignment="Left"
                               TextWrapping="Wrap"
                               Text="{Binding Model.Title, Mode=OneWay}"
                               VerticalAlignment="Top"
                               Foreground="White"
                               FontFamily="Arial"
                               FontSize="24"
                               Margin="10" /&gt;
                &lt;/Grid&gt;
            &lt;/DataTemplate&gt;
</code></pre>
                    <figcaption>Fig04-120</figcaption>
                </figure>
                <p>and I'm going to go into the MainSkin.xaml ResourceDictionary, which is already merged into the
                    UserControl.Resources:</p>
<figure>
<pre><code class="xml">&lt;UserControl.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;ResourceDictionary.MergedDictionaries&gt;
                &lt;ResourceDictionary Source="Skins/MainSkin.xaml" /&gt;
            &lt;/ResourceDictionary.MergedDictionaries&gt;
            &lt;/ResourceDictionary&gt;
    &lt;/UserControl.Resources&gt;
</code></pre>
<figcaption>Fig04-121</figcaption>
</figure>
                <p>Let's do that. Here is MainSkin, and I'm going to paste the code that I copied just before:</p>
<figure>
<pre><code class="xml">&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
                    xmlns:Custom="http://www.galasoft.ch/mvvmlight"&gt;

    &lt;DataTemplate x:Key="DataTemplate1"&gt;
        &lt;Grid Height="138"
            Width="272"
            MouseLeftButtonDown="ItemMouseLeftButtonDown"&gt;
            &lt;Grid.Background&gt;
                &lt;LinearGradientBrush EndPoint="0.5,1"
                                     StartPoint="0.5,0"&gt;
                    &lt;GradientStop Color="#FF646464"
                                  Offset="0" /&gt;
                    &lt;GradientStop Color="#FFA6A6A6"
                                  Offset="1" /&gt;
                &lt;/LinearGradientBrush&gt;
            &lt;/Grid.Background&gt;

            &lt;TextBlock HorizontalAlignment="Left"
                       TextWrapping="Wrap"
                       Text="{Binding Model.Title, Mode=OneWay}"
                       VerticalAlignment="Top"
                       Foreground="White"
                       FontFamily="Arial"
                       FontSize="24"
                       Margin="10" /&gt;
        &lt;/Grid&gt;
    &lt;/DataTemplate&gt;
&lt;/ResourceDictionary&gt;</code></pre>
<figcaption>Fig04-122</figcaption>
</figure>
                <p>If I try to run the application now, I'm going to get an error:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-123.png"/>
                    <figcaption>Fig 04-123</figcaption>
                </figure>
                <p>because the MouseLeftButtonDown event handler is not found. And, of course, there is absolutely no
                    way to add this event handler inside the ResourceDictionary, because there is no code behind. Let's
                    modify this example to use EventToCommand to select a Command defined on the item represented by
                    this DataTemplate.</p>
                <p>So first I'm removing the event handler</p>
<figure>
<pre><code class="xml">&lt;DataTemplate x:Key="DataTemplate1"&gt;
        &lt;Grid Height="138"
            Width="272"
            MouseLeftButtonDown="ItemMouseLeftButtonDown"&gt;</code></pre>
<figcaption>Fig04-124</figcaption>
</figure>
                <p>and then let's show the Command itself, which is defined here inside the DataItemViewModel.</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-125.png"/>
                    <figcaption>Fig 04-125</figcaption>
                </figure>

                <p>So here we see the ShowItemCommand, which is going to show a MessageBox using the Model.Title:</p>
                <figure>
<pre><code class="csharp">/// &lt;summary&gt;
/// Gets the ShowItemCommand.
/// &lt;/summary&gt;
public RelayCommand ShowItemCommand
{
    get
    {
        return _showItemCommand
            ?? (_showItemCommand = new RelayCommand(
                                  () =>
                                  {
                                      MessageBox.Show(Model.Title);
                                  }));
    }
}</code></pre>
    <figcaption>Fig04-126</figcaption>
</figure>
                <p>
                    Here is how you would do this in Blend. First I'm going to edit the DataTemplate of the ListBox.</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-127.png"/>
                    <figcaption>Fig 04-127</figcaption>
                </figure>
                <p>
                    And then I'm going to take an EventToCommand in the Assets Library and drag it on the Grid
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-128.png"/>
                    <figcaption>Fig 04-128</figcaption>
                </figure>
                <p>
                    Then I'm going to go to the Properties panel and I'm going to configure the Command property using
                    the Data Binding Editor:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-129.png"/>
                    <figcaption>Fig 04-129</figcaption>
                </figure>
                <p>and here Blend knows that the DataContext of this DataTemplate is the DataItemViewModel, on which the
                    ShowItemCommand is defined:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-130.png"/>
                    <figcaption>Fig 04-130</figcaption>
                </figure>
                <p>Now if I run the application again, we can see that we can click on the item and then the Command is
                    executed, which is just fine:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-131.png"/>
                    <figcaption>Fig 04-131</figcaption>
                </figure>
                <p>
                    If we want to move the Command to the MainViewModel, this is possible too. Here we are inside the
                    MainViewModel class and we have such a Command here:</p>
<figure>
<pre><code class="csharp">public RelayCommand&lt;DataItemViewModel&gt; ShowItemCommand
    {
        get
        {
            return _showItemCommand
                ?? (_showItemCommand = new RelayCommand&lt;DataItemViewModel&gt;(
                    item =&gt;
                    {
                        var message = string.Format("In MainVM: {0}", item.Model.Title);
                        MessageBox.Show(message);
                    }));
        }
    }
}</code></pre>
<figcaption>Fig04-132</figcaption>
</figure>
                <p>
                    This Command receives an item, this is a DataItemViewModel, and then it will create a message and
                    use a MessageBox to show this message. Notice how we use item.Model.Title:</p>
<figure>
<pre><code class="csharp"> var message = string.Format("In MainVM: {0}", item.Model.Title);
    MessageBox.Show(message);</code></pre>
<figcaption>Fig04-133</figcaption>
</figure>
                <p>In Blend, it is very easy to retarget the Command. Let's go and Edit the ItemTemplate:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-134.png"/>
                    <figcaption>Fig 04-134</figcaption>
                </figure>
                <p>Then I will select the EventToCommand:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-135.png"/>
                    <figcaption>Fig 04-135</figcaption>
                </figure>
                <p>
                    and open the Data Binding Editor:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-136.png"/>
                    <figcaption>Fig 04-136</figcaption>
                </figure>
                <p>
                    Because of the way that the MVVM Light Application is structured, I can see the ViewModelLocator as
                    a data source, I can select it and see the MainViewModel property, and here, the
                    ShowItemCommand:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-137.png"/>
                    <figcaption>Fig 04-137</figcaption>
                </figure>
                <p>
                    Notice that this Command expects a DataItemViewModel as parameter:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-138.png"/>
                    <figcaption>Fig 04-138</figcaption>
                </figure>
                <p>
                    So let's select it here. And after I press OK, I need to set up the CommandParameter property. I
                    need to pass a reference to the DataItemViewModel itself. This is a little unusual, because the
                    DataItemViewModel is the DataContext of the DataTemplate. Let's open the Data Binding Editor:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-139.png"/>
                    <figcaption>Fig 04-139</figcaption>
                </figure>
                <p>
                    and now we see that the DataContext of this Binding is a DataItemViewModel, which is just what I
                    want. So I don't select any property:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-140.png"/>
                    <figcaption>Fig 04-140</figcaption>
                </figure>
                <p>
                    but instead I just press OK. Now I can run the application again. And this time if I select, we see
                    that we are in the MainViewModel, and this is item #1:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-141.png"/>
                    <figcaption>Fig 04-141</figcaption>
                </figure>
                <p>
                    and here is item #2.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-142.png"/>
                    <figcaption>Fig 04-142</figcaption>
                </figure>
                <p>
                    Here is a syntax in XAML. Here we see the Interaction.Triggers:
                </p>
<figure>
<pre><code class="xml">&lt;i:Interaction.Triggers&gt;
	&lt;i:EventTrigger EventName="MouseLeftButtonDown"&gt;
		&lt;Custom:EventToCommand
			Command="{Binding Main.ShowItemCommand, Source={StaticResource Locator}}"
			CommandParameter="{Binding Mode=OneWay}" /&gt;
	&lt;/i:EventTrigger&gt;
&lt;/i:Interaction.Triggers&gt;</code></pre>
<figcaption>Fig04-143</figcaption>
</figure>
                <p>
                    this is an attached property, just like before we had Interactions.Behaviors. Then we have the
                    EventTrigger:
                </p>
<figure>
<pre><code class="xml">&lt;i:EventTrigger EventName="MouseLeftButtonDown"&gt;</code></pre>
<figcaption>Fig04-144</figcaption>
</figure>
                <p>
                    which is configured to use a MouseLeftButtonDown event. Here is the EventToCommand itself:
                </p>
<figure>
<pre><code class="xml">&lt;Custom:EventToCommand
			Command="{Binding Main.ShowItemCommand, Source={StaticResource Locator}}"
			CommandParameter="{Binding Mode=OneWay}" /&gt;</code></pre>
<figcaption>Fig04-145</figcaption>
</figure>
                <p>
                    which is using the Command property data bound through the StaticResource Locator, to the
                    Main.ShowItemCommand. And finally, we have the CommandParameter, which is a Binding to the
                    DataContext itself, represented by this DataTemplate.
                </p>
                <h3>EventToCommand Demo 3: DataTrigger and EventToCommand</h3>
                <p>For the next sample, we will use a DataTrigger inside of an EventTrigger in the Windows Phone
                    Application. In standard MVVM scenarios, it is actually quite rare to use DataTrigger, because most
                    data operations can be done directly in the ViewModel.</p>
                <p>But here, I will show an example where we use two ViewModels located in a satellite assembly. We will
                    pretend that both ViewModels cannot communicate with each other, and so we will use an
                    EventToCommand coupled with a DataTrigger to do that.</p>
                <p>Here is the application in question:</p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-011" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\eventtocommand\EventToCommandSamples.WP8.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-011">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-012" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\eventtocommand\EventToCommandSamples.WP8.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-012">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>The MainViewModel and the SettingsViewModel are located in a
                    referenced assembly here:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-146.png"/>
                    <figcaption>Fig 04-146</figcaption>
                </figure>
                <p>The MainViewModel has one Command, called ValidateCommand:</p>
<figure>
<pre><code class="csharp"> public RelayCommand ValidateCommand
{
    get
    {
        return _validateCommand
            ?? (_validateCommand = new RelayCommand(
                                  () =&gt;
                                  {
                                      Result = "Command was executed";
                                  }));
    }
}</code></pre>
<figcaption>Fig04-147</figcaption>
</figure>
                <p>
                    This command will simply set a text into the string property named Result.
                </p>
<figure>
<pre><code class="csharp">public string Result</code></pre>
<figcaption>Fig04-148</figcaption>
</figure>
                <p>
                    As for the SettingsViewModel, we have the Value property:
                </p>
<figure>
<pre><code class="csharp">public int Value
{
    get
    {
        return _value;
    }
    set
    {
        Set(ValuePropertyName, ref _value, value);
    }
}
</code></pre>
<figcaption>Fig04-149</figcaption>
</figure>
                <p>
                    which is an integer, and then we have the IncDecCommand</p>
<figure>
<pre><code class="csharp">public RelayCommand&lt;string&gt; IncDecCommand</code></pre>
<figcaption>Fig04-150</figcaption>
</figure>
                <p>
                    which we use to increment or decrement the Value.</p>
                <p>
                    Both these ViewModels are exposing the ViewModelLocator as properties for easy access.</p>
                <p>
                    Now let's open the MainPage in Blend. Here we see the Decrement and Increment buttons, which are
                    using the corresponding command in the SettingsViewModel:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-151.png"/>
                    <figcaption>Fig 04-151</figcaption>
                </figure>
                <p>
                    The Value is shown below the buttons. The textbox below, which shows Waiting' for the moment, is
                    bound to the Result property on the MainViewModel.</p>
                <p>
                    So really this view is a composite of two ViewModels, which is a little bit unusual, but which
                    happens sometimes when you build larger applications. The scenario we want to fulfill is to listen
                    to the Value property, and when it reaches a Value of 0, we want to trigger the ValidateCommand on
                    the MainViewModel. There are, of course, multiple ways to solve that, and here for the illustration,
                    I will solve this using a DataTrigger.</p>
                <p>
                    Let's add an EventToCommand to the page from the Assets Library:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-152.png"/>
                    <figcaption>Fig 04-152</figcaption>
                </figure>
                <p>
                    As we saw before, the default TriggerType is an EventTrigger, but here we want to use a DataTrigger,
                    so I will click on the New button:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-153.png"/>
                    <figcaption>Fig 04-153</figcaption>
                </figure>
                <p>
                    In the dialog, I will select a DataTrigger from the Microsoft.Expression.Interactions DLL, which is
                    a library from the SDK:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-154.png"/>
                    <figcaption>Fig 04-154</figcaption>
                </figure>
                <p>
                    There are multiple other triggers, such as KeyTrigger for the keyboard, a TimerTrigger, etc. Here I
                    select the DataTrigger and then I click OK.</p>
                <p>
                    The DataTrigger requires a Binding, which we will set thanks to the Binding Editor:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-155.png"/>
                    <figcaption>Fig 04-155</figcaption>
                </figure>
                <p>
                    Let's navigate through the ViewModelLocator, as a data source, to the SettingsViewModel. And here we
                    select the Value property, and I can click OK:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-156.png"/>
                    <figcaption>Fig 04-156</figcaption>
                </figure>
                <p>
                    You can verify that the Value is correct thanks to the Value -5 shown here:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-157.png"/>
                    <figcaption>Fig 04-157</figcaption>
                </figure>
                <p>
                    Then we will set the Trigger Value to 0:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-158.png"/>
                    <figcaption>Fig 04-158</figcaption>
                </figure>
                <p>
                    So when the Value property reaches 0, the trigger will fire. Know that you can use some Comparison
                    operators, such as Equal, NotEqual, GreaterThan, LessThan, etc:</p>

                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-159.png"/>
                    <figcaption>Fig 04-159</figcaption>
                </figure>
                <p>
                    Finally, let's configure the Command. And here we will make a Binding to the MainViewModel's
                    ValidateCommand property:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-160.png"/>
                    <figcaption>Fig 04-160</figcaption>
                </figure>
                <p>
                    This way, we have established the connection between the SettingsViewModel and the MainViewModel
                    without touching these two components, only through Data Binding.</p>
                <p>
                    Now we can test the application. If I click on the Increment button:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-161.png"/>
                    <figcaption>Fig 04-161</figcaption>
                </figure>
                <p>when it reaches 0, we see that the Command was executed, and the Result property is set, as expected.
                </p>
                <h3>EventToCommand Demo 4: EventArgsConverter</h3>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-013" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\before\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-013">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex04-014" type="text"
                               value="C:\Development Tutorials\Pluralsight Courses\MVVM Light Toolkit Fundamentals\Module 4\after\eventtocommand\EventToCommandSamples.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex04-014">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>In this example, we will handle the MouseClick on the blue rectangle:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-162.png"/>
                    <figcaption>Fig 04-162</figcaption>
                </figure>
                <p>
                    We want the ViewModel to know where the MouseClick occurred, relatively to the top-left corner of
                    TheRectangle itself. The MouseButtonEventArgs has a method called GetPosition, which allows us to do
                    this calculation. If we set PassEventArgsToCommand to true, the MouseButtonEventArgs will be passed
                    down to the Command as its parameter, but this is not a clean interaction, because ideally the
                    ViewModel should not know about the objects at all. So let's see how we can set an
                    EventArgsConverter up.</p>
                <p>
                    Here is the EventArgsConverter, this is called MouseButtonEventArgsToPointConverter:</p>
<figure>
<pre><code class="csharp">public class MouseButtonEventArgsToPointConverter : IEventArgsConverter
{
    public object Convert(object value, object parameter)
    {
        var args = (MouseButtonEventArgs)value;
        var element = (FrameworkElement)parameter;

        var point = args.GetPosition(element);
        return point;
    }
}</code></pre>
<figcaption>Fig04-163</figcaption>
</figure>
                <p>
                    and implements the IEventArgsConverter interface from MVVM Light. This interface requires only one
                    method, called Convert. It has two arguments, the value and the parameter. Let's first set up the
                    XAML markup. Here we have the EventToCommand code:</p>
<figure>
<pre><code class="xml">&lt;i:Interaction.Triggers&gt;
	&lt;i:EventTrigger EventName="MouseLeftButtonDown"&gt;
		&lt;mvvm:EventToCommand Command="{Binding ShowPointCommand}"
                     PassEventArgsToCommand="True"
                     EventArgsConverter="{StaticResource MouseToPointConverter}"
                     EventArgsConverterParameter="{Binding ElementName=TheRectangle}" /&gt;
	&lt;/i:EventTrigger&gt;
&lt;/i:Interaction.Triggers&gt;</code></pre>
<figcaption>Fig04-164</figcaption>
</figure>
                <p>
                    We set the EventArgsConverter property to a StaticResource:</p>
<figure>
<pre><code class="xml">&lt;mvvm:EventToCommand Command="{Binding ShowPointCommand}"
		 PassEventArgsToCommand="True"
		 EventArgsConverter="{StaticResource MouseToPointConverter}"
		 EventArgsConverterParameter="{Binding ElementName=PageRoot}" /&gt;	</code></pre>
<figcaption>Fig04-164A</figcaption>
</figure>
                <p>which is defined in the page's resources:</p>
<figure>
<pre><code class="xml">&lt;Window.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;helpers:MouseButtonEventArgsToPointConverter
                x:Key="MouseToPointConverter" /&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/Window.Resources&gt;</code></pre>
<figcaption>Fig04-165</figcaption>
</figure>
                <p>
                    This is an instance of the MouseButtonEventArgsToPointConverter class that we just saw:</p>
                <figure>
                    <pre><code class="xml">EventArgsConverter="{StaticResource MouseToPointConverter}"</code></pre>
                    <figcaption>Fig04-166</figcaption>
                </figure>
                <p>
                    As EventArgsConverterParameter, we set the Binding to the ElementName, TheRectangle, itself:</p>
<figure>
<pre><code class="xml">EventArgsConverterParameter="{Binding ElementName=TheRectangle}" /&gt;</code></pre>
<figcaption>Fig04-167</figcaption>
</figure>
                <p>
                    Here we can see the Name of TheRectangle element:</p>
<figure>
<pre><code class="xml">&lt;Rectangle Fill="Blue"
    x:Name="TheRectangle"
    HorizontalAlignment="Right"
</code></pre>
<figcaption>Fig04-168</figcaption>
</figure>
                <p>
                    This is the actual element on which the EventToCommand is applied. And here in the page resources,
                    we have the MouseButtonEventArgsToPointConverter, which is defined:</p>
<figure>
<pre><code class="csharp">&lt;helpers:MouseButtonEventArgsToPointConverter x:Key="MouseButtonEventArgsToPointConverter" /&gt;
	&lt;/ResourceDictionary&gt;</code></pre>
<figcaption>Fig04-169</figcaption>
</figure>
                <p>
                    Of course, as usual, this converter could also be defined in the application resources. Inside the
                    converter, the MouseButtonEventArgs is received as a value and TheRectangle is a parameter.</p>
<figure>
<pre><code class="csharp">public object Convert(object value, object parameter)
{
	var args = (MouseButtonEventArgs)value;
	var element = (FrameworkElement)parameter;</code></pre>
<figcaption>Fig04-170</figcaption>
</figure>
                <p>
                    So we can cast these two elements and do the calculation here:</p>
<figure>
<pre><code class="csharp">var point = args.GetPosition(element);</code></pre>
<figcaption>Fig04-171</figcaption>
</figure>
                <p>
                    The returned value, in this case a point:</p>
<figure>
<pre><code class="csharp">return point;</code></pre>
<figcaption>Fig04-172</figcaption>
</figure>
                <p>
                    will be passed to the Command as a CommandParameter.</p>
                <p>
                    Finally, here is a RelayCommand code inside the MainViewModel:</p>
<figure>
<pre><code class="csharp">public RelayCommand&lt;Point&gt; ShowPointCommand
{
	get
	{
		return _showPointCommand
			?? (_showPointCommand = new RelayCommand&lt;Point&gt;(
				point =&gt;
				{
					var message = string.Format(
						"{0} : {1}",
						point.X,
						point.Y);

					MessageBox.Show(message);
				}));
	}
}</code></pre>
<figcaption>Figo4-173</figcaption>
</figure>
                <p>
                    Notice how the point, which is a result of the calculation of the EventArgsConverter, is received
                    and how we can use it to format a message and then show this message in the MessageBox.</p>
                <p>
                    Of course in a real-life application, we would probably use this point to do additional
                    calculations. If we run the application now, we can click on TheRectangle and see the position
                    relatively to the top-left corner of TheRectangle:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-174.png"/>
                    <figcaption>Fig 04-174</figcaption>
                </figure>
                <p>
                    We can also easily change the parameter to reference a page itself. Here, the page has a Name set to
                    PageRoot:</p>
<figure>
<pre><code class="xml">&lt;Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:ignore="http://www.ignore.com"
        xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
        xmlns:mvvm="http://www.galasoft.ch/mvvmlight"
        xmlns:helpers="clr-namespace:EventToCommandSamples.Wpf.Helpers"
        x:Class="EventToCommandSamples.Wpf.MainWindow"
        x:Name="PageRoot"</code></pre>
<figcaption>Fig04-175</figcaption>
</figure>
                <p>
                    So if I go into the Parameter value here, I can change TheRectangle with PageRoot:</p>
<figure>
<pre><code class="xml">&lt;i:EventTrigger EventName="MouseLeftButtonDown"&gt;
                    &lt;mvvm:EventToCommand Command="{Binding ShowPointCommand}"
                                         PassEventArgsToCommand="True"
                                         EventArgsConverter="{StaticResource MouseButtonEventArgsToPointConverter}"
                                         EventArgsConverterParameter="{Binding ElementName=TheRectangle}" /&gt;</code></pre>
<figcaption>Fig04-176</figcaption>
</figure>
                <p>
                    and then if I run the application again, we will see that the position is now displayed in reference
                    to the page's top-left corner; for example, here, the top-left point of TheRectangle itself:</p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig04-177.png"/>
                    <figcaption>Fig 04-177</figcaption>
                </figure>
                <p>
                    This example is quite clean, because the ViewModel only knows the point class, which is not directly
                    related to the View. It is a level of abstraction, which is comfortable. We could, of course,
                    imagine other examples; for example, with Drag & Drop.</p>
                <p>
                    The EventArgsConverter is an advanced tool, but it is very convenient when you want to perform
                    specific calculations inside the ViewModel.
                </p>
                <h3>EventToCommand vs. InvokeCommandAction</h3>
                <p>If you've used the Blend SDK before, you may have noticed an action named InvokeCommandAction. This
                    action fulfills the same purpose in EventToCommand and can be used instead of EventToCommand in many
                    scenarios; however, it does not have a way to pass the EventArgs to the Command or to convert them.
                    This is why EventToCommand is still the recommended way to trigger commands in advanced
                    scenarios.</p>
                <p>
                    In Windows 8.1, however, the Blend Team took our feedback and added a way to convert EventArgs and
                    pass them to the Command. This is what the InputConverter and InputConverterParameter are for. Note
                    that the InputConverter is an IValueConverter, so it is a slightly different implementation than in
                    MVVM Light.</p>
                <p>
                    Because the InvokeCommandAction is fulfilling the same features as EventToCommand in Windows 8.1,
                    there are currently no plans to port EventToCommand to this version of the XAML framework. In
                    Windows 8.0, there are no Blend behaviors at all; however, at this
                    <a href="http://www.galasoft.ch/s/msdncommand" target="_blank">URL</a>, you will find a workaround,
                    which allows you to use something similar to EventToCommand, even if you cannot upgrade to Windows
                    8.1 for some reason.</p>
                <p>
                    For reference, here is a XAML syntax in Windows 8.1 for InvokeCommandAction with a Command Binding,
                    the InputConverter, and a Parameter:</p>
                <figure>
<pre><code class="xml">&lt;TextBox&gt;
	&lt;interactivity:Interaction.Behaviors&gt;
		&lt;core:EventTriggerBehavior EventName="KeyDown"&gt;
			&lt;core:InvokeCommandAction
				Command="{Binding MyCommand, Mode=OneWay}"
				InputConverter="{StaticResource KeyEventArgsToStringConverter}"
				InputConverterParameter="This is a {0} test" /&gt;
		&lt;/core:EventTriggerBehavior&gt;
	&lt;/interactivity:Interaction.Behaviors&gt;
&lt;/TextBox&gt;</code></pre>
                    <figcaption>Fig04-178</figcaption>
                </figure>
                <p>
                    And again, in other XAML frameworks, InvokeCommandAction does not support the InputConverter, in
                    which case you may want to use EventToCommand instead.
                </p>
                <h3>Summary</h3>
                <p>In this module, we talked about the architecture of an MVVM Light application and about the extra
                    components of MVVM Light. We started this module with a discussion about DataContext and how it can
                    be data bound to the View.</p>
                <p>
                    We introduced the ViewModelLocator, an object which is not part of the MVVM Light assemblies, but
                    rather introduced in typical MVVM Light applications as a place to set the application services up,
                    to set up the IOC container, and to provide some binding points for the View in a way that is
                    optimized for the Visual Designers.
                </p>
                <p>
                    Then, we talked about the reasons for having a separate assembly for the SimpleIoc and the
                    EventToCommand. We understood that it is because of the third party reference assemblies that these
                    components use, and one thing to make it easier for everyone to use the core components.</p>
                <p>
                    Then we had a long, in-depth study of SimpleIoc; an IOC container that is easy to use, but powerful
                    enough to cover many of the needs for a client application. SimpleIoc is well suited for MVVM
                    applications, and it works beautifully in DesignMode with Blend, so it is a good component to know
                    when working closely with designers, which is a trademark of the MVVM Light Toolkit.</p>
                <p>
                    The last component of MVVM Light that we studied is EventToCommand, an action that works coupled
                    with a trigger, such as an EventTrigger or a DataTrigger. First, we understood what Blend behaviors
                    are and how they can be added to an element and configured. Then we saw specifically how
                    EventToCommand can be used to handle any event of any UI element and invoke a command when the event
                    fires. We also saw how EventToCommand can be used with a DataTrigger instead.</p>
                <p>
                    And finally, we discussed the EventArgsConverter, which is useful to cleanly handle event arguments
                    in the Command directly at the ViewModel level.</p>
                <p>
                    The next module will show how MVVM Light is installed on a machine, either as a standalone complete
                    installation or with NuGet. Then we will review the Project Templates, Item Templates, and the Code
                    Snippets; some important components that can get you started faster.
                </p>
            </div>
        </div>
    </div>
</div>
