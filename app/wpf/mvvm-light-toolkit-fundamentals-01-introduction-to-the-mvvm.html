<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Introduction to the MVVM</h2>
            </div>
            <div class="panel-body">
                <p>Hello and welcome to this course. My name is Laurent Bugnion, and I'm going to talk to you about the MVVM Light
                    Toolkit. MVVM Light is an open-source toolkit, a suite of components which will help you to develop decoupled
                    applications according to the Model-View-ViewModel Pattern.
                </p>
                <p>So Toolkit is available for all XAML-based frameworks; for example, Windows Presentation Foundation,
                    Silverlight, Windows Phone, and Windows RT. The MVVM Pattern is very popular for XAML developers. For some of
                    you, it is a very well-known pattern, but for others it is quite new, and this is why we are going to start
                    with an introduction to MVVM.
                </p>
                <p>First, we are going to build a simple application and we are not going to use the Model-View-ViewModel Pattern
                    here, but we are going to use a classic architecture and some events. We are going to see some of the
                    disadvantages of this approach. And finally, we will have a small theory part about understanding MVVM,
                    understanding which layers are playing together, and how they communicate.
                </p>
                <p>In the next module, we are going to refactor this application to a Model-View-ViewModel application, and this
                    will help us to understand how the basic components of MVVM work and how they can be composed together to
                    create a more maintainable and more testable application.
                </p>
                <h3>Showing the Data Service Output</h3>
                <p>Let's start the demo with an application that we are going to build without MVVM:</p>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex01-001" type="text" value="C:\Development Tutorials\Pluralsight-Courses\MVVM Light Toolkit Fundamentals\Module 1\before\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex01-001">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <div class="example">
                    <div class="input-group">
                        <input id="Ex01-002" type="text" value="C:\Development Tutorials\Pluralsight-Courses\MVVM Light Toolkit Fundamentals\Module 1\after\WhyMvvm.sln">
                        <span class="input-group-btn">
                	        <button class="btn" data-clipboard-target="#Ex01-002">
                        	    <img src="app/images/clippy.svg" width="13" alt="Copy to clipboard">
                            </button>
        	            </span>
                    </div>
                </div>
                <p>And this is going to be a Windows Phone 8 Application connecting to a data service running on the web. Now this
                    data service is delivering data in the form of JSON, and we are going to have one big object with a data
                    property, which is an array of another type of object here with a unique id, a first_name, a last_name, a
                    picture, a location, a message, etc. Now we are going to name this object here, the friend, and this is going
                    to be the list of friends.
                </p>
                <h3>Building the Model</h3>
                <p>In Visual Studio, I created a Windows Phone 8 Application. This is an absolutely standard application, I just
                    added a Model folder and a DetailsPage, to which we will navigate later to see the details of the friend:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-001.png"/>
                    <figcaption>Fig 01-001</figcaption>
                </figure>
                <p>Inside the Model folder I have a Constants file, this is shared with the web service.</p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Model
{
    public static class Constants
    {
        public const string ActionGet = "get";
        public const string ActionReset = "reset";
        public const string ActionSave = "save";
        public const string Code = "A7DFF044AACD45F6AD91F2ADF9306397";
        public const string QueryKeyAction = "action";
        public const string QueryKeyCode = "code";
    }
}</code></pre>
                    <figcaption>Fig01-002</figcaption>
                </figure>
                <p>And here I'm going to add an object, which we are going to use for the deserialization of the JSON. Let's call
                    that object, ListOfFriends.
                </p>
                <p>I'm going to make that class public, and then I'm going to add some content. Here we are:</p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Model
{
    public class ListOfFriends
    {
        public List&lt;Friend&gt; Data
        {
            get;
            set;
        }
    }
}</code></pre>
                    <figcaption>Fig01-003</figcaption>
                </figure>
                <p>We have one property called Data, which maps to the JsonProperty("data") with a small â€˜d', and this is a
                    JsonProperty, so I'm going to use Json.NET to deserialize this. In order to use Json.NET, I will use NuGet. So
                    let's go and look for Json.NET in the online NuGet package source. Here we are:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-004.png"/>
                    <figcaption>Fig 01-004</figcaption>
                </figure>
                <p>
                    And then I'm going to select here Json.NET Install. And now this is added. So I can use here the
                    JsonPropertyAttribute:
                </p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Model
{
    public class ListOfFriends
    {
        [JsonProperty("data")]
        public List&lt;Friend&gt; Data
        {
            get;
            set;
        }
    }
}</code></pre>
                    <figcaption>Fig01-005</figcaption>
                </figure>
                <p>Now I need a friend class. So let's go into the Model, Add, New Class. I'm going to call that Friend, and let's
                    make this public. The Friend class is very simple, it has a few JsonProperty's; the Id, the FirstName, the
                    LastName, and an Update method that we are going to use later if we modify the Friend:
                </p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Model
{
    public class Friend
    {
        [JsonProperty("id")]
        public int Id
        {
            get;
            set;
        }

        [JsonProperty("first_name")]
        public string FirstName
        {
            get;
            set;
        }

        [JsonProperty("last_name")]
        public string LastName
        {
            get;
            set;
        }

        public void Update(Friend updatedFriend)
        {
            FirstName = updatedFriend.FirstName;
            LastName = updatedFriend.LastName;
        }
    }
}
</code></pre>
                    <figcaption>Fig01-006</figcaption>
                </figure>
                <h3>Building the Client Data Service</h3>
                <p>Then I'm going to add an interface to the Models folder. And I'm going to call that, IFriendsService. And this
                    is what I will use to connect to the data service, this is the definition of the service. I'm going to have
                    two methods; one method Refresh, which is returning an IEnumerable of Friends, and then the other method,
                    Save, which is going to take a modified Friend and then it's going to return a string, which is going to be
                    the id of the Friend. If the Friend was a new Friend on the service, it's going to be the new id. Note that
                    those two methods are returning Tasks of, which means that they are awaittable, so we are going to use a new
                    await and async mechanism here to call Refresh and Save:
                </p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Model
{
    public interface IFriendsService
    {
        Task&lt;IEnumerable&lt;Friend&gt;&gt; Refresh();
        Task&lt;string&gt; Save(Friend updatedFriend);
    }
}
</code></pre>
                    <figcaption>Fig01-007</figcaption>
                </figure>
                <p>Now I want to implement this interface, so I'm going to add a New Class, call that FriendsService. And then I'm
                    going to make this public and implement IFriendsService. Here we go:
                </p>
                <figure>
<pre><code class="csharp">namespace WhyMvvm.Model
{
    public class FriendsService : IFriendsService
    {
        public Task&lt;IEnumerable&lt;Friend&gt;&gt; Refresh()
        {
            throw new NotImplementedException();
        }

        public Task&lt;string&gt; Save(Friend updatedFriend)
        {
            throw new NotImplementedException();
        }
    }
}
</code></pre>
                    <figcaption>Fig01-008</figcaption>
                </figure>
                <p>Now the first thing I'm going to add is a UrlBase; this is a base URL of the web service:</p>
                <figure>
                    <pre><code class="csharp">private const string UrlBase = "http://www.galasoft.ch/labs/friends/handle.ashx?code={0}&{1}={2}&seed={3}";</code></pre>
                    <figcaption>Fig01-009</figcaption>
                </figure>
                <p>
                    I have a few parameters that I need to fill. And then here I have the Refresh method, so let's implement this:
                </p>
                <figure>
<pre><code class="csharp">public Task&lt;IEnumerable&lt;Friend&gt;&gt; Refresh()
{
    var client = new HttpClient();

    var uri = new Uri(string.Format(
        UrlBase,
        Constants.Code,
        Constants.QueryKeyAction,
        Constants.ActionGet,
        DateTime.Now.Ticks));

    var json = await client.GetStringAsync(uri);

    var result = JsonConvert.DeserializeObject&lt;ListOfFriends&gt;(json);
    return result.Data;
}</code></pre>
                    <figcaption>Fig-</figcaption>
                </figure>
                <p>And here the Refresh method is going to use an HttpClient. Now for those of you familiar with Windows 8, you
                    may have already seen this class, HttpClient, but maybe you know that in Windows Phone we don't have
                    HttpClient yet. So I'm going to use here something which is pretty new. Let's go to Manage NuGet Packages. And
                    here I'm going to select Include Prerelease, and select here HttpClient. This is a new library released by
                    Microsoft, which allows you to use the same HttpClient than in Windows 8, but to use that in Windows Phone as
                    well:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-011.png"/>
                    <figcaption>Fig 01-011</figcaption>
                </figure>
                <p>I'm going to install that. Now if you prefer to use the classic web client, of course you can do that as well.
                    This is just to make it a little bit easier later to share code with Windows 8. Here we go. Everything was
                    installed, and now I can use here the HttpClient. And what I'm going to do here is create a new HttpClient:
                </p>

                <figure>
                    <pre><code class="csharp">var client = new HttpClient();</code></pre>
                    <figcaption>Fig01-011A</figcaption>
                </figure>
                <p>create the uri with a few Constants (this is a Get):</p>
                <figure>
<pre><code class="csharp">var uri = new Uri(string.Format(
        UrlBase,
        Constants.Code,
        Constants.QueryKeyAction,
        Constants.ActionSave,
        DateTime.Now.Ticks));</code></pre>
                    <figcaption>Fig01-011B</figcaption>
                </figure>

                <p>and then I'm going to await GetStringAsync, which is going to return to me the json:</p>
                <figure>
                    <pre><code class="csharp">var json = await client.GetStringAsync(uri);</code></pre>
                    <figcaption>Fig01-011C</figcaption>
                </figure>
                <p>Because I have await, I need to make this method async:
                </p>
                <figure>
                    <pre><code class="csharp">public async Task&lt;IEnumerable&lt;Friend&gt;&gt; Refresh()</code></pre>
                    <figcaption>Fig01-012</figcaption>
                </figure>
                <p>and finally I'm going to Deserialize the result here in the ListOfFriends and return the list of actual Friend
                    objects to the caller:
                </p>
                <figure>
<pre><code class="csharp">var result = JsonConvert.DeserializeObject&lt;ListOfFriends&gt;(json);
return result.Data;</code></pre>
                    <figcaption>Fig01-013</figcaption>
                </figure>
                <p>In order to Save. What I'm going to do is also build an HttpClient. I'm going to build the uri (this time with
                    Save instead of Get). I'm going to take the updatedFriend and serialize it in json:
                </p>
                <figure>
<pre><code class="csharp">public Task&lt;string&gt; Save(Friend updatedFriend)
{
    var client = new HttpClient();

    var uri = new Uri(string.Format(
        UrlBase,
        Constants.Code,
        Constants.QueryKeyAction,
        Constants.ActionSave,
        DateTime.Now.Ticks));

    var json = JsonConvert.SerializeObject(updatedFriend);
}</code></pre>
                    <figcaption>Fig01-014</figcaption>
                </figure>
                <p>And then, I'm going to build a StringContent with MediaTypeHeaderValue("application/json"), and then I'm going
                    to post this JSON file to this URI:
                </p>
                <figure>
<pre><code class="csharp">try
{
    var content = new StringContent(json);
    content.Headers.ContentType = new MediaTypeHeaderValue("application/json");

    var response = await client.PostAsync(uri, content);
    var result = await response.Content.ReadAsStringAsync();

    return result;
}
catch (Exception)
{
    return "0";
}</code></pre>
                    <figcaption>Fig01-015</figcaption>
                </figure>
                <p>Again, this is an awaitable method, so I need to make this method async:</p>
                <figure>
                    <pre><code class="csharp">public async Task&lt;string&gt; Save(Friend updatedFriend)</code></pre>
                    <figcaption>Fig01-016</figcaption>
                </figure>
                <p>Finally I'm going to read the result, which as I'll remind you is the id of the Friend, and I'm going to return
                    that:
                </p>
                <figure>
<pre><code class="csharp">var result = await response.Content.ReadAsStringAsync();

return result;</code></pre>
                    <figcaption>Fig01-017</figcaption>
                </figure>
                <h3>Creating the UI of the MainPage</h3>
                <p>Now I'm ready to do some UI. So let's go into the XAML. And here, inside my page (MainPage.xaml), I'm going to
                    add to the ContentPanel:
                </p>
                <figure>
<pre><code class="xml">&lt;Grid x:Name="ContentPanel"
      Grid.Row="1"
      Margin="12,0,12,0"&gt;</code></pre>
                    <figcaption>Fig01-017A</figcaption>
                </figure>

                <p>a LongListSelector, this is the list control, here we go, and I name that List:
                </p>
                <figure>
<pre><code class="xml">&lt;phone:LongListSelector x:Name="List"
       ItemTemplate="{StaticResource FriendTemplate}"/&gt;</code></pre>
                    <figcaption>Fig01-018</figcaption>
                </figure>
                <p>
                    Now I also prepared a Refresh button, so let's go and add here, a Click event:
                </p>
                <figure>
<pre><code class="xml">&lt;phone:PhoneApplicationPage.ApplicationBar&gt;
        &lt;shell:ApplicationBar&gt;
            &lt;shell:ApplicationBarIconButton IconUri="/Assets/AppBar/refresh.png"
                                            Text="refresh"
                                            Click="RefreshClick"/&gt;</code></pre>
                    <figcaption>Fig01-019</figcaption>
                </figure>
                <p>And then in the code behind, I'm going to add some code here. The first thing I'm going to do is create a new
                    FriendsService. Then I'm going to call Refresh, which is an await table method, so I need to make this async.
                    And then I'm going to assign the ListOfFriends to the ItemsSource property of the LongListSelector:
                </p>
                <figure>
<pre><code class="csharp">private async void RefreshClick(object sender, System.EventArgs e)
{
    var service = new Model.FriendsService();
    var list = (await service.Refresh()).ToList();

    List.ItemsSource = list;

}</code></pre>
                    <figcaption>Fig01-020</figcaption>
                </figure>
                <p>Now the LongListSelector needs a DataTemplate, so here I name that FriendTemplate:</p>
                <figure>
<pre><code class="xml">&lt;phone:LongListSelector x:Name="List"
    ItemTemplate="{StaticResource FriendTemplate}"/&gt;</code></pre>
                    <figcaption>Fig01-021</figcaption>
                </figure>
                <p>and for this DataTemplate I'm going to keep things simple. I just created here two TextBlocks; the first one
                    bound to FirstName and the second one bound to LastName:
                </p>
                <figure>
<pre><code class="xml">&lt;phone:PhoneApplicationPage.Resources&gt;
        &lt;DataTemplate x:Key="FriendTemplate"&gt;
            &lt;StackPanel Orientation="Horizontal"
                        Tap="FriendTap"&gt;
                &lt;TextBlock Text="{Binding FirstName}"
                           Style="{StaticResource NameTextBlockStyle}" /&gt;

                &lt;TextBlock Text="{Binding LastName}"
                           Style="{StaticResource NameTextBlockStyle}" /&gt;
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/phone:PhoneApplicationPage.Resources&gt;</code></pre>
                    <figcaption>Fig01-022</figcaption>
                </figure>
                <p>Now notice that I had to type this by hand, so I don't have any Visual help, any Visual Designer, and this is
                    what we are going to improve later when we have the design time data.
                </p>
                <h3>Navigation and DetailsPage</h3>
                <p>Now we want to navigate to the DetailsPage when a Friend is Tapped. So the first thing I will do is add here a
                    Tap event to the StackPanel:
                </p>
                <figure>
<pre><code class="xml">&lt;StackPanel Orientation="Horizontal"
    Tap="FriendTap"&gt;</code></pre>
                    <figcaption>Fig01-023</figcaption>
                </figure>
                <p>And then inside the Event Handler, I'm going to get the element that was Tapped, I'm going to get DataContext,
                    which in the XAML-based framework is set to the element, which is currently represented by the item control.
                    So now, okay, it is a Friend. And then I'm going to Save this Friend somewhere.
                </p>
                <figure>
<pre><code class="csharp"> private void FriendTap(object sender, System.Windows.Input.GestureEventArgs e)
{
    var element = (FrameworkElement)sender;
    var friend = element.DataContext as Friend;

    if (friend == null)
    {
        return;
    }

    App.SelectedFriend = friend;
    NavigationService.Navigate(new Uri("/DetailsPage.xaml", UriKind.Relative));

}</code></pre>
                    <figcaption>Fig01-024</figcaption>
                </figure>
                <p>But here in this application, this is not easy, because I don't have really an object which is persistent, I
                    only have pages. And in order to Save the Friend, I'm going to use here the application, which is a global
                    object:
                </p>
                <figure>
                    <pre><code class="csharp">App.SelectedFriend = friend;</code></pre>
                    <figcaption>Fig01-025</figcaption>
                </figure>
                <p>Now it's not super clean, but this will do for this very simple non-MVVM application. And later we will see how
                    we can clean this up. Let's add the SelectedFriend to the application (App.xaml.cs). It's a static property,
                    so again it is not very clean:
                </p>
                <figure>
<pre><code class="csharp">public static Friend SelectedFriend
{
    get;
    set;
}</code></pre>
                    <figcaption>Fig01-026</figcaption>
                </figure>
                <p>And then (back in MainPage.xaml.cs), I'm going to call the NavigationService in order to Navigate to the
                    DetailsPage:
                </p>
                <figure>
<pre><code class="csharp">App.SelectedFriend = friend;
NavigationService.Navigate(new Uri("/DetailsPage.xaml", UriKind.Relative));</code></pre>
                    <figcaption>Fig01-027</figcaption>
                </figure>
                <p>Now within the DetailsPage.xaml.cs I'm going to retrieve this object, and I'm going to do that inside the
                    OnNavigatedTo method:
                </p>
                <figure>
<pre><code class="csharp"> protected override void OnNavigatedTo(System.Windows.Navigation.NavigationEventArgs e)
{
    base.OnNavigatedTo(e);

    if (App.SelectedFriend != null)
    {
        FirstNameTextBox.Text = App.SelectedFriend.FirstName;
        LastNameTextBox.Text = App.SelectedFriend.LastName;

        PreviewFirstNameTextBlock.Text = App.SelectedFriend.FirstName;
        PreviewLastNameTextBlock.Text = App.SelectedFriend.LastName;
    }
}</code></pre>
                    <figcaption>Fig01-028</figcaption>
                </figure>
                <p>Here we are. And then inside OnNavigatedTo, what I will do is check if I have a SelectedFriend. And if, yes,
                    I'm going to set TextProperty of FirstNameTextBox and LastNameTextBox, and I also have a Preview, which is
                    just a small UI, in order to see what the DataTemplate is going to look like:
                </p>
                <p>Now that I have this, I'm going to do one more thing to DetailsPage.xaml; I'm going to worry about what happens
                    when the user is modifying the TextBoxes. So here I have the FirstNameTextBox and LastNameTextBox, and here
                    again, I need to use some Event Handler, so I'm going to use here the TextChanged Event Handler and call that
                    FirstNameTextChanged:
                </p>
                <figure>
<pre><code class="xml">&lt;TextBox x:Name="FirstNameTextBox"
     TextChanged="FirstNameTextChanged"/&gt;</code></pre>
                    <figcaption>Fig01-029</figcaption>
                </figure>
                <p>
                    Let's create this Event Handler:
                </p>
                <figure>
<pre><code class="csharp">private void FirstNameTextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
{
}
</code></pre>
                    <figcaption>Fig01-030</figcaption>
                </figure>
                <p>And then for the other one, I'm going to have here, of course, LastNameTextChanged:</p>
                <figure>
<pre><code class="xml">&lt;TextBox x:Name="LastNameTextBox"
     TextChanged="LastNameTextChanged"/&gt;</code></pre>
                    <figcaption>Fig01-031</figcaption>
                </figure>
                <p>Here we go. Again, create the Event Handler. And now inside the Event Handler what I'm going to do is, again,
                    get this global Friend and set the FirstName to the Text property of the TextBox:
                </p>
                <figure>
<pre><code class="csharp">private void FirstNameTextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
{
    App.SelectedFriend.FirstName = ((TextBox)sender).Text;
    PreviewFirstNameTextBlock.Text = App.SelectedFriend.FirstName;

}</code></pre>
                    <figcaption>Fig01-032</figcaption>
                </figure>
                <p>And I'm going to do the same for the LastName:</p>
                <figure>
<pre><code class="csharp">private void LastNameTextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
{
    App.SelectedFriend.LastName = ((TextBox)sender).Text;
    PreviewLastNameTextBlock.Text = App.SelectedFriend.LastName;

}</code></pre>
                    <figcaption>Fig01-033</figcaption>
                </figure>
                <p>So again, here I'm using some global object, which is not super clean, but right now in this event-based
                    application, this is what we have.
                </p>
                <h3>Saving the Data Object, Testing</h3>
                <p>Finally, I'm going to have a Save button (DetailsPage.xaml), here we are, I prepared it earlier:</p>
                <figure>
<pre><code class="xml">&lt;shell:ApplicationBarIconButton IconUri="/Assets/AppBar/save.png"
   Text="save"
   Click="SaveClick"/&gt;
&lt;/shell:ApplicationBar&gt;</code></pre>
                    <figcaption>Fig01-034</figcaption>
                </figure>
                <p>And here, again, I'm going to add a Click event, SaveClick, and inside the code behind, I'm going to call the
                    data service and I'm going to call the Save method with the SelectedFriend. And again, this is an awaitable
                    operation, so I need to add async on this method. And in case of Errors, I'm going to use here the MessageBox
                    to Show the message
                </p>
                <figure>
<pre><code class="csharp"> private async void SaveClick(object sender, System.EventArgs e)
{
    try
    {
        var service = new Model.FriendsService();
        var result = await service.Save(App.SelectedFriend);

        var id = int.Parse(result);

        if (id > 0)
        {
            App.SelectedFriend.Id = id;
        }
        else
        {
            MessageBox.Show("Error");
        }
    }
    catch (Exception)
    {
        MessageBox.Show("Error");
    }

}</code></pre>
                    <figcaption>Fig01-035</figcaption>
                </figure>
                <p>So here we are, our application is complete, and now I'm going to test that. So I'm going to run the code
                    inside the Emulator, I'm going to refresh my list:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-036.png"/>
                    <figcaption>Fig 01-036</figcaption>
                </figure>
                <p>I'm going to tap here on the first friend, I can Edit the name, for example ttt, and then I can save here this
                    friend.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-037.png"/>
                    <figcaption>Fig 01-037</figcaption>
                </figure>
                <p>And then if I go back, I see that the friend has been saved; and if I refresh, we see that the name remains the
                    same. So, the application has actually saved the changes to the web service.
                </p>
                <h3>Summarizing the Issues of Non-MVVM</h3>
                <p>This small application works fine, but it has quite a few issues that we want to correct using the
                    Model-View-ViewModel Pattern. Notably, we have quite a lot of code behind. Now code behind is not always bad
                    in an application, and in fact, sometimes you just need some code behind; for example if you want to start
                    some animations, coordinate them together, show some messages to the user, etc. But here we have really too
                    much code behind, and we are using a lot of Event Handlers.
                </p>
                <p>Those Event Handlers are going to tightly couple the XAML to the application. For example, if we open
                    MainPage.xaml, we see that have here the Tapped Event Handler, called FriendTap, and this is going to
                    complicate our life because we cannot move this DataTemplate to a resource dictionary:
                </p>
                <figure>
<pre><code class="xml">&lt;phone:PhoneApplicationPage.Resources&gt;
        &lt;DataTemplate x:Key="FriendTemplate"&gt;
            &lt;StackPanel Orientation="Horizontal"
                        Tap="FriendTap"&gt;
                &lt;TextBlock Text="{Binding FirstName}"
                           Style="{StaticResource NameTextBlockStyle}" /&gt;

                &lt;TextBlock Text="{Binding LastName}"
                           Style="{StaticResource NameTextBlockStyle}" /&gt;
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/phone:PhoneApplicationPage.Resources&gt;</code></pre>
                    <figcaption>Fig01-038</figcaption>
                </figure>
                <p>
                    Resource dictionaries have great advantages; for example, they allow an integrator, or a designer, to work on
                    the UI of the application while a developer is working on the pages. They also allow you to structure your
                    XAML resources in a very neat manner, but here we cannot move this DataTemplate out of the page's XAML,
                    because otherwise the compilation is going to fail when the compiler doesn't find the FriendTap Event Handler.
                </p>
                <p>Another issue is a lack of design time data. If I go in Expression Blend and open the MainPage, I can find the
                    list, which is a LongListSelector. But notice that I don't have any data appearing:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-039.png"/>
                    <figcaption>Fig 01-039</figcaption>
                </figure>
                <p>Of course this is normal because Blend is not going to execute any code, but we can treat Expression Blend in
                    creating design time data and giving this some visual elements that we can visually design and edit into
                    Blend. So when we refactor the application to MVVM in the next module, we are going to add the design time
                    data service, which is going to help us doing some visual design in Blend.
                </p>
                <p>A few of the problems in the code, we have an App.xaml.cs. This static property:</p>
                <figure>
<pre><code class="csharp">public static Friend SelectedFriend
{
    get;
    set;
}</code></pre>
                    <figcaption>Fig01-039A</figcaption>
                </figure>

                <p>
                    which is part of the global application object, this is not very elegant and we would like to find a way to
                    store this SelectedFriend somewhere else in a more modular manner.
                </p>
                <p>
                    Finally, this application would be very difficult to unit test. Notably because we have a lot of code into
                    pages, so we would have to create those pages inside the unit test. We also have some code inside the global
                    application, so again we would have to create that object, which is really difficult in a unit test. We have
                    all of the Event Handlers, which are private methods, so of course they cannot be executed from a unit test.
                    All those issues make the application very hard to test, very hard to maintain, and very hard to extend with
                    additional features.
                </p>
                <p>Let's summarize the issues that we just saw:</p>

                <ul>
                    <li>Code behind is difficult to maintain and to extend.</li>
                    <li>We have some coupling because we are using a lot of Event Handlers from the XAML inside the code behind,
                        and that makes modifying the XAML very difficult. </li>
                    <li>Because we have a lot of code in the code behind, we need the developer every time that we want to make
                        small changes to the UI. </li>
                    <li>We don't have any design time data, which makes editing the application in Expression Blend or in the
                        Visual Studio Designer extremely difficult. </li>
                    <li>And finally, the application is very hard, or maybe even impossible, to unit test.</li>
                </ul>
                <h3>Theory: Understanding the MVVM Pattern (1)</h3>
                <p>Let's talk now about the Model-View-ViewModel Pattern and understand how it is working. The MVVM Pattern is a
                    variation of the very well-known MVC Pattern; the Model-View-Controller Pattern. Model-View-Controller is
                    quite an old pattern, it was developed around 1984, and it is very, very widely used, especially in web-based
                    frameworks; for example ASP.NET MVC or the Ruby on Rails framework.
                </p>
                <p>Here we have a Model, which is where the data comes from; it could be a database, it could be web services,
                    etc. We have the View, which is what the user is seeing and actuating. And we have a Controller, which is
                    coordinating all the actions. It is in charge of refreshing the Model, it is in charge of displaying data in
                    the View, and it is in charge of reacting to events from the View in order to refresh the Model or to save a
                    data object, for example.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-040.png"/>
                    <figcaption>Fig 01-040</figcaption>
                </figure>
                <p>MVC is very widely used, but when you work with XAML, there is another pattern which is even better, especially
                    because of the DataBinding system. A few years ago, Martin Fuller came up with the idea of the Presentation
                    Model Pattern. So here we have a pattern which is quite similar to MVC, we still have the Model and the View,
                    but instead of having a Controller object, what we have is a series of smaller Presentation Models, or
                    ViewModels:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-041.png"/>
                    <figcaption>Fig 01-041</figcaption>
                </figure>
                <p>And in fact, what we typically do is that we have one ViewModel per View. We will see that there are some
                    exceptions to this rule, but in general this is what we tried to do. The View is interacting directly with the
                    ViewModel, through a two-way interaction system. For the most part, this two-way interaction system is what we
                    call DataBinding in XAML:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-042.png"/>
                    <figcaption>Fig 01-042</figcaption>
                </figure>
                <p>So here, we have a system which allows us to bind properties from an UI element to a property of an object, in
                    that case a ViewModel, and we can do that directly in the XAML markup without having to use some code. And of
                    course because we do that in the XAML markup directly, this is very tool-friendly, which is why we can use a
                    Visual Designer to create those DataBindings, like we will see later when we refactor the application.
                </p>
                <h3>Theory: Understanding the MVVM Pattern (2)</h3>
                <p>Let's take a closer look at the layers in a typical Model-View-ViewModel application. Between the ViewModel and
                    the Model, the interaction is very classic. We have methods called from the ViewModel to the Model, we have
                    events from the Model to the ViewModel, and maybe other interactions, but this remains quite classic:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-043.png"/>
                    <figcaption>Fig 01-043</figcaption>
                </figure>
                <p>Between the View and the ViewModel, I already mentioned that we have DataBindings, but very often we also have
                    DataBindings going between the View and the Model directly, especially if the data objects are implementing
                    INotifyPropertyChanged, which is not very complicated to do and which presents us from having to wrap every
                    data object in order to make it observable:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-044.png"/>
                    <figcaption>Fig 01-044</figcaption>
                </figure>
                <p>The View can also actuate methods on the ViewModel, and for this we are going to use something called Commands,
                    where we'll see an example when we refactor the application to MVVM. And of course we will gain deeper
                    understanding of commands later in this course.
                </p>
                <p>
                    Finally, from the ViewModel to the View, sometimes DataBindings are not so efficient. DataBindings are great
                    to update properties on the View; for example the text, the value of the checkbox, etc. But sometimes you need
                    something a little bit more complex; for example when you have to coordinate animations or when you have to
                    display a dialog to the user and get his feedback. For example, using some View Services, which we'll see a
                    little bit later, or some kind of event bus sending messages:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-045.png"/>
                    <figcaption>Fig 01-045</figcaption>
                </figure>
                <p>
                    An application very rarely has just one View and one ViewModel. So usually we have multiple Views, multiple
                    ViewModels, and interactions between them. And here too, we can use messages, services, or maybe even Messages
                    + callbacks, which we'll talk about later in this course:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-046.png"/>
                    <figcaption>Fig 01-046</figcaption>
                </figure>
                <p>Let's take an even closer look at the ViewModel -> View Communication. From the ViewModel, it is of course
                    possible to call a MessageBox directly, but this is probably not a very good idea because a MessageBox is a
                    View element, which is going to be actuated directly from the ViewModel:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-047.png"/>
                    <figcaption>Fig 01-047</figcaption>
                </figure>
                <p>This is going to cause issues, especially when we do unit tests, because a unit test cannot verify that the
                    MessageBox has been displayed, and it cannot dismiss a MessageBox. Other operations are very difficult, or
                    maybe even impossible to execute directly from the ViewModel; for example, Animations or Navigation between
                    pages, which is why we typically don't do this:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-048.png"/>
                    <figcaption>Fig 01-048</figcaption>
                </figure>
                <h3>Theory: Understanding the MVVM Pattern</h3>
                <p>Instead, we have multiple abstracted ways to interact from the ViewModel to the View. One of these ways is
                    using something called a Behavior. A Behavior is a small piece of code behind, which is encapsulated and
                    reusable in multiple pages or even multiple applications. So we will place a Behavior on the View, and from
                    the ViewModel, we are going to interact by setting a property and using a DataBinding between the Behavior and
                    this property:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-049.png"/>
                    <figcaption>Fig 01-049</figcaption>
                </figure>
                <p>So here, again, we have a very decoupled and flexible interaction, where we can modify the UI, change the
                    Behaviors, without having to modify the ViewModel.
                </p>
                <p>Another way to interact from the ViewModel to the View is to use something called View Services. Here we are
                    going to declare an abstraction, an interface, which defines which methods can be used. For example,
                    IDialogService will have some methods, such as ShowMessage, ShowError, etc:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-050.png"/>
                    <figcaption>Fig 01-050</figcaption>
                </figure>
                <p>This interface is going to be injected inside the ViewModel. This is a technique which is very popular
                    nowadays, called Dependency Injection, and we will talk about that in a moment:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-051.png"/>
                    <figcaption>Fig 01-051</figcaption>
                </figure>
                <p>Then we will have a class implement a DialogService, and this class is going to interact with the page
                    directly:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-052.png"/>
                    <figcaption>Fig 01-052</figcaption>
                </figure>
                <p>Another such example is INavigationService, which will have methods like GoBack and NavigateTo and here to we
                    will have an object implementing this and acting on the View directly to perform the navigation:
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-053.png"/>
                    <figcaption>Fig 01-053</figcaption>
                </figure>
                <p>View Services are very convenient when you want to unit test your ViewModel. Because in that case, we can
                    simply disconnect the DialogService, and instead we are going to provide custom implementation of the
                    DialogService, which we call the Mock or a Stub. In that case, let's call that MockDialogService. And we will
                    let the ViewModel use this well-known implementation of the DialogService during the Unit Test.
                </p>
                <figure><img src="app/wpf/images/mvvmlighttoolkitfundamentals/Fig01-054.png"/>
                    <figcaption>Fig 01-054</figcaption>
                </figure>
                <p>In summary, we can say that:</p>
                <ul>
                    <li>Code behind is not always bad, sometimes it is absolutely necessary in an application, but it can
                        complicate things. </li>
                    <li>So Model-View-ViewModel Pattern is a variation of the Model-View-Controller Pattern.</li>
                    <li>The goal is to create an application, which has less coupling, especially between the View and the
                        Model. </li>
                    <li>This will make the application easier to maintain and easier to test</li>
                    <li>It will also allow us to create some design time data in order to work in a more comfortable manner in
                        Blend or in the Visual Studio Designer. </li>
                </ul>
                <p>
                    In the next module, we will take the same application and refactor it to MVVM, which will allow us to
                    understand the different components and their interaction, and we are also going to add some design time data,
                    and finally, create a unit test for this simple application.
                </p>
            </div>
        </div>
    </div>
</div>