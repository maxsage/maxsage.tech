<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Course Outline</h2>
            </div>
            <div class="panel-body">
                <p>
                    Hi, this is Brian Noyes, and welcome to this course on WPF Data Binding in Depth. In this course,
                    you'll get a good, deep, end-to-end coverage of the data binding capabilities in WPF, enabling you
                    to build rich, data-driven business applications. You'll see how data binding can really transform
                    the way you go about building out your user interface, populating it with data, and rendering out
                    the visual elements that the user sees on the screen.
                </p>
                <p>
                    We'll start off the course with a Data Binding Overview. We'll cover the fundamentals of data
                    binding to make sure everyone has a good level set, even if you have been exposed before, of what
                    the basic building blocks with data binding are.
                </p>
                <p>
                    Now this course does not attempt to teach you everything you need to know about building XAML
                    applications. I would strongly recommend you check out one of the other courses in the Pluralsight
                    library. The focus in this course is just going to be on everything to do about data binding.
                </p>
                <p>
                    So after we go through the fundamentals, then we'll also talk about data sources, specifically what
                    kinds of data objects you can use for data binding and what kinds of support those objects need to
                    have to participate properly with the data binding mechanisms. We'll look at things at an entity
                    level, we'll talk about data sets, XML, and Collections that you'll work with.
                </p>
                <p>
                    Next we'll get into the core concepts of the bindings themselves. We'll talk about how you can
                    provide alternate source objects, other than the data context that we've talked about up to that
                    point. We'll talk about the Path property and how that indicates what part of the data bound object
                    to use to come up with a value, and we'll talk about the direction of flow of data through a
                    binding.
                </p>
                <p>
                    In the next module, we'll dive to a deeper level on bindings and we'll go through a whole bunch of
                    additional properties that bindings have for advanced scenarios. You probably won't use all of these
                    on a regular basis, but you'll want to know they're there and how they work when the situation comes
                    up to use them. This includes things like being able to do asynchronous bindings, changing when the
                    data flows in two-way data binding scenarios, having fallback values and formatted values, and
                    things like that.
                </p>
                <p>
                    In the fifth module, we'll go into data templates . Data templates are one of the most powerful
                    mechanisms in data binding that allow you to provide a custom visual representation for the data
                    bound objects you're working with, and these get rendered out by WPF itself. So we'll see how to
                    define data templates and how to tie them in with your bindings.
                </p>
                <p>
                    Next we'll get into Design Time Data Binding, and you'll see that there's some wonderful features in
                    Visual Studio for being able to drag-and-drop and generate user interface elements based on the data
                    objects that you're working with, and in the process, getting the data bindings hooked up to the
                    appropriate properties on those user interface elements. You'll also see how to work with Design
                    Time data, sample data, that can be rendered in the Design Time environment to help you get your
                    user interface laid out correctly.
                </p>
                <p>
                    In the next module, we'll drill under the covers a little bit and let you see what's going on with
                    the dynamic generation of controls in containers based on data binding. We'll also review the
                    collection controls such as list boxes, combo boxes, tab controls, and data grids, and cover all the
                    important properties and usage of those in data bound scenarios.
                </p>
                <p>
                    Finally, we'll finish off the course with validation. Anytime you input data and start editing data,
                    you need to make sure you're getting good data into the system. Bindings in WPF directly support
                    evaluating validation and providing error indications to the user when input values are invalid. So
                    we'll see how all that works, what the options are, and how to get it tied in with your bindings. So
                    that's the game plan. Let's dive right in and start getting you up and running with data binding .
                </p>
                <img src="images/Fig00-01.png" class="image"/>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Data Binding Overview</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi there. This is Brian Noyes, and in this first module we're going to go through a high-level
                    overview of what data binding is all about in WPF, why you want to use it, and what some of the
                    fundamental concepts are that you'll need to master to understand the rest of the course, where
                    we'll dive deep enough to turn you into a data binding ninja.
                </p>
                <p>
                    First I'm going to go through a high-level overview of what data binding is all about and why you
                    want to use it, what some of the benefits are, and what it does for you. Next I'll talk about some
                    of the key concepts, things like bindings and

                    DataContext

                    , and Change Notifications , and the role that they play in using data binding .
                </p>
                <p>
                    Then I'll go a little bit deeper on

                    DataContext

                    and talk about the scoping mechanisms of

                    DataContext

                    and how you can use it to control what data flows to what part of your views.
                </p>
                <p>
                    And then we'll finish off the module with a series of demos that starts off with a data-driven form,
                    not using data binding at all, then transforming that to use data binding to see some of the
                    benefits there, and finally, cleaning that up a little bit by consolidating your data sources into a
                    single

                    DataContext

                    object.
                </p>
            </div>
            <div class="panel-body">
                <h3>Data Binding Overview</h3>
                <p>
                    So let's start off by talking about what data binding is about and why it's important to you. First
                    off, data binding is one of the more powerful XAML platform features and it's certainly not limited
                    to just WPF. A lot of the things we're going to be talking about in this course apply equally to
                    Windows 8 development, Windows Phone development, and even the somewhat defunct Silverlight.
                    Certainly there are other platform features such as visual states and styling and resources that are
                    equally as important and what makes XAML a great platform for developing applications, but data
                    binding stands out to me as one of the most powerful features because of how it lets you architect
                    your application.
                </p>
                <p>
                    First off, it promotes loose coupling , and loose coupling means different things, but in the
                    context of data binding what it does is it lets you decouple, first off, the View from the data
                    model . So the data model objects that get loaded up with data and that you're going to use to
                    ultimately drive what you see on the screen, the view doesn't need to be tightly coupled to exactly
                    what type of objects those are, how they get populated, where they're held in memory, and so on.
                </p>
                <p>
                    Additionally, you can keep the view decoupled from the data access that populates those data models
                    , so whether you get objects over service calls, go directly out to a relational database, load them
                    up from flat files, the view doesn't have to know anything about that. And most specifically, when
                    we're talking about view here, we really mean the elements within the view that represent the
                    renderable content that you see on screen. Additionally through data binding , the view can stay
                    decoupled from the interaction logic, the logic that gets invoked when the user clicks on something,
                    selects something, navigates around the application, all of that stuff can be decoupled from the
                    elements of the view using data binding . Now to fully achieve that, you really have to take a step
                    further and consider something like the


                    Model-View-ViewModel


                    pattern, but it's really data binding that makes that possible.
                </p>
                <p>
                    Additionally, data binding reduces the overall amount of code you'll have to write and you'll see
                    that in the demos towards the end of the module. So that reduction in code can mean shorter time to
                    market in getting your app out there at first, and it means less time to create new features and fix
                    bugs when you're maintaining the application. So that code reduction comes in, in several forms. One
                    is that the automatic data flow to and from the screen that data binding enables, means that you
                    have to write less code to explicitly push and pull data from individual properties on elements
                    within the screen.
                </p>
                <p>
                    Additionally, just in terms of conceptualizing and implementing the code, it allows you to form
                    natural associations between data objects and their properties and screen elements that are going to
                    render out the content of those objects.
                </p>
                <p>
                    One of the other benefits of data binding is it facilitates a developer-designer workflow. Now what
                    that means is that one of the key concepts in XAML-based applications is the idea that you should be
                    able to take your XAML and hand it over to a professional designer and let them go party on that
                    XAML and change elements and add animations, and style it like crazy, and it shouldn't break
                    anything in the app, but the more the elements are tightly coupled to the code-behind, especially
                    with lots of push-pull logic and stuff like that, then it's going to be harder for the designer to
                    swap out, say, a label for a textbox, because the properties on those elements that you're going to
                    push data into is going to change with the change of an element.
                </p>
                <p>
                    With data binding you just have declarations in the XAML that the designer can be in control of and
                    they can move those bindings around and put them on the appropriate properties on the elements as
                    they switch things out. So this allows designers to work more in isolation and independently from
                    the developers and not have to coordinate on every little change that they make.
                </p>
                <p>
                    Now another important concept the data binding leads into is the

                    Model-View-ViewModel

                    pattern, MVVM. I'm not going to go into any depth on MVVM in this course. I would recommend you
                    check out my other Pluralsight course, Building Windows 8 MVVM Applications, because in that course
                    I cover the MVVM pattern, the concepts behind it, and I'd say a good 70-80% of what I cover in that
                    course equally applies to WPF. You would have to ignore some of the Windows 8 specifics such as the
                    application lifecycle and navigation schemas of Windows 8, which are different in WPF, but the
                    fundamentals of the MVVM pattern are covered well there and apply equally to WPF.
                </p>
                <p>
                    Now for most of this course I am not going to use MVVM in my demos, just to emphasize that data
                    binding is powerful and useful in its own right and you don't have to do the MVVM pattern to get
                    benefit out of it. But if you're considering going down that road, it's important to realize that
                    you're never going to get there without being good at data binding. Data binding is the most
                    important aspect of being able to decouple the views and ViewModels and the data flow and
                    communication between those, because the bindings form the bond between the view and its ViewModel
                    in a loosely coupled way.
                </p>
            </div>
            <div class="panel-body">
                <h3>Data Access vs Data Binding</h3>
                <p>
                    Now one concept I want to clear up, up front, is the difference between data access vs data binding
                    , because there's common misconceptions here. Data access is all about data that sits in a
                    persistent store, and being able to load that data into some in-memory data source object. Data
                    access is about retrieving data into those data source objects in-memory from the persistent store
                    and being able to write changes back out to the persistent store. That persistent store could be a
                    relational database, it could be flat files or it could even be a service that you're making web
                    service calls out to, but conceptually you're reading data in from a persistent store and writing it
                    out and putting it into objects in-memory.
                </p>
                <img src="images/Fig01-01.png"/>
                <p>
                    Data binding , on the other hand, sits upstream of data access, so your initial focus is going to be
                    on a screen that you're trying to support. It could be a window or a user control or a view in
                    conceptual terms that you have a set of elements on that you're going to put data into, and you need
                    to flow data into those element properties to present it on screen. To do that, you need objects in
                    memory, so you have these data source objects that came from somewhere and you're going to read data
                    in from those data source objects into elements on the screen, and if those elements are editable,
                    then you're going to allow data to be written back into those data source objects when it changes on
                    screen. From data binding's perspective, it shouldn't know or care where those data source objects
                    came from or even be coupled to what kind of object they are.
                </p>
                <img src="images/Fig01-02.png"/>
            </div>
            <div class="panel-body">
                <h3>Sources and Targets</h3>
                <p>
                    Another key concept and some terminology when you're dealing with data binding are the concepts of
                    sources and targets. Ultimately, when you're doing data binding, you have some data object that
                    you're going to get some data out of that exposes properties, and those properties can be
                    collections of individual objects, they can be a single complex object or they can be properties
                    exposing primitive values, and you want to data bind those to different elements within your screen.
                </p>
                <p>
                    So, for example, we want data to flow from the Customers property on our data object into a
                    ComboBox, and populate its drop-down list. We want to have a complex object property called
                    SelectedCustomer in this case, bound to a collection of elements somewhere in our screen, in this
                    case a First Name field, Last Name field, and Email field, come off of individual properties on that
                    SelectedCustomer property. And then we might also have another collection down here, Orders, that's
                    going to flow into a DataGrid and provide the data source for that DataGrid.
                </p>
                <p>
                    When you view data binding like this, it should become clear that the data object is the source
                    object and the elements on the screen are the targets of the bindings. Now the bindings get declared
                    on the target element and point to the source object that's going to feed them. So at a high level,
                    data binding basically flows data between the source object property and the target element
                    property, discrete values that are going to flow back and forth, where those values can be a single
                    primitive value, they can be a complex object or they can be an entire collection of complex
                    objects.
                </p>
                <img src="images/Fig01-03.png"/>
                <p>
                    Now it's important to note that the terms source and target can get a little confusing because in
                    two-way data binding those fields on the screen may be editable, and if you have two-way binding
                    enabled, those arrows can reverse and allow data to flow from the target down into the source
                    object. The names don't change at that point. The source is still the source, the target is still
                    the target, in data binding terms, but just realize that the flow reverses in the case of two-way
                    data binding when edits are made in the screen.
                </p>
                <img src="images/Fig01-04.png"/>
                <p>
                    So another key thing to keep in mind is that the target properties of a binding must be
                    DependencyProperties . That typically means that they are a property defined on a framework element
                    that's part of the WPF framework, but they could be custom DependencyProperties on your own objects,
                    but the thing you hook the binding up to directly is going to be a DependencyProperty . The source
                    object property does not have to be a DependencyProperty .
                </p>
            </div>
            <div class="panel-body">
                <h3>Data Binding Building Blocks</h3>
                <p>
                    Now let's talk about the basic building blocks that you're going to use when data binding. The first
                    thing is DataContext . DataContext is a property that each framework element has that can be used to
                    flow data into the screen, so for some screen of data that you want to hook data binding up to, you
                    can think of it as a DataContext overlays that screen and provides ambient data to all of the
                    elements within the screen.
                </p>
                <p>
                    From a structural perspective, it's really that you can set a DataContext property on any element
                    and that DataContext flows down to all of the child elements that sit underneath it. So if we set
                    the DataContext to the window level, all of the child elements within that window will have access
                    to the same object that was set as the DataContext on the root window element.
                </p>
                <img src="images/Fig01-05.png"/>
                <p>
                    The next concept are bindings. Bindings provide the glue between the single element property, such
                    as the text property on a textbox and a source object property such as the FirstName property on a
                    customer. Bindings allow you to read data in from the source object property into the target element
                    property, and in two-way data binding you can also flow data back from the target element property
                    back into the source object property.
                </p>
                <img src="images/Fig01-06.png"/>
                <p>
                    Another important concept to do with binding is the way XAML parsing works. If you have some chunk
                    of XAML that's going to be rendered on the screen, the XAML parser is going to kick in and start
                    ripping through that XAML. Conceptually it's top to bottom and left to right, and it's newing up
                    objects and setting properties on those objects. As it rips through that XAML, it's going to find
                    bindings and when it first finds a binding, it goes ahead and does the initial evaluation of that
                    binding, figures out what the source object is, it dereferences a property, gets a value out of that
                    source object property, and puts it into the target element property that the binding is sitting on.
                </p>
                <img src="images/Fig01-07.png"/>
                <p>
                    Next there's the concept of Change Notifications . Change Notifications are important because if the
                    data can change behind the scenes, you want the view to stay in sync with the real state of the
                    data. So if you have some field and it's data bound to some source object property, if the source
                    object property changes, an event can fire and it can notify the binding that's up in the view, and
                    that binding will know to go and re-retrieve the value and update the view to stay in sync.
                    Likewise, as the data changes in the view, the target property can raise Change Notifications ,
                    which can trigger the binding to push the value back down into the source object property. So it's
                    these Change Notifications that allow your real data behind the scenes to stay in sync with what the
                    user sees in the screen.
                </p>
                <img src="images/Fig01-08.png"/>
            </div>
            <div class="panel-body">
                <h3>DataContexts and Scopes</h3>
                <p>
                    When it comes to working with DataContext , it's important to understand the way DataContext form a
                    scoping mechanism. So as I described before, you can set the DataContext at a window level. You just
                    set the DataContext property on that window object to some source data object, and that becomes the
                    ambient data source for all of the child elements within that window.
                </p>
                <img src="images/Fig01-09.png"/>
                <p>
                    However, you can also set a DataContext at a more granular level. So in this example I could set a
                    DataContext for the data grid and the data entry form below it to a collection of customers, and
                    that ambient source of data is just applying to those elements based on some containing element that
                    we set the DataContext on, and any bindings within that scope, by default, are going to be using
                    that DataContext as their source objects.
                </p>
                <img src="images/Fig01-10.png"/>
                <p>
                    Now when it comes to data bound list controls, it's important to realize that they will dynamically
                    set a DataContext of their own. A DataGrid, for example, as it goes and renders out each row, each
                    row is composed of a set of child elements and what it will do is set the DataContext for the
                    container of those child elements to the object that it's rendering out, the row object. So in this
                    case, this is a grid full of orders, the overall DataContext is going to be a collection of orders,
                    but the DataContext for each row is going to be an individual order object. And that means the
                    bindings on the columns themselves, for example, can just bind to the properties of a single order
                    object, they don't have to know which particular order object they're rendering out.
                </p>
                <img src="images/Fig01-11.png"/>
                <p>
                    You can also set a DataContext in a more granular fashion to a set of elements. And you would do
                    that by setting the DataContext property on some containing element such as a grid or stack panel.
                    Then, as discussed before, that DataContext flows down to all child elements. That means these
                    individual TextBoxes will have that DataContext as a customer object in this case, and they can just
                    data bind to the properties on that customer object without needing to know about what the
                    DataContext is for the rest of the form.
                </p>
                <img src="images/Fig01-12.png"/>
                <p>
                    And finally, you could set it for an individual element. It's fairly rare that you would set
                    DataContext s at that granular of level, although I will do it in the demos just to show how it
                    works.
                </p>
                <img src="images/Fig01-13.png"/>
            </div>
            <div class="panel-body">
                <h3>Demo Intro</h3>
                <p>
                    So now let's finally get to some code that demonstrates all these fundamentals. I'm going to go
                    through a series of demos starting with a data-driven form that has no data binding and talking
                    about what the structure of the code needs to be when there's no data binding present.
                </p>
                <p>
                    Then we'll transform that same thing and show how to hook up data binding and show what some of the
                    benefits are in terms of the code that you write, and we'll show how to do data binding to label a
                    TextBox, a ListBox, and a DataGrid.
                </p>
                <p>
                    Then in the final demo we'll clean that up a bit and show how you can, instead of setting a number
                    of different DataContext s for different parts of the form, you can aggregate those objects into a
                    single DataContext object. I call this Poor man's MVVM here. In the demo I'll be calling it a
                    ViewModel, but the ViewModel I'm using here doesn't follow a number of other tenets of MVVM that you
                    can learn in other courses such as my Windows 8 MVVM course. So let's dive right into some coding.
                </p>
                <img src="images/Fig01-14.png"/>
            </div>
            <div class="panel-body">
                <h3>Demo: Data Forms with No Data Binding</h3>
                <p>
                    In this first demo I want to review some of the data binding fundamentals before we dive into more
                    advanced aspects throughout the rest of the course. The data model we'll be dealing with throughout
                    the course is based around a pizza ordering company. So we have customers as a primary object,
                    customers have orders, orders have OrderItems, OrderItems are related to products, orders have an
                    order status, and we probably won't get much deeper than that in the data model for the demos that
                    we'll be doing. Now you can see in this demo I'm using an Entity Framework Database First edmx data
                    model, partly so you can visualize the schema here. In later demos I'll mostly be using Entity
                    Framework Code First.
                </p>
                <img src="images/Fig01-15.png"/>
                <p>
                    The UI that we'll be using in this demo is a simple crude data form here. At the top we have some
                    current customer information, a Customer ID has a label and a Customer Name has a TextBox. Then we
                    have a Recent Orders list, which is a ListBox that's going to be populated with dates, and when we
                    select a date there, down at the bottom in the DataGrid we're going to see the order items
                    associated with that order. We've got a Save button here so that we can modify the Customer Name and
                    save it off to the database. And we'll add some other fields as we go here to save off other
                    modifications to the customer.
                </p>
                <img src="images/Fig01-16.png"/>
                <p>
                    Now really a good starting point when it comes to considering data binding is to think about what
                    does the code need to be to support a data form like this when you don't have data binding. If we
                    drop into the code-behind here, we can see that we've got our main window, we're newing up an
                    instance of our object context, our data model, we've got a loaded event handler hooked up:
                </p>
                <img src="images/Fig01-17.png"/>
                <p>
                    In that event handler we go out through our object context, execute a query to get the first
                    customer in the customer's collection.
                </p>
                <img src="images/Fig01-18.png"/>
                <p>
                    Then comes the part that gets really tedious about not using data binding is we have to go field by
                    field and grab out values of properties on our data object, our customer in this case, and push them
                    into properties on the corresponding elements in our UI, such as the content property on a label or
                    the text property on a TextBox.
                </p>
                <img src="images/Fig01-19.png"/>
                <p>
                    Next you can see I'm executing a query to go get the orders for that current customer and selecting
                    just the OrderDate so we end up with a list of DateTime objects that we set as the ItemsSource
                    property on our ListBox.
                </p>
                <img src="images/Fig01-20.png"/>
                <p>
                    We also have a SelectionChanged event handler hooked up to the ListBox, and that's down here. And
                    here you can see we're basically going out and executing a query against the database to go to the
                    Orders collection, get the related child OrderItems, and using a Select criteria that the OrderDate
                    matches the one selected in the ListBox and the CustomerId matches the one that is the current
                    customer based on our CustomerIdLabel.
                </p>
                <img src="images/Fig01-21.png"/>
                <p>
                    You can see one of the downsides to doing it this way is that things like SelectedItem and Content
                    are declared as objects, so they can contain anything, so you end up having to do a lot of casting
                    as you move things in and out of those control properties. Once we have the OrderItems, we put those
                    as the ItemsSource on our DataGrid to drive that.
                </p>
                <p>
                    And then for our Save button you can see that we're going out and going and re-retrieving that
                    customer based on the CustomerId. We could have, likewise, held onto that customer after we
                    retrieved it in a form member variable.
                </p>
                <img src="images/Fig01-22.png"/>
                <p>
                    Once we have the customer, now we have to do some pulling of values from individual properties on
                    the controls in the UI, and putting those into individual properties on the customer object, and
                    then eventually going off and saving. And the comments are here just to emphasize that you have to
                    do this on a property by property basis for your entity because of the fact that you're just pushing
                    and pulling discrete values into the properties of controls on the UI. But with that code in place
                    we can, in fact, run this form and we can see we have our current customer at the top. We can modify
                    that customer. I'll get rid of the 42 here, click Save, close the form, start the app back up, and
                    our modification was, in fact, persisted.
                </p>
                <p>
                    When we select an order, we get the table populated down below. Now there's some nasty stuff there
                    because it's doing auto-generate columns, so we're getting these related objects, just getting
                    dumped with their type information. Here's the meaningful OrderItem information over here with the
                    related IDs, quantities, unit prices, and so on, and we can see that that changes based on the
                    selection up above. So the good news is it's fully functional, but we have to do all this pushing
                    and pulling of values in our UI, and you'll see that we can be a lot more efficient by data binding
                    . So in the next demo, we'll see how this can get better by using data binding instead.
                </p>
                <img src="images/Fig01-23.png"/>
            </div>
            <div class="panel-body">
                <h3>Demo: Data Binding Basics</h3>
                <p>
                    So now let's look at how we can start cleaning up this demo by introducing data binding. First we're
                    going to go in here to the XAML of our window and start pulling values into the XAML instead of
                    pushing things from the code-behind. So first we'll go to our CustomerIdLabel here and we'll
                    introduce a binding for the content property that says go and get me the ID property of whatever my
                    DataContext is. So whenever you see a binding that just has one thing next to it, that one thing
                    next to it is the Path or the property name on the DataContext object that flows down to this. And
                    we talked about DataContext in the slides and we'll see that we're going to set it from the
                    code-behind in a moment, but DataContext is an overall ambient data object that flows down the
                    visual tree and is accessible for data binding on elements. So this implies that for this label, at
                    least, there has to be a DataContext object that has an ID property on it, and the binding is going
                    to grab that value and put it into the content property for us.
                </p>
                <p>
                    Likewise, we can go down to our TextBox here and put Text-"(Binding LastName)". So it's the Text
                    property that we want to set, that's the target. On the source object we're expecting there to be a
                    LastName property and that source object has to be set as the DataContext for this TextBox.
                </p>
                <img src="images/Fig01-24.png"/>
                <p>
                    Next, for our ListBox, we can drop down here and we can do a binding like this. Ultimately we need
                    to get a collection into our ItemSource property and we can just use binding here and that basically
                    says, I'm expecting the DataContext for this ListBox to be a collection of something I'm going to
                    present. And by default, it will call ToString on each one of those objects if we don't do anything
                    else here. So if you remember from the previous run, we're expecting a list of order dates here. We
                    can put a list of order dates and it will call ToString on each of those and we'll see the date
                    rendered as text, but binding on its own like this implies that the source object is the DataContext
                    and that we're not looking for any particular property on that DataContext , we're expecting it to
                    be whole objects that we're pushing in as a collection here.
                </p>
                <img src="images/Fig01-25.png"/>
                <p>
                    Then we could drop down to the DataGrid and do the same thing. Now this implies that this DataGrid's
                    DataContext has to be set to whatever collection it expects to render out, which in our case happens
                    to be OrderItems. Now if you're experienced with data binding this may look a little weird, because
                    this implies that we have a different DataContext for the DataGrid, for the ListBox, and for the
                    customer-oriented controls up above, which is not something you'd normally do and we'll evolve past
                    that quickly here in the demos.
                </p>
                <img src="images/Fig01-26.png"/>
                <p>
                    So now let's drop into the code-behind and what we could do is go in here after we've retrieved our
                    first customer, we could switch things here to set the overall DataContext for the window itself to
                    that customer object. That means it's going to be set at the root level on the window and it's going
                    to flow down the visual tree to all the elements within the window and that will be their available
                    DataContext unless it is set to something different at an element level.
                </p>
                <img src="images/Fig01-27.png"/>
                <p>
                    For our OrderList, we could replace setting the ItemsSource directly with setting a DataContext for
                    that list because the ItemsSource is being set through the binding now that we added in the XAML.
                </p>
                <img src="images/Fig01-28.png"/>
                <p>
                    And then down here in our OrderSelected handler we could do the same where we replace setting the
                    ItemsSource on the DataGrid with setting a DataContext that flows into it, and then the binding on
                    the ItemsSource property in the XAML will pick it up and render it.
                </p>
                <img src="images/Fig01-29.png"/>
                <p>
                    The other thing we probably want to do is get rid of the ugly columns that we didn't intend to
                    render in the first place, so I'm going to drop down here to the DataGrid and say,
                    AutoGenerateColumns "False" and add in some column definitions that include just those columns that
                    we want to do.
                </p>
                <img src="images/Fig01-30.png"/>
                <p>
                    Now the other thing to point out here in the XAML is the way DataContext work in list bound
                    controls. So we've got the DataGrid as a whole is being set to whatever the current DataContext is
                    on that element, which we just programmatically set in the code-behind to be an OrderItems
                    collection. However, notice these bindings are assuming their DataContext has properties like Id,
                    Instructions, ProductId, and so on.
                </p>
                <img src="images/Fig01-31.png"/>
                <p>
                    That's because when a list-oriented control like a DataGrid, ListBox or ComboBox, renders out its
                    items, it sets the DataContext for the item being rendered to be the individual item. So in the case
                    of a DataGrid, it's rendering out a whole row with these columns in it, it sets the DataContext for
                    that row object to be the individual item in the collection that it's rendering. So each of these,
                    the DataContext is just a single order item, and therefore, their binding path can be equal to just
                    the property names on that object.
                </p>
                <p>
                    The other thing to point out in review here is that when you see binding Id here, this is 100%
                    equivalent to writing it this way.
                </p>
                <img src="images/Fig01-32.png"/>
                <p>
                    When you say BindingId, you're really implicitly setting the path through a parameterized
                    constructor on the binding object. So Binding Instructions here really mean set the path equal to
                    Instructions, and we'll get to other properties that the binding has in later modules.
                </p>
                <p>
                    So with that code in place, I can go ahead and run, and we can see our data has populated like
                    before and our selections happen and now we don't have the extra columns that we didn't want in the
                    first place.
                </p>
                <img src="images/Fig01-33.png"/>
                <p>
                    So if we drop into the code-behind here we can clean up those commented lines of code.
                </p>
                <img src="images/Fig01-34.png"/>
                <p>
                    The other thing to point out here is that in the OnSave method we don't have to do all this work to
                    pull individual values from controls and put them into properties on an object because the object we
                    set as the DataContext is being tracked, in our case, by Entity Framework and it knows about those
                    properties changed, because the whole object was set as the DataContext and when we're changing
                    those properties, Entity Framework is raising property Change Notifications and it knows about
                    those. So we can simply go off and save changes here and not have to do any pushing and pulling
                    anymore.
                </p>
                <img src="images/Fig01-35.png"/>
                <p>
                    So I can go ahead and run, I can modify Pucket's name, Save, shut down, and restart, and we can see
                    those changes were persisted. Now for just one editable field here, it doesn't really pay huge
                    dividends to the data binding, but where it starts to become really apparent is when you have a big
                    data entry form with lots of fields. So let's go up here and add a few more rows to our grid and
                    we'll add a few more data entry forms for other properties on a customer
                </p>
                <img src="images/Fig01-36.png"/>
                <p>
                    So now we're binding to the customer LastName, FirstName, Phone, and Email in individual TextBoxes
                    and we don't have to make any modifications to the code-behind now because the code-behind is just
                    pushing a whole customer object into the DataContext and it will flow down to all of these bindings.
                    So we could run, we could modify First Name, Last Name, Customer Phone, Save our changes, shut down,
                    and restart, and all those changes have been persisted.
                </p>
                <img src="images/Fig01-37.png"/>
                <p>
                    So now you just get to focus on the markup and deciding how do you want to render something and what
                    is the property on the DataContext that's going to give you that data.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Consolidating DataContexts</h3>
                <p>
                    Now one thing that's kind of inefficient in the previous demo in the way we are doing things is
                    we're setting the DataContext multiple times for individual controls. So here we're setting the
                    DataContext of the window as a whole to be a customer, but then we have to set a separate
                    DataContext on the ListBox and a separate DataContext on the DataGrid itself. Generally when you're
                    doing data binding you're going to try to aggregate all of the objects needed to support a given
                    screen onto some single object you can set as a DataContext , and that kind of leads to the MVVM
                    pattern, the

                    Model-View-ViewModel

                    pattern. Now I'm not really going to go into any detail on MVVM,

                    Model-View-ViewModel

                    in this course because I want to emphasize that everything about data binding you can leverage, even
                    if you don't embrace the MVVM pattern or perhaps you go do MVC or MVP as other patterns you could
                    use, data binding can still help you out there. But just to show a very lightweight form of MVVM is,
                    if we declared an instance of a main window ViewModel here and we go look in the code. And this
                    thing is actually already defined, and you can see it has the customer that we need for part of the
                    screen, order dates that we need for another part of the screen, and OrderItems that we need for
                    another part of the screen, all just exposed as properties on that ViewModel.
                </p>
                <p>
                    Now when you really do MVVM you're generally going to encapsulate down on your ViewModel the
                    interaction logic and also the data loading and saving kind of logic inside of the ViewModel and get
                    that out of the code-behind so it's more testable, but at a minimum here, to support a little bit
                    better data binding you need to aggregate all the data the screen needs on a single object so that
                    you can set an instance of that single object as your DataContext .
                </p>
                <p>
                    So if we go modify the code a little bit more, we've got this instance of the ViewModel available to
                    us now. Once we get our first customer we'll set that as the customer property on the ViewModel and
                    we'll get rid of this DataContext setting, and then once we have our OrderDates we'll set those as
                    the OrderDates property on the ViewModel and down below in our order selected we can set the
                    OrderItems property on the ViewModel to that set of OrderItems for the current order.
                </p>
                <p>
                    Now all we need to do is set the DataContext as a whole to an instance of that ViewModel. Now that
                    DataContext will be set at a window level and it'll flow down to all of the child controls. That
                    implies that we need to change some of the bindings over here in our XAML. So first off, each of
                    these bindings for customer I could prefix with Customer. and it would go to that ViewModel.customer
                    to get the object and then get to the LastName property on there, and then I'd have to say
                    Customer.FirstName down here, and so on.
                </p>
                <p>
                    Another way I could do the same thing is, because all these controls are grouped inside of this
                    grid, I could just go to the grid and set the DataContext to the grid using a binding to the
                    Customer property on our ViewModel, so it basically grabs that object reference, sets it as
                    DataContext , and everything under this grid now will just see the customer, not the ViewModel.
                </p>
                <p>
                    Then I could go down to my ListBox and change the binding to point to the OrderDates property on the
                    ViewModel, and go down to the DataGrid and change that one to point to the OrderItems. Now if we go
                    ahead and run, you can see we've got the same kind of experience up at the top as we had before, but
                    notice when I'm making selections in the OrderDate list we've got a problem, it's not actually doing
                    anything down below. You can see that we are still setting the OrderItems property here when an
                    order selection happens. So what's the issue there? Well it kind of leads into our next module and
                    working with data sources, but the problem is that we're setting this property and this is a normal
                    property and it doesn't raise any kind of change notification. So even though the value of that
                    property has changed, when our event handler fires, the data binding doesn't know anything about it.
                </p>
                <p>
                    Now as a quick workaround and to show you something we'll cover later in the course, we could force
                    it to update. If you've worked with older technologies like Windows Forms, you may have seen methods
                    called Invalidate, and variations on that, that force the form to re-render itself. This is kind of
                    the data binding equivalent of that and you generally don't want to do this, but I just want to
                    expose it as a quick workaround at this point. We can go to the DataGrid itself, we can use a method
                    called GetBindingExpression that we pass a reference to a DependencyProperty exposed on that. So the
                    ItemsSource Property that we were setting is actually a DependencyProperty on the DataGrid. And when
                    we say GetBindingExpression it goes to that DependencyProperty and gets the underlying binding
                    that's setting it. So you're effectively getting a reference to this binding object here. Then on
                    that binding object there is a method exposed called UpdateTarget.
                </p>
                <p>
                    And remember the terminology of source and target, source is the underlying data source object,
                    which is our ViewModel here, target is the property on the element that's being set. So by saying
                    UpdateTarget here, it's forcing it to grab the current value out of the source and set it again on
                    the target and that forces the UI to update.
                </p>
                <p>
                    So with that in place, we can run, we can make our selections, and down at the bottom you can see
                    the grid is updating even though our layout's not that great now. So that code will work, but it's
                    not very efficient. We'll see in the next module the better way to do this is to support
                    INotifyPropertyChanged and collection Change Notifications from your data bound objects.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    Alright, so wrapping up this first module, we covered a number of key concepts and some good demos
                    of some fundamentals. We started off by talking about the motivations of using data binding, which
                    mostly center around the way it lets you write more loosely coupled and well-structured code that
                    can facilitate the developer-designer interaction and can also enable separation patterns such as
                    MVVM. Even if you don't do those things, it lets you write less code and more maintainable code. We
                    talked about the concepts of sources and targets and the way data flows between them. Sources are
                    your behind-the-scenes objects that feed data to the screen. Targets are the elements within your
                    screen that are going to present the data. We covered the DataContext and talked about the way it
                    acts as a scoping mechanism for data that you're going to flow into the view. And then we talked
                    about the bindings themselves and how they're used to tie a source property to a target property and
                    flow data between those two. We saw some basic demos that showed how a data-driven form works with
                    and without data binding, and what some of the basic coding patterns are around setting up a
                    DataContext and declaring your bindings. In the rest of the course, we'll get a lot deeper into all
                    of those aspects including different kinds of data source objects that you can use and how to
                    structure that in your views, all the different options that are available on your bindings to do
                    more advanced things, things like how to validate your data, and so on. So continue on to continue
                    your journey to becoming a data binding ninja.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Data Sources</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes, and in this module we're going to focus on data sources for data binding,
                    where the data comes from to support your UI. Specifically, we're going to talk about the different
                    kinds of data source objects that you can data bind to and some of the support those data objects
                    may need to fully participate in data binding. First we're going to talk about Entity Data Sources,
                    and this includes individual objects that you want to data bind to and their properties for
                    something like a data entry form, as well as collections of entities for something like a DataGrid
                    or a ComboBox. Next we're going to talk about Change Notifications . This is support that these
                    entities will need in order to fully participate in data binding, meaning that if their properties
                    can change behind the scenes, they've got to raise Change Notifications so that the binding can
                    update the UI and keep it fresh with the real state of the data behind the scenes. Next we're going
                    to talk about some of the other aspects of the support that entities can have for data binding,
                    inducing the ability to back out changes when multiple properties have been changed. Those are
                    called EditableObjects, and CollectionViews, which are things that wrap collections when you data
                    bind to them to maintain the notion of currency or what is the current object within the collection.
                    Towards the end of the module, we'll start talking about other kinds of things besides entities
                    including DataSets and XML Data Sources, and how you can go about data binding to those.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding to Entities and Collections</h3>
                <p>
                    data binding in XAML technologies including WPF, support binding to Plain Old CLR Objects or POCOs.
                    These are basic classes that expose properties and those properties can either be primitive values
                    such as strings, integers, DateTimes, and GUIDs or they can expose a reference to another complex
                    type object that itself has other properties with values in it. So you can have whole object
                    hierarchies or graphs that you data bind to in this way. data binding does not support binding to
                    member variables. You really shouldn't be exposing member variables publicly, they should be fully
                    encapsulated, so the WPF framework team tried to prevent you from doing the wrong thing here and
                    won't let you bind to your member variables. Likewise, bindings can't target methods, so you can't
                    invoke a method through a binding, you can only call a property to get a value out of that property
                    or to set a value in the case of two-way data binding. A lot of data binding scenarios revolve
                    around binding to collections and presenting that data in DataGrids, ComboBoxes, ListViews,
                    ListBoxes, and so on. The minimum bar to support data binding to collections is pretty low in .NET.
                    It basically just has to be a proper collection in .NET, meaning it implements the IEnumerable
                    interface. So this includes everything down to a simple array of integers or strings that you could
                    data bind to, but it could be a more sophisticated collection such as a list&lt;T&gt; or a
                    collection&lt;T&gt;, where you have the generic-type safety, as well as additional features around
                    the manipulation of that collection. So when it comes to data binding to these entities or entity
                    collections, basically what you're going to do is set the DataContext to some object that exposes
                    properties that are either entities or entity collections so that you can start binding to those.
                    Once you've set that DataContext and it flows down to the elements of your view, the bindings on
                    those elements just need to identify the path they're going to bind to, and that path is generally
                    the property name on the DataContext object or it could be a complex path because the property
                    exposed from the top level data object may be a complex object itself, so you may need to dot your
                    way down to something like Customer.Address.Street to get to a discrete value to put into a property
                    of an element. So let's take a look at a demo of some basic data binding scenarios with entities and
                    entity collections.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Binding to Entities and Collections</h3>
                <p>
                    In this series of demos, I want to cover some of the key concepts when it comes to data binding to
                    entities. Our starting point for this demo is a window that's laid out like this. We're going to
                    have a list of customers at the top in a drop-down ComboBox, we're going to have individual fields
                    here for FirstName, LastName, and Email on the SelectedCustomer that are editable so we can see some
                    of the change impacts there. We've got a DataGrid in the middle that's going to list out recent
                    orders for that customer, and then we've got a data form down below where we can create a new order
                    and add it to the collection up above. So those are the scenarios we want to support here and we are
                    going to do it by data binding to entities. The entities we're going to be working with are already
                    defined in the solution here under this model folder. We've got a customer as a top level object,
                    you can see this is a Plain Old CLR Object, just simple auto-implemented properties here, for an Id,
                    a FirstName, a LastName, an Email, a Collection of Orders as a List. And then notice you can also
                    have computed properties here, ones that are read-only, and in this case computed from the FirstName
                    and LastName property and those are data bindable as well. We've got an OrderObject that has an Id,
                    a parent Customerid, an OrderDate, and a related object and OrderStatusId that will set through a
                    drop-down ComboBox, and then finally an ItemsTotal. The OrderStatus object is just a simple lookup
                    list kind of thing with an Id and a Name, and then the way we're populating those entities for these
                    demos is through an Entity Framework DbContext a Code First DbContext, and you can see we're just
                    exposing DbSets for Customers, Orders, OrderStatuses, and then we've got some ModelBuilder stuff
                    down here. Again, I don't expect you to necessarily know how to do Entity Framework at all to
                    understand these demos. We're focusing on the data binding, not how we get those objects in the
                    memory. The code-behind of the MainWindow currently is mostly empty, it's just got stubbed out event
                    handlers for the drop-down list selection, the Add and Cancel buttons for adding orders. So the
                    first thing we might need is to expose some data that we can data bind to. For this demo, I'm just
                    going to put things as properties exposed from the MainWindow itself, so we're not doing MVVM, we
                    just want to expose objects from our code-behind so that we can data bind to them. In simplest form,
                    we could do that by just exposing normal auto-implemented properties on our Window class here. So
                    I've got a list of customers here that I can put into my ComboBox, and I've got a SelectedCustomer
                    that I can use to drive those individual input fields for the SelectedCustomer. I'm going to need an
                    instance of my DbContext to go ahead and populate that data, and then I could go into my constructor
                    here and go ahead and execute a query through my DbContext to get back all the customers as a list
                    and push those into my Customers property that I declared down below. Then I could go to the
                    CustomersCombo that has an ID of that, set the SelectedItem to the first customer in the list, and
                    then if I set the DataContext of the Window itself to a reference to the Window, then any of the
                    properties exposed by the Window are now accessible on the DataContext for bindings to use. I need
                    one other thing in the code-behind here before we go to the XAML is in our CustomerComboBox, when we
                    make a selection, we need to set that SelectedCustomer property, which is defined right up above, to
                    the customer that was selected. So we can go out to the CustomersCombo, grab the SelectedItem, cast
                    it to a Customer, and set that as our Customer property. Later in the course we'll get to, there's
                    better ways to do this where you can do this through binding as well, but this will be sufficient
                    for what we're showing now. Now we need to get things hooked up in the XAML. So I'm going to switch
                    over to XAML, I'm going to go down to our ComboBox here, and I'm going to add in some data binding
                    properties. First we're going to set the ItemsSource to the Customers property exposed on our
                    DataContext , which is the Window instance itself. Each item in that collection is a whole customer
                    object and we don't want it to ToString that for us, so we'll set the DisplayMemberPath property to
                    FullName, that computed property on our entity, and we'll set the SelectedValuePath to the Id
                    property. And then I'll go down to my data form here and I'll add a binding for the FirstName
                    property, we'll point that binding to the SelectedCustomer property that's on our DataContext ,
                    which is the Window, and then we can dot down to the FirstName property on that SelectedCustomer to
                    set the text there, likewise, for the LastName and for the Email. So with that code in place, we can
                    fire this thing up and we can see our ComboBox is bound. The problem is, as we select things we can
                    see that the TextBoxes are not updating. To make matters worse, if I go and edit something like Last
                    Name here and tab out of the field, which is what causes it to get written, the Last Name jumps at
                    that point to the actual value of the currently selected customer, but the First Name and Email are
                    out of sync now. And if I go look at the list here and go back to Derek up here, his Last Name
                    hasn't been modified there, but if I click on it then the modification shows up. So things are
                    wildly out of sync here because our entities are not properly defined to really support data
                    binding. So in the next couple of demos, we'll fix that by supporting Change Notifications when
                    things are changing.
                </p>
            </div>
            <div class="panel-body">
                <h3>
                    Change Notifications </h3>
                <p>
                    Now one of the most important concepts when dealing with data binding to entities and data objects
                    where you're building a rich interactive UI around those objects, is property and collection Change
                    Notifications . Basically, Change Notifications are going to be necessary if those source object
                    properties that you're binding to or the collections can be modified by any other code, other than
                    the binding itself. So this includes things like if you go out and do an asynchronous service call
                    to load some data into your UI's memory space, you're going to end up setting properties or
                    populating collections behind the scenes after the UI has already rendered and the XAML has been
                    parsed. Another scenario is if you have a command or event handler in code and that reaches out and
                    modifies the data source object for another control. And certainly if you have any background
                    threads or things going on in the background that are modifying your data objects, that's another
                    source where things are going to change behind the scenes, not directly from user input, through the
                    bound control. In any of these scenarios, you're going to need property or collection Change
                    Notifications to make sure that the UI stays fresh, because if there's no notification, the UI is
                    going to continue to show the value that was in the source property at the initial binding, the
                    point where the XAML was parsed. So to keep that UI fresh and in sync with the data source object,
                    the data source object has to raise Change Notifications to tell the binding in the UI, hey, come
                    and read my value again because it's changed. Now when it comes to supporting property level Change
                    Notifications , you really have two options. The first is to support the INotifyPropertyChanged
                    interface, which I'll often call INPC for short based on the capitals in that name.
                    INotifyPropertyChanged is a simple interface with a single member on it called PropertyChanged, an
                    event that you're supposed to raise whenever the properties on your object change. Bindings are
                    aware of this interface and when they go to data bind to a source object, they will query it to see
                    if it supports this interface. And if it does, then the binding itself will subscribe to that
                    PropertyChanged event so it can be notified and refresh the bound property if that PropertyChanged
                    event indicates that that property has changed. The other option you have is to use
                    DependencyProperties . If your source object inherits from DependencyObject as a base class and the
                    properties that it's exposing that you're binding to are DependencyProperties , there's an internal
                    mechanism that can raise Change Notifications to bindings so that they know to refresh. So let's
                    look a little deeper at the first of these doing INotifyPropertyChanged. Basically, what you're
                    going to do is implement that interface on your data object class, so this is going to be your
                    entity class that you're using as a data source object. In addition to declaring that interface on
                    the class definition itself, you're going to expose a public event with a signature of public event
                    PropertyChangedEventHandler and give that event the name PropertyChanged. Once you've defined that
                    event, you're going to be responsible for raising that event in each of your property setters on
                    that object, but you should generally check and see that the value being set is not the value that's
                    already there, and not raise the event if the setter is being called with the current value. So
                    let's take a look at a demo of implementing INotifyPropertyChanged and how it syncs up our UI better
                    for the demo scenarios we've been covering.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Implementing INotifyPropertyChanged</h3>
                <p>
                    So in the last demo we saw the synchronization problem because we're using simple Plain Old CLR
                    Object Entities that if we are making selections up here they're not reflecting in the fields. If we
                    edit a field and then tab out, then it jumps to the current object it didn't update in the list
                    here, but if we select the guy, then the change shows up. Now part of that is caused by the lack of
                    support for INotifyPropertyChanged, which is what we're going to remedy here. If we go to our
                    Customer object, you can see it's just a simple Plain Old CLR Object. Anytime you're doing data
                    binding to a complex object like this, you're going to want it to support the INotifyPropertyChanged
                    interface. To do that, I'm going to modify the Customer class here and what I did is you can see it
                    got a lot bigger. First off, I'm implementing the INotifyPropertyChanged interface. I'm going to
                    call this INPC for short in a lot of the course here. So the INPC interface here requires that you
                    expose a public event called PropertyChanged on your type of Type PropertyChangedEventHandler. Now
                    this syntax over here, if you haven't seen it, is kind of a nice trick called the delegate trick,
                    that if you assign an empty anonymous delegate into that event, then it's basically a no-op
                    subscriber that's always there and can't be removed, so you no longer have to check for nulls before
                    firing your events in C#. You can see that our property is expanded to backing member variables and
                    individual properties with getters and setters on those member variables. Now this Id property you
                    might treat as invariant. In this case it's a GUID so it actually does have to be set. What you
                    really want to be doing on every property is what the other ones are doing, which is raising the
                    PropertyChanged event, passing a reference for the object sender of this, and then a
                    PropertyChangedEventArg that takes the name of the property that's being changed, so I should really
                    add this PropertyChanged to the ID as well and make sure the name of the property is Id. So on any
                    object that implements INotifyPropertyChanged, the way to think about it is any of the public
                    properties you expose that have a set block should raise PropertyChanged. Now if we slide down to
                    the bottom, we've still got our FullName property that we're actually binding to in the ComboBox,
                    and it's computed based off the FirstName and LastName. It doesn't have a set block that we can put
                    a PropertyChangedEvent in, but we basically need the PropertyChanged to fire on that whenever
                    FirstName or LastName changes. So a little trick for dealing with that is if we go up here to the
                    two DependentProperties, FirstName and LastName, we can raise other PropertyChanged events in their
                    set block. The first PropertyChanged says yes, in fact the FirstName PropertyChanged, but it also
                    pretends that the FullName property has changed because effectively it has. So if we raise
                    PropertyChanged for FullName on both the DependentProperties, then the right thing will happen
                    there. So if we go ahead and run, now we modify Pucket's Last Name here and tab out of the field,
                    and we see that it immediately updates in the ComboBox, both there and in the drop-down list,
                    because the object is raising the appropriate Change Notifications . Now our selection problem is
                    not yet fixed, we'll have to fix that in the next demo.
                </p>
            </div>
            <div class="panel-body">
                <h3>
                    DependencyProperties </h3>
                <p>
                    Now the other option that you have for raising Change Notifications at the property level, that we
                    discussed, is to data bind to DependencyProperties as your source properties. DependencyProperties
                    can be implemented on any class that derives from DependencyObject, either directly or indirectly
                    through an inheritance chain. Now it turns out there is another kind of DependencyProperty called an
                    Attached Property, and these are actually implemented on a static class that doesn't have to have
                    any inheritance requirement there, but these are not directly relevant to the discussion of data
                    source objects and binding. They can tie in with data binding in other ways, but we're not going to
                    go into that in this module. So the reason DependencyProperties will work here is that when you set
                    a DependencyProperty there's an internal notification the bindings are able to monitor directly, so
                    they satisfy the same purpose as an INotifyPropertyChanged object that they can make sure that that
                    binding knows when to refresh itself, if the underlying source object property is changed. Now
                    you're typically only going to use DependencyProperties for properties exposed on UI elements,
                    controls, and views, and those are the things that are typically the target, not the source of a
                    binding. But as we'll see later in the module, you can bind from one element to another, for
                    example, in which case one element can be the source and a different element the target. So in those
                    cases, you're going to leverage the fact that those Source properties are probably
                    DependencyProperties if it's a framework element, but we'll also see in demos that you can expose
                    your own DependencyProperties as your Source objects or your DataContext properties so that you get
                    the appropriate Change Notifications when those are set. Another important thing to re-emphasize
                    about bindings is that the target of a binding does have to be a DependencyProperty itself. So this
                    doesn't really tie into the Change Notifications , it's just a requirement of a binding, the target
                    has to be a DependencyProperty . Now when it comes to implementing your own DependencyProperties ,
                    what you're going to do is declare a public static readonly member variable on your class of type
                    DependencyProperty . And there's a particular signature to this you're going to have to follow, as
                    well as naming conventions for the property itself. The easiest way to follow these conventions is
                    to use a built-in code snippet in Visual Studio called propdp and you'll see that in the demos. When
                    you declare a DependencyProperty in addition to the public static readonly member variable that's
                    the real DependencyProperty , you're also going to declare what's called a "wrapper property". This
                    is a normal .NET property that's Get and Set blocks just delegate down to the base class GetValue
                    and SetValue methods that are the way you really read and write from a DependencyProperty . It's
                    important to understand that the wrapper property is really just there for programmatic access from
                    your own code, even though based on the naming convention, as you'll see in the code, it's going to
                    look like your binding is pointing at the wrapper property, not the DependencyProperty , but the way
                    it really works out is the binding is pointing to the DependencyProperty and it's actually going to
                    be calling GetValue and SetValue on the DependencyObject base class and completely ignoring that
                    wrapper property. So the important impact to that is it means you should not put side effects such
                    as validation and things like that in your Set block of your wrapper property because those are not
                    going to be called in the binding process, but we'll get into more details on validation in a later
                    module. However, this wrapper property is part of the overall signature of declaring a
                    DependencyProperty , so you're really always going to be defining two things, the actual
                    DependencyProperty itself that's the public static readonly member, and then the wrapper property
                    that matches the naming conventions to expose that for programmatic access. When you define the
                    DependencyProperty , you do have an option to pass a metadata object to the factory method you used
                    to create it, and that metadata can contain several things. First is, it contains a default value
                    that's going to be used if the property is never explicitly set, and it can also be used to define
                    the default data binding directionality. We'll get into more on directionality in a later module,
                    but that has to do with whether it's a one-way binding, two-way binding or some of the other
                    variants supported there. There's also some other things you can do through that metadata object we
                    won't go into in this course, that have to do with more advanced framework aspects. So let's take a
                    look at declaring custom DependencyProperties on our view when we're using our view as our
                    DataContext to get the Change Notifications we need so we can set those at any time and have the UI
                    stay fresh.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: DependencyProperties </h3>
                <p>
                    Okay, so we saw that implementing INotifyPropertyChanged fixed part of the problem for us, that when
                    the individual properties change, such as FirstName and LastName, they can raise Change
                    Notifications and even raise Change Notifications for other properties such as this computed one
                    that depends on them, and get the UI to update. But we still have that selection problem that when
                    we selected things in the ComboBox, it wasn't updating on the UI. Now the reason for that is this
                    right here. We're setting this SelectedCustomer property, but it's just a plain C# property itself,
                    and raises no Change Notifications . So we have a couple options to fix that. One is, we could go up
                    there to the Window class and we could implement INotifyPropertyChanged up here and then expand
                    these properties to raise PropertyChanged events as well. And if these properties were on something
                    like a ViewModel, that would be the right thing to do. However, since we're in a Window class, which
                    is also a DependencyObject, another option you have is to use DependencyProperties . So I can delete
                    off these two properties and add them back in using a code snippet that's built in to Visual Studio
                    called propdp. If I hit tab, tab, and then I start filling in the blanks, the first one was my list
                    of customers called Customers and then I tab down to the bottom right here and you can see it wants
                    an Owner class that's going to be the main window, and then I'll tab right one more time and there's
                    a default value which I'll set to null. So let me just clean that up a little bit. So here you can
                    see the cleaned up Customers DependencyProperty , and just to review these, if you haven't had a lot
                    of exposure, a DependencyProperty is a public static readonly member variable on the class that
                    declares it. That class will have to derive directly or indirectly from DependencyObject. The
                    DependencyProperty itself always has a suffix of property with the name of the property that's being
                    exposed as part of the registration, declares what the type of that property is, what the type of
                    the containing type is, and then optionally it can provide a default value through metadata. Then
                    paired with your DependencyProperty , you'll always have what's called a wrapper property, which is
                    always just a .NET property with the same name, Customers, and you can see it uses the
                    DependencyObject base class to call GetValue and SetValue to read and write the underlying value of
                    that DependencyProperty . This normal property is just there to make it easier to get and set the
                    value from programmatic code. The thing that's important to understand is the XAML when you bind to
                    Customers, it's actually only going to be using the DependencyProperty , and the binding itself is
                    going to call GetValue and SetValue just like you see up above, it's not going to be calling the
                    getters and setters of this .NET property. So we define one DependencyProperty for Customers, and
                    I'll define another one for the SelectedCustomer. So now we have a DependencyProperty for the
                    SelectedCustomer as well. Now why did I do all this, it's a lot of syntax. The reason is that
                    DependencyProperties raise their own Change Notifications and bindings are aware of those, so if the
                    properties are bound to our DependencyProperties , you don't have to worry about raising any kind of
                    change notification, that'll happen under the covers automatically. Our code that goes and sets
                    properties doesn't have to change because they're actually using the wrapper property here, and it's
                    when the SetValue on the DependencyProperty gets called that the change notification actually gets
                    raised under the covers that the binding is listening for. So with that in place, if we go and run,
                    now we make our selections and you can see the boxes below are updating with those selections
                    because when SelectedCustomer changes, each of these is bound to select Customer and some property
                    on that and it knows to re-render based on that property change.
                </p>
            </div>
            <div class="panel-body">
                <h3>ObservableCollections</h3>
                <p>
                    Now when it comes to collections that we're going to data bind to, we have a change notification
                    challenge there as well. If we're just using something like a simple array or even the List&lt;T&gt;
                    and we're adding and removing items from that collection, the binding is not going to know anything
                    about that and we're not going to see the changes reflected on the screen. This is where
                    ObservableCollection&lt;T&gt; and the INotifyCollectionChanged interface come into play. The base
                    level support you need to ensure that the UI stays fresh is that your collection type needs to
                    implement an interface called INotifyCollectionChanged and you should see the similarity here to
                    INotifyPropertyChanged. INotifyCollectionChanged raises a CollectionChanged event, so it's the
                    conceptual dual or parallel to the INPC interface. And this one covers changes to the collection
                    meaning additions and removals changes of what objects are currently in the collection. If you've
                    come from previous technologies such as Windows Forms, it's important to realize that the
                    CollectionChanged event is only going to fire for these add, remove, replace, and clear type
                    operations, things that change the overall set of objects in the collection. You won't get a
                    CollectionChanged event fired if a property on one of the objects within the collection has been
                    modified. If you want to know about those, then the objects that are in the collection will need to
                    implement INotifyPropertyChanged or DependencyObjects with DependencyProperties to get those
                    property level notifications for the objects in the collection. Now the best way to go about this,
                    as the title of the slide suggests, is to not implement anything yourself. There's a built-in
                    collection type called ObservableCollection&lt;T&gt; that already implements the INCC interface or
                    INotifyCollectionChanged, and will raise those CollectionChanged events for adds, removes, and so
                    on. So, in general, the easiest way to think of things is anytime you're going to expose a property
                    that is a collection and you want to data bind directly to that collection, make sure that that
                    property is defined as an ObservableCollection&lt;T&gt;. This means that if your objects are coming
                    in, say, from a service call or you've read them in from a database, they're not necessarily already
                    going to be an ObservableCollection&lt;T&gt;. The good news is that type has a constructor that
                    takes an IEnumerable so you can pass in any other collection type and it'll basically just iterate
                    through that collection and add references to those same objects into your new ObservableCollection&lt;T&gt;,
                    and that's what you can expose for data binding. So let's take a look at the demo and see how using
                    ObservableCollections instead of other collection types solves our UI synchronization problems for
                    collections.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: ObservableCollections</h3>
                <p>
                    So in this demo I'm going to hook up the rest of this form with this list of orders for the
                    SelectedCustomer and then the ability to add new orders to that list from the form at the bottom. To
                    do that, we're going to drop into the code-behind here and we're going to need a couple more
                    properties, which I'll go ahead and define as DependencyProperties so that they can have Change
                    Notifications as we discussed in the last demo. So first off, for the new order form at the bottom
                    we're going to have an OrderObject that those fields combine to called NewOrder, and then for the
                    ComboBox in the form we're going to have one called OrderStatuses that's going to be populated with
                    the choices for OrderStatus from the database. Next we're going to need to populate the orders, so
                    I'm going to go up here to where we are initializing our customer information in our DataContext and
                    add a few more things. First off, we're going to populate that OrderStatuses collection with the
                    list of OrderStatuses from the database. We're still selecting the first Customer like we were doing
                    before and we're setting the DataContext still to the window as a whole. Just to emphasize from the
                    previous demo, I could actually move this now and set the DataContext at some point before we start
                    populating the properties on whatever that DataContext is, as long as those properties raise
                    appropriate Change Notifications , which the DependencyProperties do, then it's okay to change these
                    after the fact of setting the DataContext . Now we also need to populate that NewOrder object, so if
                    I go down to my CustomerSelected handler, and then I add in some code, and that code is going to new
                    up an Order Object and set it as the NewOrder, and set the CustomerId of that NewOrder to the
                    SelectedCustomer in the ComboBox. Then we're going to go execute a query to get the orders for that
                    corresponding customer and push it in the Orders collection of the SelectedCustomer object. Now we
                    just need to update our bindings a little bit in the UI. So first I can go into the XAML and I can
                    come find my DataGrid that the Orders are supposed to show up in. I can add a binding here for the
                    ItemsSource property pointing to that SelectedCustomer object and the Orders collection that hangs
                    off of it. Now we don't have any columns to find here, so it's going to auto-generate the columns
                    based on the properties on that object. And then I'm going to slide down and update the fields in
                    our order form to include appropriate bindings. So up here you can see we're binding the OrderId to
                    the NewOrder object.Id, NewOrder.OrderDate, NewOrder.ItemsTotal, and then for the OrderStatuses
                    ComboBox we bind that to our OrderStatuses collection on the window. So that we can push the
                    SelectedValue from that ComboBox into the underlying object, we have a binding on the SelectedValue
                    here that points to the NewOrder.OrderStatusId, but SelectedValue is not a two-way binding property
                    by default, so we have to set the Mode property here of the binding to TwoWay. We'll get into more
                    details on directionality of bindings in a later module. One other thing we're going to want to
                    modify in the code-behind here is our Add handler, so I'm going to add some code to that that
                    basically takes that NewOrder object at the point where the Add button is pressed and adds that
                    object into the Orders collection on the SelectedCustomer. We're also going to persist that change
                    so you can see that we're taking that NewOrder, adding it to our DbContext Orders collection, and
                    calling SaveChanges. And then you can see we're setting the NewOrder to a new Order object, clearing
                    it out basically, but setting the CustomerId in case we're going to have multiple orders. If I go
                    ahead and run here, we've got the orders populated for the SelectedCustomer. If we pick another
                    customer, you can see it's updating to show just the orders for that current customer. Now if I go
                    to one that's only got a couple showing here, and I go to enter a new order, I'll pick Halloween
                    here as a date, we'll go with 99.90 as an Order Total, and an Order Status of PickedUp, and I click
                    on Add. Now you can see the order cleared out at the bottom, but nothing happened up in the grid. If
                    we go ahead and close, startup again, pick that same customer, we can see that new order was
                    actually placed and it was even added to the data bound collection, it just didn't show up. And this
                    is, again, because we need Change Notifications now at a collection level instead of a property
                    level when you're adding and removing things from a data bound collection. So if we go look at our
                    Customer object, we can see the root problem here is that that Orders collection on the
                    SelectedCustomer is just declared as a list of Order. If we set the Orders property as a whole,
                    changed out the whole collection, we would have been fine because a PropertyChanged would have been
                    raised and the binding would have re-bound to that new collection. But in this case we're not
                    swapping out the whole collection, we're just reaching into that collection and adding a new item.
                    has no Change Notifications associated with that. So what we're going to want to do is change our
                    property here to be an ObservableCollection&lt;T&gt;, and we'll have to go change the member
                    variable, as well, to be an ObservableCollection. And there's one other place in the code-behind
                    where we first populate that Orders collection, so we're now newing up an ObservableCollection and
                    passing in the IEnumerable that comes out of this link expression to populate that collection. With
                    that code in place, we can go ahead and run, we can make our selection, let's add a new order, this
                    one for January 1, 33, and Delivered, and watch the grid up above when we click Add. It shows up
                    immediately because that ObservableCollection class raises a CollectionChanged event the bindings
                    are watching for, and the binding will re-render the content based on that. Now in a similar
                    fashion, I really should go up here, if you remember from previous demo, we had defined this list of
                    customers that we were binding to. I'm going to replace that with ObservableCollection as the type
                    of that collection. Basically, anytime you're exposing a collection for data binding purposes, if
                    there is any chance whatsoever that items will be added and removed to it, then that collection
                    should be an ObservableCollection, not something like a list. And because of that change, we have to
                    change the initialization of this one as well, and we just do a similar thing. We call the
                    constructor of ObservableCollection&lt;T&gt;, passing in an enumerable to populate it, and assigning
                    that into our property.
                </p>
            </div>
            <div class="panel-body">
                <h3>Editable Objects</h3>
                <p>
                    Now another thing you can support on your entities, that honestly is not often used, but I wanted to
                    get you exposed to it anyway here since it does relate to entities as data source objects, is
                    EditableObject Support based on the IEditableObject interface. What this is all about is that you
                    may want your objects to be able to back out changes that have been made on multiple properties. The
                    canonical scenario here is that your object is data bound in a DataGrid, the user goes and changes
                    one field, tabs to the next, makes a change, tabs to the next, makes a change, and then decides, I
                    want to back that out. DataGrids support this inherently and allow you to hit the escape key and
                    they will actually back out those changes in memory separate from the data object itself that it's
                    data bound to. But you may want to support this in something like a data entry form, as well, that
                    you want the user to be able to tab from field to field and then maybe hit a Cancel button and back
                    all those changes out as well. Additionally, you may have custom logic that needs to execute even in
                    the DataGrid scenario, that when the changes are backed out you may need to do other things to
                    related objects, for example. So the way you go about doing this is to simply implement the
                    IEditableObject interface on your data source object entity. When you do that, you're going to
                    implement its API, which includes three members. One is a method called BeginEdit, and this will be
                    called implicitly for you by a DataGrid, but you can call it explicitly in the case of a data form.
                    And the concept behind BeginEdit is that you're going to save off your original values for the
                    current entity somewhere. It can just be in some temporary member variables within the entity
                    itself, or you could push it out to a cache somewhere that you could retrieve it from. If the
                    EndEdit method is called, then the idea is you can just discard those original values. Think of that
                    as a commit in a transactional type of system. You're basically saying that I have successfully
                    ended the Edit operation and so I should go ahead and keep those values around that have been
                    modified. but if you want to back things out, the number you're going to implement there is called
                    CancelEdit, and this is where you would basically get those original values and override the current
                    values of all the properties with those to restore the state of the entity back to what it was when
                    the BeginEdit method was called. Again, these are going to be called implicitly for you by a
                    DataGrid if your object supports it, ubt you can call them explicitly in other editing scenarios as
                    well to give this kind of transactional back out of changes at an entity level. And we haven't
                    covered DataSets yet, we will later in this module, but I should point out that DataSets implement
                    IEditableObject for all the Row objects, so they inherently support this API as well. So let's take
                    a look at a demo of how you can implement IEditableObject on your entities and the scenarios where
                    it can help you out.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Editable Objects</h3>
                <p>
                    In this demo, I want to show you how, where, and why you might want to implement IEditableObject for
                    transactional changes on entities that you're data binding to. The starting point for this one is
                    the ending point of previous demos in the module, and what we're going to be focusing on here is the
                    Order objects. If we go ahead and run the app, the first thing to notice is that the DataGrid in WPF
                    already has support for backing out changes or rolling back changes as you edit an object. As soon
                    as you put a row into Edit mode, like I've just done by clicking into a cell, and start modifying
                    the values there, as long as my focus stays on that row I can hit escape and you can see it backed
                    out the changes. So, really, while a row is in Edit mode it's creating a temporary object in memory
                    and modifying the values on that. Now there's a data binding Update mode we'll get to in a later
                    module where it might be pushing those changes as you tab out of the field. So I could make this
                    change, tab out of the field, and you can get it to write it to the underlying object immediately,
                    but by default it's not doing that. And if we hit escape, then it backs those things out. Now
                    whether you support the immediate update mode or not, you might want to have your object notified,
                    because it might need to refresh its values from the database, for example, instead of just directly
                    from memory. So that's one place where IEditableObject comes in. The other would be if we were
                    editing our order down at the bottom and wanted to back out changes here when we click Cancel, then
                    one way to go about it would be to support IEditableObject on that order object. So how do we go
                    about doing that? Well, first off, if we're data binding to these order entities, as we covered in a
                    previous demo, we really should be supporting INotifyPropertyChanged on this object. So the first
                    change I'm going to make is to do that. So you can see I've added the INotifyPropertyChanged
                    interface and the corresponding event onto my Order object, I've expanded all the properties to have
                    backing member variables and to raise the PropertyChanged event when those change. So that's the
                    starting point is make it a good object for data binding. The second part is to implement the
                    IEditableObject interface, so I declare that I want to implement that interface, and I can stub out
                    the implementation using Visual Studio. So you can see the interface defines three methods,
                    BeginEdit, CancelEdit, and EndEdit, and the idea here is that when you go into an Edit mode, such as
                    in the DataGrid row, you can call the BeginEdit method. If the user escapes and cancels those
                    changes, it can call CancelEdit, and if they complete the changes normally then it'll call EndEdit.
                    In the case of the DataGrid, that would happen when the row focus changes to a different row. So
                    what do we really need to do on these methods? Well let me add some implementation. And you can see
                    what I'm doing here is I've got a TempValues object that's declared as a member variable on the
                    class that is an order itself, so it's just a place to stash the temporary values for each of our
                    properties. And you can see I new up an Order object when we go into the BeginEdit mode, stash off
                    all the values of my properties into the properties of that temporary object, then if CancelEdit is
                    called, we just restore the property values to those original values, and if EndEdit is called we
                    throw away our temporary values because they're no longer needed, so just a simple, straightforward,
                    brute-force kind of approach to implementing IEditableObject. With that in place, I can set some
                    breakpoints here and go ahead and run, and now we'll see as I click into a cell, BeginEdit is
                    called, so we have a chance to stash off our values and we can go ahead and start editing that. As
                    you can see as I tab off the fields, it's holding onto those values, I can change this to 3, maybe,
                    this to 99, and as long as I don't tab out, which will take me to the next row, I can hit escape and
                    now our CancelEdit is being called. So it just gives your code a chance to be involved in that
                    EditCancel process and to do whatever is necessary to restore the state of your object on Cancel.
                    Now what if we wanted to leverage this for our entry form down below for creating a new order for
                    when the Cancel button is hit? If we wanted to back out the changes to the NewOrder object that's
                    being held in the window? To do that, we'd want to go to the place where the NewOrder is initiated
                    and that editing can begin. So in our case, that's as soon as the Customer is selected we could call
                    BeginEdit on the NewOrder object. Then when the Add button is pressed, that's basically the success
                    case, we would call EndEdit and then in Cancel, naturally we would call CancelEdit. With those
                    changes in place, we can run, we could go down here and start editing our object, and then if I
                    click the Cancel button, watch the fields revert back to their defaults. So that's all there is to
                    IEditableObject, implement the interface, define the Begin, Cancel, and End Edit methods, stashing
                    off the values somewhere appropriate, and being able to restore those values on CancelEdit. And then
                    if you have explicit Start and End processes for editing and forms, you can call BeginEdit and then
                    call EndEdit at the appropriate point or Cancel if you need to back out changes.
                </p>
            </div>
            <div class="panel-body">
                <h3>Collection Views</h3>
                <p>
                    Now another common concept in data binding and collections is the concept of the "Current" object in
                    the collection. If you came from a Windows Forms background, there was a thing called the Currency
                    Manager under the covers of a form that managed this aspect of data binding. WPF has something
                    equivalent. Basically what happens is when you data bind to a collection in WPF, WPF is always going
                    to wrap that collection in an implementation of the ICollectionView interface. This ICollectionView
                    interface does a number of things, but one of the main things it does that we'll talk about in this
                    module is the concept of keeping track of what is the "current" object in that bound collection.
                    Because, when data binding in WPF, you can have your data source or your DataContext be an entire
                    collection of objects, but you can have bindings within the elements that expect a single object,
                    and the single object they're going to pick is the current object. So, for example, if you set the
                    overall DataContext for the entire form to be a collection of customers, but then you have a
                    TextBox.Text property that's bound to Customer Name, it's just going to get the name off of the
                    current customer, and it does that because of this ICollectionView support. So through the
                    ICollectionView, you can obtain a reference to the current object. There's also APIs on that
                    interface to be able to control the current index to move to next, move to previous, and things like
                    that to support paging type operations. So the ICollectionView exposes other capabilities as well,
                    including sorting, filtering, and paging, and we'll take a look at those in a later module. Here
                    we're just going to focus on this currency aspect of the ICollectionView, so let's take a look at a
                    demo of how this affects us and how you can use it.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Collection Views</h3>
                <p>
                    In this demo, I want to show you some of the basics of CollectionViews and working with those to
                    control the current object within a data bound collection. And then we'll change the way our form
                    works slightly so that when an order is selected in the DataGrid in the middle here, its details
                    show up in the fields down below. To do that implies some currency between the form at the bottom
                    and the DataGrid in the middle. So the first thing I'm going to do is I'm going to go into the XAML
                    and go find my DataGrid and add another property on it called IsSynchronizedWithCurrentItem. Now the
                    key thing to understand here is, anytime you data bind to a collection, such as Orders here or
                    Customers here or OrderStatuses here, WPF is always going to be wrapping your collection in a
                    CollectionView and CollectionViews are something that support a number of things. We'll look at more
                    details in a later module on binding collection-oriented controls, but one of the most important
                    things a CollectionView does is keeps track of a current item within a data bound collection. That
                    current item in our case can correspond to a selected item in something like a DataGrid, ComboBox or
                    ListBox. And the IsSynchronizedWithCurrentItem is basically a signal to WPF that says, I already
                    know you're going to wrap this collection in the CollectionView, so anytime I select something on
                    this, make sure it is marked as the CurrentItem in the corresponding CollectionView for this
                    collection. Next, I'm going to drop in here and replace the Grid that has our AddOrder form in it.
                    All I did here is I put some minor changes. One is that at a Grid level, notice that I'm setting the
                    DataContext for the grid as a whole to the exact same collection that my DataGrid is bound to. When
                    WPF wraps a collection in the CollectionView, it'll create one CollectionView for all references to
                    that same collection. So even though this DataContext is pointing through this binding and this
                    ItemsSource is pointing through this binding, they end up pointing to the same CollectionView
                    instance. So if I select an item in the DataGrid and it sets the CurrentItem, it's also implicitly
                    setting the CurrentItem for the CollectionView that's going to be used for this Grid. Down inside of
                    the Grid now, instead of saying NewOrder.Id, and NewOrder.OrderDate, and NewOrder.ItemsTotal, we're
                    just saying Id, OrderDate, and ItemsTotal, because the DataContext has already been restricted down
                    implicitly to a single order, even though the DataContext is pointing to an entire collection here.
                    When you have a binding that results in a single value like this, it knows enough to use the value
                    off of the CurrentItem in that collection. If it sees that the DataContext is a collection, it will
                    grab the CurrentItem in that collection through the CollectionView and then this path will resolve
                    against that CurrentItem. Now because of restricting the DataContext for this entire Grid to that
                    collection, I have to do some additional gymnastics here for binding this ComboBox, which really
                    wants to get to the OrderStatuses collection that's on the window itself. I'll get into more details
                    on RelativeSource bindings in the next module, but conceptually, what this binding is doing is
                    reaching up to the window level, dotting down to its DataContext , which happens to be a reference
                    to the window itself, and then going to the OrderStatuses property that's on that. So with those
                    bindings in place, I can now go ahead and run, and notice that when I select in the DataGrid, the
                    order that the form is bound to at the bottom is changing along with my selections, and that's
                    happening even though the DataContext for those individual elements is really a collection the
                    bindings themselves are smart enough to go to that collection, see it's a CollectionView, ask for
                    the Current object, and then apply their path to the Current object. Now what if we wanted to
                    programmatically control what the CurrentItem is, I'm going to go up here and replace my DataGrid
                    with a StackPanel that contains the DataGrid. Inside that StackPanel I have two buttons sitting
                    right atop the DataGrid that allow me to move the focus, if you will, or the selection within the
                    DataGrid up and down, and then I still have the IsSynchronizedWithCurrentItem on my DataGrid. The
                    additional stuff here is just some styling to make it very apparent what the selected row is by
                    drawing a blue box around it. Now I need some Click event handlers for those buttons so I'll drop
                    into the code-behind. So I'm just going to go to the bottom of the code-behind here and add the
                    event handlers. In the MoveDown one you can see what we're doing is we're going to a class called
                    CollectionViewSource, and we call GetDefaultView, and we pass it a reference to the same collection
                    that was being data bound to by both the DataGrid and the grid for the order form. Calling this
                    basically gives you a reference to that CollectionView that's wrapping that collection that both
                    bindings are using. Once we have that reference, we can use the exposed API on CollectionView to do
                    a number of things. One thing is we can check the CurrentPosition and get an index back of where it
                    is in the collection, and then we can command it to move to different positions. So in this case, to
                    move down, we're making sure we're not already at the last item with this comparison, and for moving
                    up we're making sure we're not already on the first item. To move down we say MoveCurrentToNext, to
                    move up we say MoveCurrentToPrevious. So with that code in place, I can run, I can click the down
                    arrow, and you can see the highlight moving, click the up arrow and it moves back up. So we're able
                    to control the currentPosition programmatically using the ICollectionView interface. And, again,
                    we'll see other things we can do CollectionViews more in a later module.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding to DataSets</h3>
                <p>
                    Now let's talk about data binding to DataSets. The venerable DataSet has been around a long time in
                    the .NET space. Back in Windows Forms 1.0 and 2.0 days there was a lot of guidance from Microsoft
                    and others saying DataSets are the way to go, you put all of your data in the DataSet and life is
                    good. Well the truth is, DataSets are kind of fading in popularity. Most of the modern capabilities
                    coming out in the .NET framework and in other technologies are really focused on entities, simple
                    objects with properties to contain data instead of treating everything as a relational set of data.
                    And part of the reason for this is that with lots of flexibility comes complexity. When you use
                    untyped DataSets, you typically ended up with a lot of fragile, untyped code, lots of casting
                    indexing into columns with indexes or column names, and it tended to be very unmaintainable code.
                    Once Typed DataSets came out in .NET 2.0, you could at least get away from the untyped aspects of
                    that. And you could have objects with properties and dot into those properties as if they were
                    entities, but they were really a poor-man's entity because you couldn't really leverage inheritance
                    and polymorphism, and the concept of encapsulation that they had was a bit clunky. To have a
                    single-entity object, you always had to have a table with a single row in it, so you always had this
                    extra layer of everything as a collection, even if it's not, which was a little weird to deal with.
                    And the way that you would write code that was logically encapsulated by the DataSet, just didn't
                    match up well with object-oriented concepts. However, all that being said, DataSets are still out
                    there and they're still useful at times. Untyped DataSets, in particular, can still be useful in
                    this modern day if you have places where you allow end users to formulate ad hoc queries where you
                    don't know what the columns are going to be in the resulting record set. And the reality is, none of
                    us can start from scratch on every single application we build, we often need to maintain an
                    existing application, maybe move it forward to a new UI technology like WPF, but we have to carry
                    along some legacy code, and that legacy code itself may be dependent on DataSets. So the good news
                    is you can still use those in WPF. WPF data binding works just fine with DataSets, both untyped
                    DataSets and typed DataSets. However, it is worth pointing out that the later XAML stacks,
                    Silverlight, Windows Phone, and WinRT, do not support data binding to DataSets. So that's something
                    to take into consideration if you're going to be writing code that supports your views, that pulls
                    in your data sources, and you might be trying to move that forward to one of these other
                    technologies in the future, then you would definitely want to avoid DataSets. But with all that
                    being said, let's dive into a demo and show you how you can easily work with DataSets. And you'll
                    see that the XAML really doesn't care, it treats those as objects and doesn't care whether it's
                    working with columns or properties, the syntax is the same.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Binding to DataSets</h3>
                <p>
                    In this demo, I want to show you how you can data bind to DataSets. Now DataSets are kind of falling
                    out of vogue. I generally wouldn't use DataSets in any new projects I was working on, I would favor
                    using entities. But if you're stuck moving some legacy code over or migrating an application maybe
                    from Windows Forms, they use DataSets extensively and you can't afford to rewrite all that code, I
                    want you to see how you can easily still data bind to those DataSets in WPF. The DataSet we're going
                    to be using here is a typed DataSet, but I'll show you, you can also use untyped DataSets. The
                    schema is the same Zza database that we've been using and it's got customer, Order, and OrderStatus
                    as a minimal part of that schema. The UI we'll be using for this demo is just the top portion of a
                    demo that we've been using before that has the drop-down list of customers, and when you select one
                    it fills out the fields for First Name, Last Name, and Email for the SelectedCustomer. If we go to
                    the XAML, you can see here's our ComboBox and the binding is not really going to look any different
                    here. It's going to say, I'm expecting my DataContext to provide me a property called Customers, and
                    in that Customers I'm expecting a bindable collection of something. When working with DataSets, the
                    bindable something is going to be what's called a DataRowView. It's a view on top of a data row
                    similar to the ICollectionView we talked about earlier, but one that's built in to the overall
                    schema of DataSets, and bindings are aware of those. Then when it comes to specifying binding Paths,
                    such as the DisplayMemberPath, and the SelectedValuePath here, these become column names. Now they
                    could be strongly-typed property names if you're working with a strongly-typed DataSet, but if you
                    have untyped DataSets they can just be the column name. Down below you can see we have
                    SelectedCustomer.LastName, .FirstName, .Email, just like we had in earlier demos with entities. So
                    the syntax at a binding level is no different if you're working with DataSets or with entities. The
                    only thing that's going to be a little different is the way you do the data access. So, the first
                    thing I need to do is declare a couple of properties that the bindings were expecting in the XAML.
                    Those are a Customers collection and a SelectedCustomer. The types of those properties, if I'm
                    starting with the typed DataSets are going to be a CustomersDataTable for the Customers collection
                    and a DataRowView for the SelectedCustomer. The individual objects in the data table are actually
                    data rows, but once you bind to them, it's actually going to be a DataRowView object that the
                    binding is expecting to see. otherwise, these are just DependencyProperties as we've seen in
                    previous demos that will raise Change Notifications if their values are set. Next, we just need to
                    load data using DataSets. So the first thing I'll do is I need to set my DataContext to the Window
                    as I did in previous demos. I use a CustomerTableAdapter here and I go out and I call GetData on
                    that tableAdapter. That's going to return me with a strongly-typed DataSet, it returns me one of
                    those CustomerDataTables, which I can just write directly into my wrapper property for my
                    DependencyProperty customers. Next, I need to handle the Selection, so I'll set the SelectedCustomer
                    property to a DataRowView, which I can do by going to the CustomersCombo and getting the
                    SelectedItem. If you try to cast that to DataRow it's going to fail because it's wrapped it in one
                    of these DataRowViews at the point where you data bind here to the Customers collection. With that
                    in place, I can go ahead and run, I can select a customer, and we can see the fields are filling in
                    and it's really getting values out of the fields in the DataRow from a DataTable as opposed to
                    working with entities and properties. Now just to show that this can also work with untyped
                    DataSets, I'm going to replace my Customers property here with a DataTable one, a non-strongly-typed
                    DataTable, and then I'll go up to the top and replace my data loading by declaring a DataSet, an
                    untyped DataSet, and then I create an instance of a SqlDataAdapter, do a "SELECT # FROM Customer",
                    pass an appropriate connection to it, and then do a Fill on the adapter passing in the DataSet. Then
                    to populate my customers DataTable property, I can just go to the DataSet.Tables collection and when
                    you do a fill like this it names the Tables, Table, Table1, Table2, so that first fill actually
                    populated a Table named Table. I could go rename that, but since I'm just grabbing its value here
                    and passing it into my property, it doesn't matter. I don't need any changes to the XAML itself. I
                    could go ahead and run again and we can see things are populating just fine even though we have no
                    type information now, it's just an untyped DataSet with columns and rows.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding to XML</h3>
                <p>
                    Finally, let's talk about binding to XML directly. WPF does support allowing you to point to an XML
                    document and set up your bindings to point to the values that are contained within the XML elements
                    or attributes within that document. In general, I would recommend you avoid using this capability of
                    WPF from a architecture perspective, you don't really want to couple your UI code to how you're
                    doing data persistence, and XML is really a low-level data persistence mechanism, leaking that all
                    the way up into the bindings of your view, locks you into a persistence mechanism you may not want
                    to stick to in the future. This is kind of the moral equivalent to putting SQL statements in your
                    views, which you also shouldn't be doing, because that locks you into using SQL as your persistence
                    mechanism and that's something you don't want to do, you want to have logical layers and you
                    probably want to have a data layer behind the scenes that encapsulates how data persistence is done
                    and just brings it in as entities. But all that being said, you may have some XML documents around
                    that perfectly fit what you want to show on the screen, so the good news is you can do that. What
                    you do is, there's an object called an XML data provider and you can put that in your XAML, point it
                    to a document as a source, and then you use XPath on your data bindings to refine what part of the
                    DataContext that you set up as the XML data provider that you want to use for display purposes. So
                    you're basically using XPath to reach down into that document, pull out portions of it, you can set
                    those as child DataContext , for example, you could reach down in and find a collection of elements
                    within the document and set that as the DataContext for something like a DataGrid. So let's look at
                    a demo that shows us how to do this.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Binding to XML</h3>
                <p>
                    In this demo, I want to show you how you can easily bind to XML data sources to pull in hierarchal
                    data and display that in the UI. Now just like I said for DataSets, I generally stay away from XML
                    data binding because you're too tightly coupling the UI to the particular way the data is getting
                    into your application. If you want to build a nice loosely coupled application that can evolve over
                    time and be easily maintained, you don't want to assume that now and for all time your data is
                    coming in as a chunk of XML. You want to separate that out into a data layer that produces objects
                    for binding instead of raw XML. But with that caution in mind, let's show you how you can do it if
                    you really need to. So down here you can see we've got a Zza xml file that's really a dump of some
                    of the customers and their orders from the Zza database. That's going to be our data source for
                    this. The window we're going to deal with is similar to the last demo, that we have a Customers
                    drop-down and we have some data bound fields on the current customer selected in that drop-down, and
                    we want to support that same scenario, put data binding directly to a collection of customers in
                    XML. Code-behind for this has absolutely nothing in it, and you'll see that we're going to keep it
                    that way, we're just going to load the XML directly into our XAML, which is definitely a point of
                    coupling, but it's the most expeditious way to work with XML in data binding. So I'm going to drop
                    into the XAML here and I'm going to declaratively hook up the DataContext for the window to an
                    object called an XmlDataProvider. This is an object that you can point to an XML file with its
                    source property, so this is really just a relative path within the project is how it's resolving
                    that. And then from there you can refine what part of the XML file this provider points to using
                    XPath statements. So you do have to be comfortable with XPath to be able to use this to any large
                    degree, but here you can see we're pointing to the Customers root element and then saying, get me
                    all of the Customer elements that sit within that Customers root element. And it's basically going
                    to form a collection of XML elements within this DataProvider as a source. Then I'm going to go down
                    here to our ComboBox and add some data binding properties to it. First off is an ItemsSource that
                    says I'm going to bind to the entire DataContext . And that DataContext , again, was being set to a
                    collection of Customer objects through this XPath statement. Then we're able to say,
                    DisplayMemberPath and SelectedValuePath like we did before, but now as opposed to these representing
                    property names on an entity or column names within a DataSet, they represent either element names or
                    attribute names on the current object, so it's going to look for an element or attribute called
                    LastName and grab its value, and it's going to look for one called Id. Notice we also use the
                    IsSynchronizedWithCurrentItem, because just like we talked about with entities and with DataSets,
                    there's a view that wraps all this that maintains the concept of a current item within that
                    collection. Next, we can drop down to the form fields of our little data form and add bindings to
                    those, and here you can see we have a Text Binding, but the way we specify the path in this case is
                    we specify it as XPath. So in this case, because they are child elements with values in them, we can
                    just say XPath FirstName, LastName, and Email, and it's able to locate those and grab the value of
                    those. With that in place, we can go ahead and run, and you can see our form already works just like
                    it did before, even though we have no code-behind driving anything, it's just sucking XML into the
                    root, setting that as the DataContext through this Provider to the collection of the Customer
                    elements within that XML binding to that as a collection, and also binding to the current item,
                    Fields through the concurrency of the underlying view. So this might work great if you have a flat
                    data file that's provided to you in XML that you just want to data bind to, and it is even possible
                    to do two-way data binding and push the values back in and then go and save that document off, but
                    if you're really doing all that, you should consider putting some layers of abstraction there and
                    not doing it directly against an XML file.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    Okay, so to wrap up this module on data sources, we saw a lot of different ways of providing data to
                    your bindings. We started with entities and collections and you saw that it's a simple matter to use
                    Plain Old CLR Objects or any type of IEnumerable in .NET, and you can data bind to that and show its
                    data on the screen. But if that data is going to be changing behind the scenes, then you saw the
                    Change Notifications both in an object and collection level become vital to keeping the screen in
                    sync with the true state of the data in memory. You saw a few additional things that you can do on
                    your entities such as implementing IEditableObject for transactional changes and backing out those
                    changes or working with CollectionViews that automatically wrap your collections when you're bound
                    to them to manage the current object, and how that current object is displayed on the screen for
                    things like paging. Finally, we talked about DataSets in XML and you saw that you can easily bind to
                    those as well, even though I generally recommend if you are writing a new application from scratch
                    you would stay away from binding directly to those kinds of sources and stick to entities.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Binding Core Concepts</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes. In this module, we're going to dive a little deeper into bindings and get
                    into some of the core concepts of how you can have explicit control over exactly what a binding is
                    doing with respect to its source objects and its paths and the direction of flow of data through
                    that binding. First we're going to dive into binding sources. We've already seen in previous modules
                    how bindings use the DataContext as their source by default. In this section we'll talk about the
                    other options that you have there, including the RelativeSource bindings, ElementName bindings, and
                    Source bindings where you can point to a explicit Source object through those properties on the
                    binding. Next we're going to get into Property Paths in a little more detail. We've seen simple
                    paths that are just a property name in previous demos, and we've actually seen a couple of other
                    examples that dot down. Here we'll just talk a little bit more about exactly what is supported, the
                    fact that you can walk an entire object graph through the property path and even index into arrays.
                    And also we'll talk a little bit about debugging bindings when they're not working and see how you
                    can spot the errors for your bindings in the output window. Finally, we'll close out this module
                    with the mode and direction of bindings. Bindings flow from source to target, by default, and we've
                    seen that you can have two-way bindings that flow from target to source as well. The binding mode
                    property is the thing that lets you control this, and we'll also look into how the default direction
                    is set for a given target property through its DependencyProperty metadata.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding Sources</h3>
                <p>
                    Let's talk about how the Source object for your binding is provided to that binding. The Source
                    object that's going to be used is explicitly determined by the way the binding is defined.
                    Typically, it's going to use the DataContext of the element that the binding is on, and we've seen
                    that in previous demos, as well as talked about how the DataContext can flow down to that element by
                    being set on some parent element. But there's actually three other ways that you can explicitly
                    point to some Source object. The first one is a RelativeSource binding. RelativeSource is a property
                    on the binding that you can point to a RelativeSource markup extension that indicates where the
                    Source object can be found in the element hierarchy. So it's called RelativeSource because it's kind
                    of like a relative path within the element hierarchy, and there's a couple of different forms this
                    can take on that we'll look at in a demo. Another way you can specify the Source object is with an
                    ElementName. If you're going to use some other element within the current UI as the source object,
                    then you can use ElementName= and the name of that element, and it will locate that element in the
                    visual tree and treat that as the Source object. And then the last way is to use the Source property
                    on a binding. Source property has to point to some object reference that you want to use as the
                    source. Now the only reasonable way to get an object reference down into the Source property is to
                    use a static resource that points to some object in a Resource collection. So let's see all of these
                    in some demoos.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: RelativeSource Bindings</h3>
                <p>
                    In this series of demos, I want to get you familiar with the other ways you can provide a Source
                    object to your bindings other than using the DataContext that is the default. The first one we're
                    going to look at is RelativeSource bindings. So the starting point for these demos is that we have a
                    solution here with a basic data bound form, it's got a DataGrid in it, I can fire it up here, and
                    you can see that we have customers from the Zza database that we're using for sample data in this
                    course. The data access is being done through a data layer that's part of the solution. It just has
                    plain old CLR objects for the data entities and it's got a DBContext and an Entity Framework
                    DBContext that we're doing the data access through. Again, how you do your data access is up to you,
                    just get it into Entities and you're ready to data bind. And we've got the MainWindow code, which is
                    mostly just the contents contained in the DataGrid here with the pre-defined columns. The DataGrid
                    is bound to a Customers collection that we're exposing on our DataContext , and each of the columns
                    is bound to properties on the individual Customer object that's being rendered out. As we talked
                    about before, when a DataGrid renders its rows it sets the DataContext for the current row to the
                    current object, which will be a customer in this case, so these bindings on the columns are relative
                    to a single customer. Then we need to set the DataContext to a collection of Customers, and we do
                    that from the code-behind. Here you can see we're using our DBContext to execute a query on top of
                    the Customers collection, push that into an observable collection that we called Customers, and
                    exposed as a DependencyProperty from our code-behind, similar to previous demos. Then we set the
                    DataContext programmatically here by setting DataContext = the this reference, the Window itself. So
                    the first way we could use RelativeSource bindings is to get rid of this DataContext = this here. We
                    can do that declaratively from the XAML. So I'll delete that from the code-behind, I'll switch over
                    to the XAML and go up to the top to the window element, and I'll add in the declaration here that
                    sets the DataContext declaratively through a binding, and remember, that binding would normally use
                    the DataContext as its Source object. Well, that's going to get you in kind of a recursive thing
                    here, which isn't going to work, so we need the XAML equivalent here of pointing to the this
                    reference on the Window and we can do that with a RelativeSource Self binding. So RelativeSource is
                    a property on the binding when set, it's going to obtain an object reference that will be used as
                    the Source object. And the way it's going to obtain that reference is through one of several modes
                    that this RelativeSource markup extension supports. This one is the Self mode and it's basically
                    like a this reference on whatever element the binding is on. So in this case it's going to obtain a
                    reference to the Window and set that as the DataContext , which is exactly what we're looking for
                    here. Now for another example of using a RelativeSource binding, let's say that in our DataGrid we
                    want to add a Delete button to each row so that we can click on that and delete the corresponding
                    customer. I'm going to drop into my code-behind here and go down to the bottom here, and the idea is
                    that we want to have a method that looks like this on Delete customer that takes in a customer
                    reference and removes it and possibly deletes it from our database. In this case, I'm just going to
                    remove it from the data bound collection, and we need a way to target that method in a data bound
                    way. Now a common way to do that would be to use a command object, so I'm going to add in a new
                    DependencyProperty here called DeleteCustomerCommand. DeleteCustomerCommand is of type RelayCommand&lt;T&gt;,
                    and that's a type that's in my solution here, it's a common pattern in data bound scenarios where
                    you use the ICommand interface of WPF to create an object that can target some other object's method
                    and invoke it when this Command object gets executed. RelayCommand just uses delegates under the
                    covers to point to that method on some other object. The method we're going to be targeting is our
                    DeleteCustomer method and some other object will be the Window itself. So now we need to initialize
                    this DeleteCustomerCommand to an instance of a RelayCommand that points to OnDeleteCustomer. So I'll
                    just go up here to the constructor of the Window and add a line of code that sets that property to
                    an instance of the RelayCommand, and the RelayCommand constructor takes a delegate reference to the
                    target method, which is our OnDeleteCustomer. So we're just using Delegate Inference here in C# to
                    pass the method name directly, and it turns it into an action delegate reference that gets passed in
                    as the argument to that RelayCommand. Then basically, if someone executes this command, they'll be
                    executing the target method of that action, which is our OnDeleteCustomer. So now we just need a way
                    to execute this command, but doing it with data binding from the button within the view, so let's go
                    add that button. To add the button, I'm going to go into the DataGrid itself and just drop in here
                    and add a new column at the front here. And the kind of column that I added here is a
                    DataGridTemplateColumn. A DataGridTemplateColumn uses a DataTemplate, which we'll get into a lot
                    more detail on in a later module, to specify the structure that we want to put into each cell within
                    that column. So you can see we're just putting a Button with its contents set to "Delete", so that's
                    what'll show on the button and that'll show up in each row, basically, right next to the Customer
                    row. Now we need this button to be able to invoke our command or execute that command. So Buttons
                    have a Command property on them, which we can use to set a binding, and basically we need to be able
                    to point this binding to that Command object in our code-behind. The challenge is, this binding is
                    part of the column definition, and as we saw in other column definitions, the DataContext for those
                    bindings is a single row object. So these bindings are binding against a single customer and,
                    therefore, this binding up here would be pointing to a single customer if we relied on DataContext ,
                    but we don't want to put our Delete logic for removing a Customer from its parent collection down on
                    the Customer object itself, so we need a way to point right here to the Window object and to the
                    Command object on that Window, and one way to do that is with a RelativeSource binding. So what
                    we're going to do is use a RelativeSource to kind of escape from the row and walk our way back out
                    to the Window using the RelativeSource. So RelativeSource lets you walk up the visual tree from
                    where you're at to get to some parent element and then look at properties on it. So now I've flushed
                    out this binding and I'm setting a RelativeSource property on it like I did with the RelativeSource
                    Self binding, but in this case I'm going to use a different mode of the RelativeSource object, which
                    is to specify an ancestor. An ancestor would be a parent element within the visual tree. And what
                    you can specify is what is the type of that parent element that we want to walk our way up to. So
                    we're down here on a Button inside of cell, inside of a row, and that eventually walks its way up to
                    the DataGrid itself and says, yes, that is a type match with the kind of Ancestor that we're trying
                    to look for, so that is my Source object. Once I get to that source object, I can use any of the
                    exposed properties on that Source object to get the data I'm trying to get to with this binding. In
                    this case, we're trying to get to the DeleteCustomerCommand that's part of the window. Well, one way
                    I could've done it is I could have walked all the way up to Window here and pointed to
                    DeleteCustomerCommand on that, but just to show another variation, I can just walk my way out to the
                    DataGrid, then I know that the DataGrid's DataContext is the window itself, because that was set
                    earlier on as the overall DataContext for the view. So then I can dot my way down using Property
                    Paths to the DeleteCustomerCommand that is on that DataContext object, which is the window. Now my
                    command is targeting what I want and I can invoke it. Now the other thing is, remember, we wanted to
                    pass a customer. Well, objects that support commands also support CommandParameters, so I can set
                    the CommandParameter to a binding and that binding can just use the current DataContext of the
                    Button, which as I talked about a moment ago, is going to be a Customer object, the one we want to
                    delete. So I can just use binding with nothing else on it here, and it's going to grab the whole
                    DataContext object and pass it as the CommandParameter. With that code in place, I can start and
                    run. You can see the Delete button there, and I can start deleting, and we can see the rows are, in
                    fact, deleting. So those are the primary forms of RelativeSource bindings you'll use. An
                    AncestorType one to walk up the element tree to find some parent element that's a given type, and
                    then use a path off of that current object to get to where you want to go for a value. The other is
                    a RelativeSource Self to effectively get a this reference back to the element that the binding is
                    on, to access some other property on that object. In this case, we don't have a Path statement, so
                    we're getting a reference to the whole object, the Window itself, and setting it as the DataContext
                    .
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: ElementName Bindings</h3>
                <p>
                    In this demo, I'm going to show you how to use the ElementName to specify a Source object for a
                    binding. Our scenario for this one is we still want to delete customers like in the last demo, but
                    instead we decide we want to put the Delete button outside the DataGrid and not have it repeated in
                    every row. We're also going to use commands here again as the way we're going to invoke our
                    functionality. So the first thing we're going to want to do is define a new DependencyProperty
                    that's a Command we can target from the separate button we're going to add. So I'm going to add a
                    DeleteSelectedCommand that's also a RelayCommand&lt;Customer&gt;, and we're going to end up
                    targeting that same OnDeleteCustomer as the Execute method for that command. We're going to need to
                    initialize that, so we'll add an initializer up here in the constructor to set that property to an
                    instance of a RelayCommand, but this one's going to pass an extra method here to the constructor of
                    the RelayCommand. RelayCommand supports the concept of executing a target method. It also supports
                    having a CanExecute handler as a target method. And the CanExecute will be called first to determine
                    whether the command should actually execute the target method, so we need to add that method to our
                    class as well. That method takes this kind of signature, it takes in the same parameter as the
                    Execute method does, a Customer, and it returns a Boolean. The Boolean, if it's true, says that the
                    command is enabled, you can go ahead and invoke the Execute method. If it returns false, then it
                    should not only, not invoke the Execute method, if it's hooked up to something like a Button, that
                    Button will be disabled. And you can see the logic here is we're just going to check our DataGrid
                    and see if there's actually a SelectedItem and return true or false based on that. Now the other
                    thing we need to do is make sure we signal the Button to re-query this CanExecute method whenever
                    the state that drives it changes, so whenever the SelectedItem changes, we want it to re-query this.
                    The way you do that with the RelayCommand is you call RaiseCanExecuteChanged on it whenever the
                    affected state is modified. So we have our SelectionChanged handler for DataGrid, we can just call
                    that anytime Selection changes, and that's going to cause this to be called by the Button to
                    re-query the state and get a new true or false value. Now with all that Command nonsense out of the
                    way, what does the binding look like? Let's jump over to our MainWindow, and we've got a StackPanel
                    sitting here atop our DataGrid. I'm going to go ahead and add a Button that simply says,
                    Content="Delete" on it, so it's just going to sit right on top of our DataGrid and be a Delete
                    button. Now we need to hook this up to our command. Well hooking it up to the Command is actually
                    easier here than it was down inside the DataGrid because the overall DataContext is flowing down to
                    this from up above and that DataContext is the Window itself. So we just need to get to the exposed
                    property on the Window that is the Command, so we can use a straightforward binding that goes to the
                    DeleteSelectedCommand. Now we also need to pass a CommandParameter, so I'm also going to use the
                    CommandParameter property and set that equal to a binding. But this binding needs to point to the
                    Customer that needs to be deleted, and how do we know where that is? Well, it happens to be the
                    SelectedItem on the DataGrid. So we basically need to turn the DataGrid into our Source object and
                    you can do that through an ElementName binding. So I'm just going to say
                    ElementName=customerDataGrid, which you can see down below is the x:Name of the DataGrid. That makes
                    that the Source object for this binding and then I just need the Path to point to the SelectedItem
                    property of that Source object. With that in place, we're ready to go. I can go ahead and run. We
                    can see our button up at the top is disabled because of the CanExecute checks, and there is no
                    SelectedItem currently. As soon as I select an item, the event handler fires, it raises
                    CanExecuteChanged, and the Command calls that CanExecute handler again and sees that it can enable.
                    Now that the button is enabled, I click it, and that first row goes away. Select another one, click
                    it, and the row goes away. So our functionality is all hooked up through an ElementName binding,
                    which points to some element by name that is in the overall XAML you're working with, and then uses
                    the Path to refine what properties on that object you want to grab values from.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Source Bindings</h3>
                <p>
                    The last binding source we're going to look at here is the Source property on a binding. If I wanted
                    to get customers down into my DataGrid here and I didn't want to rely on the DataContext being set
                    to something that exposed that Customers collection, I would point explicitly to some Source object
                    that contained the Customer collection. Now the way you're typically going to do this when working
                    with the Source property on a binding, is to define a resource on the current view that you're
                    working with. It could be an application-scoped resource in the window itself down in some user
                    control that you're working with, but a resource that's in-scope for the element that's going to
                    have the binding. And what I'm using here is a class called the CollectionViewSource. We covered the
                    ICollectionView interface in a previous module. This is an object that implements that, and you
                    point to some Source collection and it's going to wrap it in an ICollectionView. We define this as a
                    Resource with a key so that we can refer to it somewhere else in the XAML and the Source can be set
                    through a binding based on the DataContext . Once we've done that, we can drop down here to our
                    DataGrid and change the ItemsSource here to say, Source=, and basically we have to point to some
                    object here. Now really the only way to point to another object from within a binding is to use the
                    StaticResource or DynamicResource markup extensions, and the StaticResource markup extension takes a
                    key name of the object in a Resource dictionary that you want to point to. So we just need to go up
                    and grab our Resource name that we just created, which is CustomerViewSource, and put that in the
                    StaticResource markup extension. And you can see the squigglies go away, it's now pointing to that
                    CustomerViewSource object, that's coming in as the Source object, and will provide the collection to
                    the ItemsSource . So with that in place and one minor change to the code-behind, I had to move my
                    Commands up to before I set the Customers context because as the Customers bind, it actually changes
                    the selection, tries to use this command object, and if it wasn't initialized yet, it's null, that's
                    going to throw a null reference exception. So we generally want to set up our commands earlier, I
                    meant to put those before the loading of the data, so I've corrected that now. So with that in place
                    I go ahead and run, and we can see we have our Customers collection bound again. But now we're doing
                    it through an explicit Source reference on our binding that points to an object that provides a
                    collection, which in this case happens to be a CollectionViewSource object that has bound itself
                    through a DataContext binding to the Customers collection on the Window. So this one demo shows you
                    RelativeSource Self, it shows you RelativeSource with an AncestorType, it shows you an ElementName
                    binding, and it shows you a Source binding, as well as a number of DataContext -based bindings.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding Property Paths</h3>
                <p>
                    Once the binding has figured out what the Source object is, the next thing it needs to know is where
                    to go on that Source object to obtain the value it's going to use to set the target property and
                    that's where Property Paths come in. The Path property on a binding is what determines the property
                    path. Typically it's going to be a simple value, but it could be a complex path. Basically, the path
                    to the binding can be passed one of two ways. If you use the syntax on the left, which we've seen a
                    number of times, where we just say Binding and Name, you're actually calling a parameterized
                    constructor on the binding markup extension object and that name gets passed into the parameterized
                    constructor and is used under the covers to set a Path property. The alternate way is to use the
                    Path=Name syntax, in which case you're actually calling the default constructor of the binding and
                    then setting the Path property explicitly after construction. Either way, the net result is exactly
                    the same. The binding object is created and the Path property is set to Name. Now bindings are
                    typically set to just a simple path, a property name on the Source object itself. So if your Source
                    object is a customer and you want to grab the name value off that customer, you just say Path=Name.
                    They can also be complex paths and walk an entire object graph from the Source object. So if your
                    Source object is, say, the Window, and the Window exposes a customer, then your path may be Customer
                    and then dot down into the Orders collection of that customer, index into that array, and get a
                    single object out of the orders, in this case the second omen in the array, then the Order object
                    that you obtained can have a collection of OrderDetails, so we can dot down to that. We could reach
                    into that collection and grab out the third object from the OrderDetails collection. On that
                    OrderDetail object it may have a Product-related object, we can dot down to that, and then finally
                    dot down to the name once we get down to a discrete value that we're trying to set through our
                    binding, we're ready to go. You can also add no path at all. So you can basically let the bindings
                    say, give me the whole Source object, and we've seen a couple of these in previous demos as well.
                    You can express this with just Binding and no arguments whatsoever, and you're basically saying
                    Path=. is the equivalent syntax, dot meaning the current object, similar to a file system path. Now
                    an important concept related to binding paths is how you go about debugging bindings that are not
                    working for you. Basically, you want to always be paying attention to the output window when you're
                    hooking up data binding and trying to get it working. If you have an error in one of your bindings,
                    particularly the path is incorrect, what you're going to get is some information dumped to the
                    Output window and it looks kind of like this. You can either have data warnings or data errors and
                    it's going to tell you detailed information including what property was not found on what Source
                    object, in this case, 'Idx' and 'Customer', and then it's also going to tell you what the target
                    element property and type is as well. So this is something you can stare at and then go inspect
                    those objects and figure out whether you've actually got something that should be working. By
                    default, Visual Studio is going to show both warnings and errors. If you want to only show errors,
                    which are the more severe form, you can go through Tools Options and there's a place under the
                    debugging section where you can change the data binding WPF Trace Settings. So let's take a look at
                    Property Paths and debugging in a demo.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Binding Property Paths</h3>
                <p>
                    In this demo, I just want to quickly revisit Property Paths on bindings to make sure it is clear the
                    power you have to locate the particular value you want once you have some Source object. I'm going
                    to drop into the XAML of our last demo and just point out a couple of these paths that we've been
                    using here. Most of the bindings we've looked at take on a form like this, which is really saying
                    the Binding Path property is equal to Customers. The way it works out without the Path property is
                    that the Binding markup extension itself has a parameterized constructor that takes one argument and
                    it'll use that argument to set the Path property. So whether you say Binding Customers here or
                    Binding Path=Customers, they mean exactly the same thing, just a different way of initializing the
                    Binding object. Now another path we saw in one of the last demos was this Path= DataContext
                    .DeleteCustomerCommand. Remember this was with the RelativeSource binding where we were walking up
                    the visual tree to get to the DataGrid and then basically saying, go to its DataContext property,
                    which happened to be the Window in that demo, and then dot your way down into that object to get to
                    the DeleteCustomerCommand. Well you can take this to the nth degree if you need to, so I'm going to
                    go up here to our StackPanel and I'm going to add in a label and set the content of that label using
                    a binding. That binding is going to be pointing to the DataContext , which is our Window, which
                    exposes a Customers collection. I can then index into that Customers collection and grab the first
                    item, that's going to be a single Customer object. I can then dot into that Customer object, which
                    has an Orders collection, and index into that to get the second order. That order has an OrderItems
                    collection, I can dot down to that, I can index into that to get the first OrderItem. That OrderItem
                    has a Product property which is a complex object. I can dot down to that and dot down to the Name of
                    that product and display the resulting value in my content. Now I just need to make sure that my
                    query loads up all those related objects, so I'll go into the code-behind and replace my line of
                    code that's loading up Customers so that .Includes all the related collections and objects there.
                    With that in place, I can go ahead and run, and notice up here next to the Delete button we have Taj
                    Mahal is the name of the product that is on the related objects there. Now one other thing that's
                    related to property paths that's important is debugging when binding goes wrong. If I have a typo in
                    my path here, say I put an inadvertent x on the end of my DeleteSelectedCommand and I go ahead and
                    run, the app is not going to blow up, it's just going to start up and run, and then you'll wonder
                    why, in this case, the Delete button is enabled and I'm clicking away on it and nothing's happening,
                    and you'll kind of wonder what's going on there and wonder how to debug it. The important thing is
                    when you have that kind of thing going on you always want to look at your output window. If we go
                    back up in our output window here, we'll see this entry that says, System.Windows.Data Error:
                    BindingExpression path error: and it basically breaks it down for you and it says, this property was
                    not found on this object, which is the DataContext object. And if you scroll over some more it tells
                    you the BindingExpression path equals this, the DataItem is that DataContext object, and then it
                    even tells you the target element, the thing you were trying to set was the 'Button' 'Command'
                    property. So when you screw up a binding path, you always want to be looking for these
                    System.Windows.Data Errors in your output window for debugging your bindings.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding Mode and Directionality</h3>
                <p>
                    Now let's talk about directionality and the Mode property on bindings. Bindings can flow data in two
                    directions. From the source to the target is the standard direction to populate data on the screen,
                    but also from the target back down to the source if you're doing two-way data binding. The default
                    mode for a binding is really determined by the DependencyProperty that's the target of that binding.
                    So when that DependencyProperty is declared, if it doesn't say anything, the default is going to be
                    one-way. But through its PropertyMetadata it can indicate that it wants to be a two-way binding by
                    default, such that the text property on a TextBox or any primary prosperity that's an edit input on
                    editable controls. So in WPF, the primary properties of editable controls are set to two-way by
                    default, but other read-only controls such as a label and other properties will be one-way be
                    default. Just be aware if you're using other XAML technologies, the other XAML technologies don't do
                    this, all properties are one-way be default, and you always have to set the Mode property to two-way
                    if you mean it to be, but in WPF they make it a little easier. The way you can influence this in
                    your bindings is simply by setting a Mode property on the binding. It's got a number of values.
                    One-way is the default. Two-way might be the default if it's an editable control. There's
                    OneWayToSource, which is basically from the target to the source, but it never reads from the source
                    to the target. And there's OneTime, which means it reads from the source to the target once, and
                    then it forgets the binding exists, so any changes to the source won't be reflected, even if there's
                    property Change Notifications and then the editing in the UI will not push any values down to the
                    Source object. There's also a value on the enumeration called Default, and that's basically saying,
                    do whatever the target property wanted to do by default, which again, is going to be OneWay, in
                    general, by default, but most editable properties on editable controls in WPF are set to TwoWay by
                    default. So let's take a look at Binding Mode in a demo.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Binding Mode</h3>
                <p>
                    In this demo we're going to cover the Binding Mode property and how it influences the direction of
                    flow of data through a binding. The starting point for this demo is a simple little data app that
                    has a data entry form for a Customer object here and it has this button to trigger a customer
                    change. If you watch the Name field when I click on that, it's going to go programmatically set the
                    name of the Customer. Now the current structure of the code is we're setting the DataContext to the
                    Window itself through a RelativeSource binding like we saw earlier in this module. We've got the
                    grid as a whole, bound to a Customer property exposed from the Windows code-behind, and then the
                    individual fields are just using DataContext bindings to point to the properties of that Customer
                    object. Now by default, a binding has a Mode, and the Default Mode depends on the property that
                    you're binding on the control itself. Data entry controls, such as TextBoxes, ComboBoxes,
                    DatePickers, and so on, set the Default Mode for their primary Edit properties to be a TwoWay
                    binding. That means that if I run here and we edit the field and tab out of it, we can see from this
                    breakpoint that the set block on our Name property on the Customer object is being called. So the
                    normal flow is from the Source object to the element with the binding, but if we edit it in the
                    bound element, then that property is going to change and push the value down into the Source object
                    in a TwoWay data binding fashion. And as long as that object supports Property Change Notifications
                    , if it gets changed programmatically like with our button, it will update on the screen. That's
                    your typical TwoWay data binding scenario. Now we could modify the behavior here by going into our
                    binding and setting the Mode property equal to one of the other values. I'll start with OneWay. If
                    we explicitly set it to be a OneWay binding and we have that same breakpoint on our Customer object
                    behind the scenes, I can modify that Name property and tab out of the field, but we never hit our
                    breakpoint because it never pushed that value down into the Source object, because it's set to be a
                    OneWay binding. OneWay means from source to target, not the other way around. Now if we did want it
                    to be the other way around for some reason, we can set the Mode to OneWayToSource. If we do
                    OneWayToSource and start up, we can see that our form starts up in the field as blank, even though
                    there is a value in the underlying Customer object for Name, it didn't read it because it's only got
                    the one direction in the opposite direction that a binding normally works. But if we change the
                    value and tab out of the field, you can see that we called a set block on our bound object. Now
                    that's a pretty rarely used value, generally you want OneWay or TwoWay, but that's an option if you
                    have a specialized scenario. Another option you have there is OneTime. OneTime means that it will do
                    normal data binding from source to target one time, but if it changes behind the scenes, even if
                    it's raising Change Notifications , notice if I click on the Trigger Customer Change here, under the
                    covers we can see the property is being set, but the UI does not update because the mode of OneTime
                    basically says, do data binding one time and then pretend that this binding is not even there, and
                    changes to the field itself will not trigger any change to the underlying Source object. It's as if
                    the binding evaporates after it does the initial read of the value from the Source object.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Defining Default Binding Mode</h3>
                <p>
                    Now, in this demo, I want to show you how the Default mode really works based on the property that
                    you're binding. When controls are created and their properties are defined as DependencyProperties
                    that can be bound to, by default, binding will only be supported one way, but there's a property you
                    can set on the DependencyProperty itself to make it so it will be a TwoWay binding by default. To
                    show this, I'm going to create a custom control, just a simple User Control, and we'll call it
                    MyCustomControl. For the content of that CustomControl, I'm just going to put a rectangle with a
                    fill of gray by default and give it a name of "TheContent". Then I'm going to drop into the
                    code-behind of that control and define a DependencyProperty . So this DependencyProperty is going to
                    be of type Brush called MyBackground, and what's different about the declaration of this
                    DependencyProperty , is notice this down here. With the default code snippet, it's going to define
                    just a PropertyMetadata object here and allow you to set the default and possibly hook up a Change
                    handler. If you change that to be a FrameworkPropertyMetadata, you can still set a default value,
                    which you can see I'm setting to gray here, but you have this FrameworkPropertyMetadataOptions, and
                    you see that there's an option to say BindsTwoWayByDefault. Then I also hook up a Change handler
                    here so that whenever my background gets set I'm going to go set the Fill property of the rectangle
                    that's my content. And then I'm also going to drop into the constructor of my CustomControl here and
                    add an Event handler for the MouseDown event on my rectangle that's my content. And what I'm going
                    to do when I get that Click on it, is I'm going to explicitly set the MyBackground property to red
                    so that we can see that that change actually occurred. So I'm going to go out here to my MainWindow
                    now and drop into the XAML and add an instance of our CustomControl. Notice that I'm setting the
                    MyBackground property to a Brush returned from the current DataContext called TheBrush. So I need to
                    go declare that in the code-behind in my MainWindow that is my DataContext . So I add this
                    DependencyProperty called TheBrush to my code-behind and it's just a standard DependencyProperty
                    with a Change handler that's hooked up here so we can set a breakpoint and tell when the binding has
                    actually set that value for us. And then I'm just going to go into my constructor and set an initial
                    value for my Property of Chartreuse. So with that in place, if I go ahead and run, we can see it
                    starts up with our chartreuse rectangle. Remember that I have a MouseDown handler inside the
                    CustomControl that's going to set the MyBackgroundProperty. That's equivalent to something like a
                    TextBox setting the Text property when I do data input on the control here. And we want to see that
                    that value flows to the Source object because the data binding is TwoWay. So when I click on this,
                    we can see that our breakpoint is being hit in our Change handler for TheBrush property and our
                    DataContext . So the TwoWay data binding has worked out for us and is passing that value in. So the
                    default mode for a binding is basically going to be OneWay unless the DependencyProperty that you're
                    binding to has gone and set its default to be TwoWay with this FrameworkPropertyMetadataOptions.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    Okay, to wrap up this module, we covered a number of things. First off, we reviewed the fact that
                    the default source for a binding is always the DataContext and for the vast majority of data binding
                    scenarios, you're going to use the DataContext as your Source object, but there's specialized
                    scenarios where you need more control and so we looked at the RelativeSource binding as one way to
                    do that where you can reference other elements in the visual tree through a relative path within the
                    tree. You use the RelativeSource markup extension and the property on the binding, you can use the
                    Self mode to point to the same element that the binding is on, or you can use the AncestorType to
                    point to a parent element somewhere up the tree looking for a match based on the type of that
                    element. the elementName binding is another way to get an explicit Source object for your binding by
                    pointing to some other element within the visual tree that has a name on it and that doesn't
                    necessarily have to be an explicit ancestor of the element that you're on. Then we looked at the
                    Source binding and the Source binding allows you to explicitly point to some object that you have to
                    place within a Resource dictionary and then get to it through a StaticResource or DynamicResource
                    markup extension that points to that object, then that can become the Source object for your
                    binding. Next we looked at Property Paths in a little more detail and we saw that there's a number
                    of forms it can take on. You can have a simple property name on the Source object, you can have a
                    dot, which means the whole Source object, you can exclude the Path, which means the same as the dot,
                    or you can have a complex path that starts with the property name on the Source object, but then
                    dots down through an object hierarchy, even indexing into arrays as part of that path syntax. We
                    covered the directionality of bindings, the fact that they are one-way by default where the data
                    flows from the source to the target at initial binding time, and when property Change Notifications
                    occurs, but you can use two-way bindings either explicitly by setting the Mode property or if you're
                    on an edit control, with the primary edit property such as Text on a TextBox. Those properties can
                    be declared to be two-way by default, and the way you do that default declaration is through the
                    metadata of the DependencyProperty that's going to end up being the target property on the element,
                    and we saw how you can declare that yourself if you're writing a CustomControl with properties that
                    you expect people to bind to.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Unleashing the Full Power of Bindings</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes, and in this module we're going to dive deeper into bindings and look at a
                    number of additional properties that let you unleash the full power of what a binding can do for you
                    for specialized scenarios. First up, we're going to look at a property called UpdateSourceTrigger,
                    and this is a property on a binding that controls when data flows from the target to the source into
                    a data binding scenario. The Default mode is when focus changes, but you'll see there's a number of
                    other options there and I'll explain how that works. Next we're going to talk about Converters.
                    Convertors give you a lot of power because it allows you to insert an object between the source and
                    the target object conceptually, hooked up through the binding, and the data will flow through that
                    Converter. So as the data flows from the source to the target, you can change the value or the type
                    of the object that's being used to set the target property. And, likewise, in a two-way data binding
                    scenario, as data flows from the target to the source, you can do a similar transformation either in
                    value or in type. Next we'll talk about Async Bindings. Normally, bindings all happen on the UI
                    thread, but sometimes you may need to have the get and set block of your source property called on a
                    background thread, and Async bindings allow you to do that. Then we'll talk about Fallback values
                    and this is really two separate properties on a binding, one called FallbackValue and one called
                    TargetNullValue, that allow you to provide alternate values to be used when the source object can't
                    be resolved properly. Next we'll talk about FormatString. This is an automatic convertor of sorts,
                    that lets you convert from the source property into a formatted string using any standard .NET
                    FormatString to render out the value the way you want to present it to the user. Finally, we'll
                    finish off with a couple of specialized bindings called a MultiBinding and a PriorityBinding. These
                    bindings allow you to aggregate multiple bindings into a collection, and in the case of the
                    MultiBinding, you can come up with a single value based on the individual values of those multiple
                    bindings. And in the case of the PriorityBinding you can pick from one of the child bindings which
                    one to use based on a priority scheme. So let's dive right in and see how these modify the behavior
                    of our bindings.
                </p>
            </div>
            <div class="panel-body">
                <h3>UpdateSourceTrigger</h3>
                <p>
                    Now let's talk about the triggers that cause data to flow through a binding in a two-way data
                    binding scenario. By default, the modified values in a binding control only get pushed down to the
                    source object when you tab out of the field or really a focus change, so things like minimize,
                    maximize, and switching to another window would also do it. Sometimes, however, you want to get the
                    values sooner than that. You want it keystroke by keystroke in the TextBox, for example, or you want
                    it as a slider bar is being slid. To do that, you can use a property on the binding called
                    UpdateSourceTrigger. The default value is called Default, and it basically means lost focus for most
                    controls. There's also a value called LostFocus and then there's the PropertyChanged value.
                    PropertyChanged says, whenever the target property changes, such as Text on a TextBox, which will
                    happen with every keystroke or the position on a slider, then you want to push that current value
                    down into the source object. LostFocus is going to wait until the focus leaves the control.
                    Basically, Default and LostFocus mean the same thing for most controls. The one place they're
                    different is in a DataGrid. Default means when the row itself that the editable control is in loses
                    focus, whereas LostFocus means the cell lost focus. So basically, if you set it to LostFocus, as
                    soon as you tab out of the cell, the value will be written to the source object. If you leave it on
                    the default, then you're going to have to actually click on a separate row or tab out of the row
                    before the values of all the edited cells will be written to the source object. And, of course, even
                    in the DataGrid scenario, PropertyChanged means keystroke by keystroke in a TextEdit field, for
                    example. So let's take a look at using UpdateSourceTrigger in a demo.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: UpdateSourceTrigger</h3>
                <p>
                    In this demo, I want to show you how to use the UpdateSourceTrigger property on a binding to control
                    exactly when data flows in a two-way data binding scenario. By default, as we've talked about
                    before, when you've got a two-way data bound scenario here, the point where data flows is when you
                    tab out of the field, and that's called LostFocus. That is the default UpdateSourceTrigger for most
                    bindings. I'm going to drop into the XAML here and add a couple of Labels and TextBoxes, which we
                    can show up down here as Source and Target, two different TextBoxes. And the way the bindings are
                    set up here between these is that you can see the Source TextBox has no binding, so it's just going
                    to reflect whatever is put into it as a source object. The Target TextBox has its text bound, but
                    it's using an ElementName binding, which we covered earlier, to point to the source TextBox as a
                    source object. And because the Path that we point to is a DependencyProperty , that's going to raise
                    Change Notifications , and we should see the Target update whenever the Source value changes. So
                    that means for every character that we put into the Text, the Text property is changing and it's
                    going to update the Target to reflect that. Now notice this UpdateSourceTrigger=PropertyChanged. If
                    I leave it on Default, once I start putting stuff in the Source, you can see that the Target stays
                    in synch on every keystroke. However, if I go to the Target and start putting stuff in, the Source
                    does not update until I tab out of the field and then the Source is updated because of the focus
                    change. So the Default UpdateSourceTrigger is really a focus change for most elements. So if I
                    change this to PropertyChanged, it basically says, every time the Target property changes, which is
                    the Text property of this TextBox, go ahead and push its current value down into the source object's
                    property. So now we're going to get fully synchronized if we start up. Source is raising
                    PropertyChanged on every keystroke because the text of the Source is changing, but now on every
                    keystroke in the Target, it's pushing the current value of the text of the Target down into the
                    Source property. So basically, when you want the source set immediately every time the bound
                    property changes, then you want to use the PropertyChanged on UpdateSourceTrigger. This is
                    especially good for validation scenarios where you want immediate feedback to the user and not wait
                    until they tab out of the field. Now you can see here there's actually four choices there. There's
                    Default and LostFocus, which for most controls mean exactly the same thing, lost focus. The place
                    where they're different is if you're inside of a DataGrid. If the bound control is inside of a
                    DataGrid, Default means losing focus on the row that the control is within, whereas LostFocus means
                    losing focus on the cell that the control is within, but for single controls like a TextBox,
                    Defaults and LostFocus mean the same thing. We covered PropertyChanged. Explicit is a mode where you
                    actually have to use programmatic call against the binding itself to tell it when to flow the data.
                    So data is not going to flow automatically in any case, you have to tell it to flow the data and
                    it's fairly rarely used.
                </p>
            </div>
            <div class="panel-body">
                <h3>Converters</h3>
                <p>
                    Now let's talk about using Converters and bindings, which is a very powerful mechanism to be able to
                    transform values as they flow from your source object to your target and vice-versa. Basically, a
                    Converter is a chunk of custom code that you can write that's going to sit in between that source
                    and target object, and as the data flows from the source to the target, you can transform the data
                    value. You can transform just the value using the same type, so in a numeric scenario maybe you
                    would round off a floating point number to a whole digit, but still keep it as a float. But you can
                    also transform the data type. So one example that I'll demo is, that we could data bind to a Boolean
                    property, but set a Style property based on that Boolean flag. The way you define a convertor is by
                    creating a class that implements the IValueConverter interface. This interface has two methods.
                    Convert is the method that gets called when data is flowing from the source to the target and
                    ConvertBack is called in two-way data binding scenarios when data is flowing from the target to the
                    source. So basically, you just implement this interface on a class, you put an instance of that
                    class in a Resource dictionary within your UI, and then you point to that Converter instance from
                    the Converter property on a binding using the StaticResource markup extension. So let's take a look
                    at a couple of examples of using converters.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Converters</h3>
                <p>
                    In this demo, I want to show you how you can use converters with bindings to change the value that
                    gets set through a binding or to change the type entirely. For our first scenario, let's say that
                    anytime you want to display negative numbers in a form, you want to put parentheses around them
                    instead of showing the minus sign. That's something I can accommodate through a converter. So I'm
                    going to go and add a class to my project here called NegativeNumberConverter. To implement a
                    Converter, you're going to want it to be public so it can be called by the framework, and you're
                    going to implement the IValueConverter interface. I can stub out the methods on that interface and
                    you can see that it has two methods, Convert, and ConvertBack. Convert gets called as data is
                    flowing from the source to the target. The value that is going to be set, flows in here and tells
                    you what the type of the Target property is that's going to be set and it has an optional parameter,
                    and will tell you what culture it's being done in, so you can use converters to actually modify
                    values for localization purposes. ConvertBack is called if you have two-way data binding and the
                    value is being pushed down from the target down into the source object. So I'm going to replace this
                    implementation with a fully _____ fleshed out version, and you can see what the implementation does
                    here, is it's expecting this to only be hooked up to integers. Now to write a production _____ of
                    one of these, you want to do a little more type checking and not just blindly cast the value here,
                    which could blow up if it's not an integer. But here we're assuming we're only going to be hooked up
                    to integers. We cast to an integer and we check to see whether it's greater than or equal to 0. If
                    so, we're just going to return it as a string, but otherwise, we're going to negate it here and put
                    it in between parentheses using a string format. If we're going to support two-way data binding and
                    allow people to enter negative numbers with parentheses around them, then the value is going to flow
                    in here when they tab out of the field or if you're using UpdateSourceTrigger=PropertyChanged. And
                    we're going to look here and see if it starts with parentheses and ends with parentheses. We're
                    basically going to strip those off and negate the value that's there to return the negative integer
                    down to the source object. Now to use this converter I need to create an instance of it and use it
                    in a binding. So I'm going to go over to my MainWindow and I'm going to go to its Resource section.
                    And the way you'll typically use a converter is by creating an instance of it in your Resources
                    collection and give it a key. Then you can refer to it in a binding using a StaticResource. So then
                    we're going to drop down into the form here to the field that we have that's a numeric value, such
                    as an age, and we're going to use the Converter property, say StaticResource, grab the key name of
                    our Converter as we defined it up above, and pass that as the key in the StaticResource. So that's
                    going to pull in a reference to that converter and basically invoke it. Anytime data is flowing from
                    the source to the target, it's going to call the Convert method, and then if we edit this and push a
                    value down through, it's going to invoke the ConvertBack method on that converter. With that in
                    place, we can go back here to where our Customer is being initialized and we'll set it as -35 there,
                    and I'll go over to the Age property on my Customer object and set a breakpoint so we can see when
                    it's being set what it's being set to. We'll go ahead and start up and it will be called here one
                    time as it's initializing, and we see it renders out with parentheses instead of the -35. And if we
                    put in some other values, such as 99, and tab out of the field, our set block gets called, and the
                    current value is -99, so it strips off those parentheses and turns it into an actual negative
                    integer. Now as another example, let's say we want to set a style based on a Boolean property in our
                    model. I'm going to add a _____ Style Converter and I'll quickly _____ flush out the implementation.
                    You can see what this is doing is it's doing a little more type checking, so it's saying, if the
                    target type is a style and the input is a Boolean, then that's what this thing was designed to do,
                    otherwise, it's just going to blindly return the value and say, this converter doesn't know what to
                    do with that. And for a starting point here, it's going to say, I could hard code here a style name
                    of TrueStyle and FalseStyle corresponding to those Boolean values and go use a Helper method here to
                    reach out to my Application Resources and get the Style by name out of my Resource dictionary. Then
                    I'm just going to return that as the value that actually gets set on the target of the binding.
                    Based on that code, I'll need those styles to exist so I'll go out of here to my
                    application.Resources and pop in a Name Style called TrueStyle and FalseStyle that are just going to
                    set the foreground to Red for True and Black for False. Now to use that in my application, I would
                    go to my MainWindow to the Resources, and create an instance of that Converter and give it a name.
                    And then on the control that I wanted to use it on, such as my TextBox, I would set the Style
                    property using a Binding so the value that's going to come out of the Converter is a Style, but the
                    input is a Boolean. So I'm pointing to a Boolean property on my model called premium customer and
                    then I'm using my Converter instance to convert that Boolean value into a Style value. With that in
                    place, I can go ahead and run, and we can see that Joe is red right now because it is a Premium
                    Customer. If I uncheck it, it goes to black and back to red. Now obviously hard-coding Style names
                    down inside some code like this is not a great idea, and that's where this object parameter can come
                    in. You can pass ConverterParameters to a converter to drive its behavior. So if I modify that
                    implementation a little bit, and I expect my parameter to be a semi-colon separated pair of Style
                    names, I can split that out into an array and then use the first one as my TrueStyle and the second
                    one as my FalseStyle. Now I can just go back to where I was binding the Style and add another
                    property on my binding called ConverterParameter, and pass that value, which is going to be
                    TrueStyle;FalseStyle. With that in place, the same behavior is manifest, it's red now, it goes to
                    black when I uncheck the Premium Customer property. But now this BoolToStyleConverter is a little
                    more reusable because you can pass in those two different styles that it supports as a parameter
                    when you use the Converter. The one downside to be aware of is when you use a ConverterParameter,
                    the values will have to be statically expressible in the code here. And that's the basics of using
                    Converters.
                </p>
            </div>
            <div class="panel-body">
                <h3>Async Binding</h3>
                <p>
                    Most of the time you're binding, you're going to be binding to objects in memory that have already
                    been populated and so the binding can pull the values out of the properties very quickly and push
                    values back into those objects quickly. Occasionally, you might bind to something that's a little
                    slower, and that's where Async bindings come in. So a binding is calling the get and set block of
                    the property it's bound to, and it does that on the UI thread in a synchronous manner by default.
                    Now one thing to be aware of is that in WPF your source objects can raise PropertyChanged on a
                    separate thread, so you could have a background thread or an Async service execution that goes out,
                    gets some data, and pushes values into your data bound objects. And when you call the set block, the
                    PropertyChanged event is going to fire. In WPF that's okay. The binding is actually smart enough to
                    see that you're not on the UI thread, switch to the UI thread and get the value, and update the UI,
                    only on the UI thread. However, just be aware, other XAML technologies are not as smart. You cannot
                    do that same thing in other XAML technologies, you'll have to make sure your set blocks are always
                    being called on the UI thread if they raise PropertyChanged. Now if the get and set blocks will
                    execute slowly, maybe they make a database call themselves or the service call themselves, you can
                    get the binding to call those on a background thread itself. So all you do is you set IsAsync true
                    on the binding, and the binding is actually going to go grab a background thread and use that to
                    dispatch the call to the get or set block. And then once it gets the value, it'll set the target
                    property on the element using the UI thread. Another form of Async the bindings support, is setting
                    a Delay on when the binding can call the set block. So this is only for two-way data binding
                    scenarios and it's basically there to act as a buffer to make sure that you're not sending new
                    values down to the source object too often. The Delay property is specified in ms and it's
                    basically, how long will the binding wait before it attempts to set the property on the source
                    object, even if the target property is rapidly changing? So let's take a look at a demo of working
                    with Async bindings.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Async Binding</h3>
                <p>
                    In this demo, I want to show you how you can use the Async capabilities of bindings. Now in most
                    binding scenarios, as long as your data is already right there in memory, populated on whatever your
                    model objects are that you're binding to, you won't have to worry about doing the binding itself
                    Async. You may have some code behind the scenes that gets these things loaded up asynchronously, but
                    the bindings itself won't have to be Async. But depending on the way you structure things, you may
                    have setters and getters on a given property that take a while to execute. So I'm going to simulate
                    that in this case by putting a Thread.Sleep in the get and set block of my Phone property on my
                    Customer. And if I did that without doing anything else and tried to run, first off, we can see as
                    it starts up it's waiting a full 5 seconds before the UI becomes responsive because it's got to read
                    that value in to populate the UI through the binding and it's got to wait for that full execution of
                    the get block to complete. Likewise, if we go and change that field and tab out of the field, you
                    can see the cursor didn't move, it's gone completely unresponsive, and will stay that way until the
                    set block execution completes and then it comes back to life. Obviously not the user experience
                    you're going for. So if you're doing complex model objects that you're binding to where the get and
                    set blocks of the properties you're binding to execute real work such as doing a database query or a
                    service call or something, you may need to use Async bindings then. So all you would do to leverage
                    Async bindings, is go to the binding on the property that you want to be Async and say,
                    IsAsync=True. Now, if we start up our same exact scenario, you can see the UI comes up and is
                    responsive right away, and then 5 seconds later the Phone pops in there when the set block is
                    finally done executing. And, likewise, if we modify it and tab out of the field, it just goes blank
                    and we can be using the rest of the UI until the point where the Phone set block completes and the
                    value pops back in there. So it just makes it a non-blocking thing the WPF is going to actually go
                    use a background thread to invoke the get and set blocks when you have IsAsync=True on the binding.
                    But that also means that these are actually going to execute on a separate thread, so you do have to
                    be concerned about concurrency if the UI thread can also access this code. The other thing to be
                    aware of is that if you have multiple threads in your application and a background thread calls this
                    set block, it's going to raise the PropertyChanged notification, which goes up into the binding and
                    the binding has subscribed to that based on seeing that your bound object supports
                    INotifyPropertyChanged. And generally you don't want to be doing anything to a UI element on a
                    background thread. The good news is, in WPF, and only WPF, the other XAML technologies this is not
                    true, you can raise PropertyChanged from a background thread and the WPF binding will be smart
                    enough to switch back over to the UI thread before it calls the get block and modifies the UI based
                    on the PropertyChanged notification. So it is safe from a binding perspective to set the property on
                    a background thread. So another binding property related to Async that you might use in some
                    scenarios is the Delay property. So I can add Delay=500 on my data binding to my two TextBoxes down
                    here. So I could add Delay=500, and that's in ms, on my two TextBoxes that are bound to each other
                    down here. And what that's going to do is act as a throttle for input. So this only affects the
                    calling of the set block and it basically says, my input may be coming quicker than I actually want
                    to go set it on the data bound source object, so I'm going to delay by this much time before I call
                    the set block, and if I would have triggered multiple times within that time window, I'm only going
                    to call it once when that time window is up. So with that in place, we can see the visual impact of
                    this behavior. If I go down here to my source, I start setting things there in sync. I go to my
                    target and I rapidly input some stuff. 500 ms later, it fills in the source and it only set the
                    source one time in that case at the 500 ms point. Do it again, and 500 ms later, one set of the
                    source happens, not one for each character that I was setting. So this is handy for situations like
                    this if you may have some very rapid input, especially if you're doing something like an
                    auto-complete service call to look up the available candidates, and you don't want to do that
                    service call on every single keystroke. Another example would be if you were binding the current
                    position in something like a slider, you don't want to necessarily go set the property on the source
                    object on every miniscule movement of that slider, just when it finally settles in position or has
                    moved by a significant amount, so you could set the Delay property on there so that it only sets the
                    source property every 500 ms, for example.
                </p>
            </div>
            <div class="panel-body">
                <h3>Fallback Values</h3>
                <p>
                    Another minor capability of bindings you should be aware of is the ability to supply some fallback
                    values when the binding can't come up with an appropriate value to set the target with. The first
                    one of these is called TargetNullValue, and the name is a little deceptive there. What it really
                    means is, if the source object's property is null, what is the value you want to use for the target?
                    So you basically supply a value in the binding that's going to be used to set the target property if
                    the current value of the source property is null. The other one is literally called FallbackValue,
                    and this one is used when the binding can't come up with a value at all based on the data source and
                    the path. So when that's the case, it can't come up with the value, and you supply a FallbackValue,
                    it's going to use that value to set the target instead. So let's take a look at a quick demo of
                    using both of these.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Fallback Values</h3>
                <p>
                    In this demo, I want to show you a couple last properties here on the binding which relate to having
                    fallback values when the binding can't quite come up with the value it's supposed to use for
                    binding. What I mean by that is, I can go into my MainWindow here, and we'll just use my Name
                    TextBox that I've been binding, we'll go to its Text Binding here for name, get rid of the
                    Mode=OneTime here, and we'll say, TargetNullValue-'Not set'. What TargetNullValue means, the name is
                    a little misleading there, it's really if the source value is null, then what is the value you want
                    to set on the target instead of null? So if we go to the code-behind to the point where we're
                    setting the name, and we set it to null here, start up the UI, and we see, Not set. So because of
                    the value that the binding came up with was equal to null, and we had the TargetNullValue there, it
                    used the value provided by the TargetNullValue property on the binding. Another somewhat similar
                    property is the FallbackValue. So here we're going to say FallbackValue='no value'. This will be
                    used when the binding is unable to come up with a value at all based on the Path that it's given. So
                    if I corrupt my Path over here and say Namex, which doesn't exist on my DataContext object, and I
                    run, now we see no value in there because the binding was unable to evaluate and come up with a
                    value to set the target property. And, again, down here in the output window, notice that we have
                    one of these System.Data Warnings that says, Namex not found on Customer. So you always want to be
                    looking for those. In this case, it was a warning, not an error, because we had the FallbackValue
                    here. If we get rid of the FallbackValue and run with Namex in place there, now you can see it's a
                    System.Windows.Data Error down here because it can't come up with any value to present in the UI. So
                    _____ those are TargetNullValue used when the Source property is null, and gives a value to set on
                    the target and FallbackValue when it can't resolve a value from the specified binding Path.
                </p>
            </div>
            <div class="panel-body">
                <h3>StringFormat</h3>
                <p>
                    StringFormat is a handy property on bindings for being able to render out a formatted value in the
                    form of a string for a given source property value. You can think of StringFormat as an automatic
                    converter from the source property type to a string, applying formatting in the process. So with it,
                    you can use any standard .NET format string, the same kind of format string you would use with the
                    String.Format method in the framework. There are a number of built-in format strings for things like
                    dates and numeric formats, and you can come up with your own custom format strings as well. Now this
                    works great in simple scenarios where you want to render out a date in the TextBox or a numeric
                    value in a TextBox and have some formatting applied to it. But there is one gotcha with it, you
                    generally don't want to combine it with the UpdateSourceTrigger=PropertyChanged value. There can be
                    some weird input behaviors that you'll see in the demos that makes it kind of unsuitable for use in
                    combination with that, and I'll just defer to the demo to show you what I mean by that.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: StringFormat</h3>
                <p>
                    In this demo, I want to show you quickly how to use the StringFormat property on a binding to render
                    out a formatted value to the user interface. Our starting point here is the same demo app that we've
                    been using up to this point and what I'm going to focus on is this Age field. If you remember from
                    previous demo, we were applying a converter there that's putting the parentheses there for a
                    negative value. We're going to replace that and do some string formatting. So, first off, I'm going
                    to drop into my Customer and change my Age property to be a floating value so that we can put some
                    decimal points in there. And I'll do that on the member variable and on the property. Then I'm going
                    to drop into the UI and find the Age input, and I'm going to replace that with a slightly different
                    Text Binding. So here we can see we're still binding to the Age Property, but now we just simply set
                    the StringFormat property and here we're using one of the pre-defined StringFormats, a floating
                    point with two decimals. If we go ahead and run now, we can see that that value which is set to -35
                    now displays with two decimals. If we go and make other mods to it, let's say we set it to 44.444
                    and we tab out of the field, notice as we tab out of the field the value is written to the
                    underlying object and the value becomes 44.44. Now let's go set a breakpoint in the set block and do
                    that again, and we'll say 44.55, tab out, and we can see the value that's being set is the full
                    precision value, but when we run, all we see is the rounded off value applied by StringFormat. So
                    one downside to using these is to realize that what you see on the screen and what the actual
                    underlying values are might be slightly different, but if the way you want to display it to the user
                    is always with two decimal places, then that's up to you to manage the actual precision under the
                    covers. Now there's one other gotcha to be aware of with using StringFormat. If we also add the
                    UpdateSourceTrigger=PropertyChanged property on our binding, which we saw earlier in the module, and
                    go run our scenario again, now watch what happens as I put in a value. I hit 5, and it immediately
                    StringFormats because we've got UpdateSourceTrigger=PropertyChanged. As soon as the Target property
                    changes, which happens on every keystroke, it's going to set the underlying source property. The
                    source property raises a PropertyChangedEvent, that forces the binding to re-bind and re-render
                    based on the StringFormat. The problem with this is, for a rapid input scenario, say that I wanted
                    to highlight this and say 55.55. If I do that quickly, 55.55, look what I end up with. It's because
                    after each keystroke it's re-rendering, it's putting the decimal place in there for me, so when I
                    get around and type the decimal place I'm actually adding another decimal place and I've got an
                    invalid StringFormat now that can't be converted to the underlying Type, and that's why we see the
                    red box, which we'll get into more in the validation section. As a result of that, you generally
                    don't want to use UpdateSourceTrigger=PropertyChanged in combination with StringFormat because
                    you'll get this re-rendering as you're typing, which especially with numeric formats, does not work
                    out the way you want, but with a normal focus change UpdateSourceTrigger, StringFormat works very
                    nicely for inputting those formatted values and rendering them appropriately.
                </p>
            </div>
            <div class="panel-body">
                <h3>MultiBinding/PriorityBinding</h3>
                <p>
                    One last topic I want to touch on in this module is the concept of MultiBindings and
                    PriorityBindings. A MultiBinding is a special kind of binding in WPF that allows you to provide a
                    collection of bindings inside the MultiBinding. It's basically going to evaluate each one of those
                    bindings and come up with a value, and then you combine this MultiBinding with a
                    MultiValueConverter, an object that you implement the _____ center face on, similar to the
                    converters we covered earlier in the module. But this MultiValueConverter is going to get passed an
                    array of values. The array is going to be populated with the values that came out of each one of the
                    child bindings in the MultiBinding and then the Converter can do with those values what it pleases.
                    So one example would be if you were going to create a _____ color picker and have a separate slider
                    for the red, the green, and the blue values, you could use a MultiBinding in combination with a
                    MultiValueConverter to come up with a color object based on those red, green, and blue inputs. So
                    basically, the net result of a MultiBinding is to come up with a single value based on the
                    individual values of the child bindings. The other kind of binding is called a PriorityBinding, and
                    it's somewhat similar in that it can contain a collection of child bindings, but what the
                    PriorityBinding is going to do is pick a value from one of those, and the priority is the first one
                    declared is the highest priority one, and the idea is that even though you have a binding in there,
                    it may not be able to come up with a value. It could be that it's using Async and it's waiting for
                    an Async result that hasn't come back yet, or it could be that it's pointing to a Path that may or
                    may not be there in the DataContext that varies over time. So the PriorityBinding is going to
                    produce a single value based on whichever highest priority binding has an available value. Now I'm
                    not even going to do a demo of these, because generally, in many years of doing WPF development,
                    I've never used either one of these. And the reason for that is I don't like the fact that they
                    really are putting logic in the XAML itself. They are a little difficult to debug as a result. If
                    you are not getting exactly what you want, there's nowhere you can set a breakpoint and see what's
                    going on. And it's also too much coupling in the view. Generally the alternative is to go produce a
                    single value behind the scenes and put it into a source object property and just use normal binding.
                    And then all the code that produces that value is debuggable and you can structure it however you
                    want, to use priorities or to go to multiple sources and figure out which one to use or to go to
                    multiple sources and combine the values of those multiple sources, but then you can just use a
                    normal binding and point to your source object that you populate however you want.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    So in this module we covered a bunch of fine-grain control points that you have when you apply
                    bindings by setting different properties on those bindings. First we covered the
                    UpdateSourceTrigger, which controls when data flows in a two-way data binding scenario from the
                    target to the source. Normally it's going to be on FocusChange, but if you set this to
                    PropertyChanged then you can get that immediate feedback, keystroke by keystroke, in a TextBox, for
                    example, to flow the data from the target to the source. And we'll see later in the Validation
                    module this can be important for immediate feedback to the user if they're inputting bad data. We
                    also talked about the difference between Default and LostFocus. Default and LostFocus generally mean
                    the same thing on most controls, but on a control like the DataGrid, Default means a row focus
                    changed and LostFocus means a cell focus changed. Next we talked about Converters. Converters are
                    these objects that you implement that implement the IValueConverter interface. You hook them in
                    through the Converter property of the binding and the data will flow through them both from source
                    to target and from target to source. And as part of that flowing process, you can transform the
                    value or the type of the object that's being passed through. Next we talked about Async bindings and
                    simply using the IsAsync property on a binding to make it so the get and set block of your source
                    object get called on a background thread if they might take a long time and you don't want to block
                    the UI. Next we talked about FallbackValues, specifically the FallbackValue property and the
                    TargetNullValue property that allow you to supply alternate values to be used when the source object
                    value can't be resolved. Next we talked about StringFormat and the way it will let you, basically,
                    "pretty print" or create a formatted string version of the value that you're getting from your
                    source object, so this works very nicely with dates and numeric formats, and so on. Finally, we
                    finished off with the concept surrounding MultiBindings and PriorityBindings. We described that
                    MultiBindings have a collection of child bindings, from which it can come up with a final value
                    based on the values that come out of the individual bindings. And a PriorityBinding, on the other
                    hand, allows you to have a collection of child bindings and have it pick the highest priority one of
                    those that comes up with a value for you.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Deep Dive into DataTemplates</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes, and in this module we're going to dive into Data Templates. Data Templates
                    are a very powerful mechanism of WPF data binding that allows you to provide the visual structure
                    for some data-bound object and have that mapped up at runtime as the objects get rendered out. So
                    we'll look at how DataTemplates work and what the variations on DataTemplates are and how to use
                    them. First we'll talk about the broad concepts of DataTemplates and how they work in general, and
                    how they get mapped out to the data objects that are being rendered out to provide the visual
                    structure for rendering on the screen. Next we'll talk about ExplicitDataTemplates, which are the
                    most direct and simple way to use DataTemplates. As the name implies, it involves a direct hookup
                    between the data-bound control and the template that should be used for a given collection or data
                    object. Next we'll talk about ImplicitDataTemplates, which are a little more magical in the way that
                    they work, but it involves an automatic selection of the appropriate DataTemplate based on the type
                    of the data object that's going to be rendered, and this gives us an awful lot of power for handling
                    heterogeneous collections of derive types of some data object type, and it becomes vitally important
                    in

                    Model-View-ViewModel

                    scenarios, which we'll use in the demos to render out different Views for different ViewModel types.
                    Next, we'll talk about DataTemplateSelectors, which give you a little more explicit control, but
                    still dynamic control to switch which DataTemplate you use based on whatever logic you need to
                    invoke to make that selection. And finally, we'll finish off this module with
                    HierarchicalDataTemplates, which are just a specialized form of DataTemplate that work in
                    hierarchical data model scenarios such as presenting data in TreeView control.
                </p>
            </div>
            <div class="panel-body">
                <h3>DataTemplates Overview</h3>
                <p>
                    The way DataTemplates work, in general, is that you are going to have some data-bound control, and
                    it's either going to be a ContentControl or some control derived from ItemsControl in general, such
                    as ListBox, ComboBox or DataGrid. Let's start with the ContentControl case. ContentControl, if
                    you're not familiar, has a single Content property that can be set to a UI element and it will
                    render that UI element in the child area, so the child area is really a blank canvas in which the
                    content can be rendered. In this case, though, we're supplying the content as a data-bound object.
                    It happens to be a ViewModel in this case, and this is where DataTemplates come in, is that a
                    DataTemplate can provide the visual structure for how to render that data object into that child
                    content area. So we then supply a DataTemplate, and the DataTemplate has some structure to it. In
                    this case we've just got a child user control as the structure of that DataTemplate as the nested
                    element. And when these come together in the data binding context, that DataTemplate provides the
                    visual structure for the data-bound object that is the content. Now a really important part of
                    DataTemplates to understand is that when a DataTemplate gets rendered, the DataContext property of
                    the root element in that DataTemplate, in this case, the HierarchalDataTemplates view, it's
                    DataContext will be set to the instance of the data- bound object that is being rendered. So in this
                    case, the CurrentViewModel object will be set as the DataContext for that
                    HierarchalDataTemplatesView. Now in the case of an ItemsControl, such as a ListBox, ComboBox or
                    DataGrid, first off you're going to be binding to a collection of data objects and the idea is you
                    want to have a visual representation for each one of those collection objects, so you provide a
                    DataTemplate and hook it in either implicitly or explicitly, as we'll cover in this module, and that
                    DataTemplate provides that visual structure for how do I render a single Product object in this
                    case. So here we have a grid with an image and a couple of rows in it to provide the name and
                    description for that product. So that DataTemplate basically lays down what is the visual structure
                    for that data object. Within the DataTemplate we have individual bindings and you can see that
                    they're just binding with simple paths to properties on a single Product object. This works because,
                    again, whenever a DataTemplate is rendered, the DataContext of the root element is set to the data
                    object it's being rendered for, in this case, a Product object. So that DataContext flows down the
                    visual tree of this DataTemplate, making that DataContext available to those child bindings. And
                    then in the case of an ItemsControl, this all comes together in that the ListBox, in this case, will
                    render out a single instance of that DataTemplate for each product object in the collection it's
                    bound to, setting the DataContext of that single instance to that product object. And that's
                    basically how DataTemplates work at a high level. So now let's look at the different ways to get
                    them hooked up and the different variants of DataTemplates.
                </p>
            </div>
            <div class="panel-body">
                <h3>Explicit DataTemplates</h3>
                <p>
                    So first let's look at ExplicitDataTemplates because they're the most straightforward in terms of
                    the way the DataTemplate gets hooked up to the data-bound control. First off, you're going to define
                    a DataTemplate somewhere, and usually that's going to be in a Resource dictionary, and again, you
                    define that DataTemplate with some visual structure for some data object that you want to render
                    out. You're going to give that DataTemplate a key if it lives in the Resource dictionary, so that
                    you can then refer to it by pointing to it with a StaticResource or DynamicResource markup extension
                    from the appropriate property of the data-bound control. The property we're talking about here is
                    either going to be the ContentTemplate property of a ContentControl or the ItemTemplate of an
                    ItemsControl, such as a ListBox. That tells that control to use that specific DataTemplate when it's
                    rendering out the data-bound objects that it's pointed to. Then at runtime it's going to be used to
                    render out those data-bound objects and provide the visual representation of those objects, and
                    again, the DataTemplate can contain bindings to the properties of that data-bound object. So let's
                    take a look at a demo of using ExplicitDataTemplates to render out some data.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Explicit DataTemplates</h3>
                <p>
                    In this demo, I want to show you how you can use ExplicitDataTemplates to provide the visual
                    structure for a data-bound object that's being rendered in a control. Our starting point for this
                    demo, and the rest of the demos in this module is this DataTemplates project, which is just a stock
                    WPF project with a couple things added at this point. We've got this Images subfolder that has some
                    product images that we'll use for rendering purposes, and we've got a RelayCommand, which we've seen
                    in previous modules for hooking up Command scenarios. We've also got our ZzaData data layer that
                    brings in data via Entity Framework from a Zza database. Now in this demo, I'm going to go ahead and
                    use the

                    Model-View-ViewModel

                    , or MVVM pattern, in a very simplistic form. You don't have to get too wrapped up in that, I'm
                    using it as just another example of data binding and also because in MVVM DataTemplates become
                    fairly important. So the first thing I'm going to do is add a View in ViewModel. The View will be
                    called ExplicitDataTemplatesView and it will be a User Control. And then I'll add a class called
                    ExplicitDataTemplatesViewModel. I'm going to replace this class with a fleshed-out definition and
                    just explain the code here quickly. Okay, so the fleshed out definition here is a class that
                    implements INotifyPropertyChanged, so that it can participate nicely in data binding. It exposes one
                    property called Products, which is an observable collection of products suitable for data binding,
                    again. And then it has a Constructor that only when you're not in the DesignTime environment, and
                    you can do that by checking this Designer properties GetIsInDesignMode property. If it's true, then
                    you're in the designer, if it's false you're not. So only if we're not in the Designer, do we go out
                    to the database and populate our products by going to the Products collection of our Zza DBContext.
                    And then we're looping over each product after we get it, and modifying the Image property to have
                    this relative path down into the Images folder that's part of our project. Now we need a View that's
                    going to data bind to this, and whenever you do the MVVM pattern, the ViewModel is going to be set
                    as the DataContext for the View. So the View elements can just bind to the exposed properties of
                    that ViewModel. So let's go into our View and add a local namespace so that we can get to the other
                    objects defined in our project, and then we're going to set the DataContext of this View
                    declaratively by setting the DataContext property to an instance of our new ViewModel. Now we can
                    add elements to this View that bind to the exposed properties of that ViewModel. So I'm going to add
                    a ListBox that's bound to our Products collection. So I'll drop down here in the Grid and add that
                    ListBox, and we can see we just set Binding to Products, and because there is a Products property
                    that exposes a collection on our ViewModel, we should be good to go here. Now to actually see this
                    View, we're going to have to put it into our MainWindow. So I'm going to drop over to my MainWindow,
                    build to make sure that Visual Studio knows about those, and open up my Toolbox. And up here at the
                    top you can see that our ExplicitDataTemplateView shows up. I can drag and drop that into the Grid
                    of the MainWindow. If I go ahead and run at this point, we can see that I do, in fact, get products
                    rendered out, but I'm just getting a ToString on the Product object, not very functional. So the
                    simplest thing we could do is drop here to our ListBox and add the DisplayMemberPath property
                    pointing to the Name property of each of the products. If we run with that we get a slightly more
                    functional ListBox where we see the product name, but it's not very pretty to look at. This is WPF
                    and we can put a little more visual flare on presenting a product, and that's where DataTemplates
                    come in. Now normally when you define DataTemplates, you're going to want to make them reusable.
                    That means you're going to put them into a Resource dictionary. So I'm going to go into the
                    UserControl.Resources here and declare myself a DataTemplate called ProductTemplate. A DataTemplate
                    is just an element that you can create inside of a Resource dictionary and it has some content to
                    it. The content of the DataTemplate is the visual structure that's going to be rendered out when
                    that DataTemplate is used. So we want some visual structure to render out a product here. I'm going
                    to drop into my DataTemplate and add some XAML, and we can see what I've added here is a root Grid
                    that has two columns. In the first column is an Image control that's going to render out our Image
                    property of an individual product. Then there's a nested Grid that has two rows. The first row is
                    going to show the name of the product and the second row is going to show the description of the
                    product. Notice that each of these bindings is assuming that the DataContext is going to be set to
                    an individual product, and that's an important part of how DataTemplates work. An instance of this
                    DataTemplate and its contents is going to be rendered out for each data-bound object in a bound
                    context. So in the case of a ListBox, we're going to have a collection of products. For each product
                    in that collection, it's going to render out an instance of the context of this DataTemplate. And as
                    part of that process, conceptually, it is setting the DataContext property to that Product object
                    that is being rendered. Now you don't explicitly put that there, that's going to happen
                    automatically for you when the DataTemplate is rendered, but the root elements DataContext is going
                    to be set to the data- bound object, and that means that DataContext will flow down and nested
                    bindings within that template can just use a Path property off of that DataContext object. Now that
                    we have our template defined, we need to tie it into our ListBox, so we're going to get rid of the
                    DisplayMemberPath and instead use a property called ItemTemplate. We're going to point to our
                    template through a StaticResource to the ProductTemplate. And with that in place, we can go ahead
                    and run, and now we see a much more visually-appealing presentation of our products in the ListBox.
                    And we can put whatever structure we want into this DataTemplate to render out the data that is
                    associated with whatever visual elements we want to present them. Now we could make some further
                    modifications to our DataTemplate. If I go to this nested grid and set a Height property, I can
                    actually use other forms of bindings that we've talked about with ElementName and RelativeSource
                    bindings, for example, to point to other elements within our DataTemplate. So, in this case, you can
                    see that we gave a name to our Image called ProductImage and we can use an ElementName binding to
                    point to that and modify the height of our Grid based on the height of that image, and really this
                    should say ActualHeight. Whenever you bind to a height or width, make sure you're binding to the
                    ActualHeight or ActualWidth. Likewise, I could add a couple more row definitions to this nested
                    grid, and then drop down and add a couple more TextBlocks. In this case, one of these is using a
                    RelativeSource binding and you can see it's going to walk all the way up using the AncestorType to
                    get to the ListBox that this is going to be rendered in. Even though this DataTemplate itself does
                    not explicitly know about the ListBox, this stuff all comes together at runtime into the visual
                    tree. So an ancestor of this TextBlock element will be somewhere up the chain, will be the ListBox
                    itself. So we can walk all the way up there, use the ListBox as our source object, and then we could
                    us a path that dots down to the ItemsSource , which will be our Products collection, and the Count
                    on that collection, and render that out in a TextBox. Likewise, we can even use ElementName bindings
                    that are outside of our CurrentDataTemplate. So the name of our ListBox is ProductsListBox. That's
                    out here in the main visual tree, but at runtime, this TextBlock will be rendered as part of the
                    overall UI so it's able to use an ElementName binding to locate another element within that same UI,
                    and in this case we're going to do the same thing, dot down through the ItemsSource to the Count.
                    With those in place, if I run right now, it's actually not going to render right because of this
                    ActualHeight. I wanted to show that as an example, but it'll end up truncating those fields that we
                    just added because the image won't be big enough. So I'm just going to take this Height off of here
                    and run. And now we can see the two 41's there, 41 products in our collection, getting 1 by walking
                    up the element tree to the ListBox, and getting the Products collection off of the ItemsSource
                    there, the other one using the ElementName binding to get to the ListBox and gets the Products
                    collection from there. Now one last thing to show is I'm going to cut this DataTemplate out of the
                    Resource dictionary, and show you that you can define it nested directly on the element itself. So
                    if I go onto my ListBox and set the ItemTemplate property as a nested element here, and I paste that
                    DataTemplate in there and get rid of the key because it's no longer in the Resource dictionary, now
                    the structure here is similar to what we did with our DataContext being set to an instance of a
                    ViewModel. Here we're really just setting the ItemTemplate property of the ListBox explicitly to an
                    instance of a DataTemplate. That works exactly the same. We can see the same visual rendering of our
                    elements. The difference here is this DataTemplate is no longer reusable, it's only available within
                    the context of this ListBox. So generally, I'll stick to defining my DataTemplate as part of a
                    Resource dictionary, giving it a key, and then referring to that from the ItemTemplate property with
                    a StaticResource. Then you could potentially move that DataTemplate out from the User Control to an
                    application-scoped resource or even in the reusable class library and use it over and over again in
                    multiple places in your applications. So that's how you use ExplicitDataTemplates. Specifically
                    point to one through the ItemTemplate property of a ListBox or we'll see another example is a
                    ContentTemplate property of a ContentControl.
                </p>
            </div>
            <div class="panel-body">
                <h3>Implicit DataTemplates</h3>
                <p>
                    Now let's talk about ImplicitDataTemplates. ImplicitDataTemplates give you a lot more power and
                    flexibility to address scenarios where you may not have a one-to-one mapping between a given
                    DataObject type and the control where a specific DataTemplate is supposed to be used for that object
                    type. Basically, an ImplicitDataTtemplate gets associated automatically with a data-bound object
                    based on the type of that object when it's being rendered. For ImplicitDataTemplates to work, the
                    DataTemplate has to be defined in the Resource dictionary that is in-scope wherever that data-bound
                    control is going to be. So down below you can see we have a ContentControl that's binding to a
                    CurrentViewModel and we placed the DataTemplate in a Resource dictionary that is somewhere upstream
                    of that. It could be a Resource dictionary directly on the ContentControl, on the containing Grid,
                    on the containing window or out at application scope, as long as it is at the same scope or a higher
                    scope, in terms of resources, from the control that's going to be data binding and looking for a
                    DataTemplate. Next we have to have a DataType property on our DataTemplate that matches up to the
                    concrete type of the data-bound object in that data binding context. So our content down below is
                    binding to a CurrentViewModel. that CurrentViewModel can be one of several types and, in this case,
                    it's checking the Type of that object and if it matches up to be an ExplicitDataTemplatesViewModel,
                    then this is the appropriate DataTemplate for it, and it will automatically select that and use it
                    to render it out. Note the use of the x:Type markup extension, make sure you use that. It's very
                    tempting to just put the Type name itself in quotes there, and then the DataTemplate won't work as
                    expected. And basically, ImplicitDataTemplates give you a lot of flexibility now, because the object
                    that shows up through a binding, such as this CurrentViewModel can dynamically change over time,
                    between different Types and then the DataTemplate can select the appropriate visual representation
                    based on that Type. So it could either be pushing a different ViewModel into this Content property
                    as shown in this example, or it could be something like a ListBox with a collection of different
                    types of objects in the collection based on some common base Type, such as Product, where each
                    derived type has its own specific DataTemplate mapped to it. So let's take a look at a demo of using
                    ImplicitDataTemplate to facilitate View switching in a ViewModel scenario.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Implicit DataTemplates</h3>
                <p>
                    In this demo, I'm going to show you how to use ImplicitDataTemplates to automatically associate a
                    DataTemplate with a data-bound object based on its type. Starting point for this demo is the ending
                    point from the last one where we showed ExplicitDataTemplates. Let's get started here. I'm going to
                    add a new View in ViewModel. I'm going to call the View DataTemplateSelectorsView because we're
                    going to use it in the subsequent demo for that purpose. And then I'll add a class that's called
                    DataTemplateSelectorsViewModel. In the view, I'm going to add a single element, which is a TextBlock
                    that just says DataTemplateSelectorsView so we know when that view is presented. Basically what
                    we're going to be setting up here is the ability to switch between child views, between our
                    ExplicitDataTemplateView and our DataTemplateSelectorsView, and do that using ImplicitDataTemplates.
                    So I'm going to go back to my ExplicitDataTemplateView and get rid of the explicit setting of the
                    DataContext here, because this is going to end up being done now automatically through
                    ImplicitDataTemplates. Now we're going to need some logic to switch between the
                    ExplicitDataTemplateView and the DataTemplateSelectorsView, and we're going to put that logic in a
                    ViewModel for the MainWindow. So I'm going to add a new ViewModel called MainWindowViewModel. And
                    we're going to first make this a proper ViewModel by implementing the INotifyPropertyChanged
                    interface, and then we're going to statically wire this up to our MainWindow by setting the
                    DataContext in the MainWindow, similar to what we saw in a previous demo. I'm going to get rid of
                    this explicit instance of our ExplicitDataTemplatesView, and what we're going to do is drop back
                    into our ViewModel and declare a property called CurrentViewModel. So the idea is that we can set an
                    instance of a ViewModel into this property and data bind to it from the MainWindow, and that will
                    cause the current rendered child view to switch out. So now we need some ViewModels to switch
                    between. I'm going to pop in here two more MemberVariables, one an instance of our
                    ExplicitDataTemplatesViewModel and one an instance of our DataTemplateSelectorsViewModel. Now we
                    need some logic that's actually going to switch between those two and we're going to do that with
                    Commands. So I've added two RelayCommands to my MainWindowViewModel, View1Command and View2Command,
                    that can be triggered from the MainWindow. You can see the handling is simply to set the
                    CurrentViewModel to the respective ViewModel. That will trigger a PropertyChanged and now we can set
                    up some data binding in the view to cause the right view to be rendered for that ViewModel using
                    ImplicitDataTemplates. So we're going to go up here to our MainWindow and replace our main Grid with
                    a grid that has two rows in it. The first row has a StackPanel with two Buttons. Each Button is
                    wired up to its respective Command, view1Command and View2Command, on the current DataContext ,
                    which is our MainWindowViewModel. Then in the second row we just have a ContentControl. The
                    ContentControl in WPF is a nice little container control that you set the content to some UI element
                    and that UI element will be rendered out in the child area of that control. Now you can set the
                    Content property explicitly to a UI element, or you can set the Content property to a data-bound
                    object and use DataTemplates to render out that object. So here you can see I'm setting the Content
                    property to our CurrentViewModel property back in our MainWindowViewModel. Now as we saw in previous
                    demos, if we did nothing else it would just do a ToString on whatever that ViewModel is and it
                    wouldn't look the way we want it, so what we want to do is supply a DataTemplate that's going to be
                    automatically married up with the appropriate ViewModel Type to render out a corresponding view for
                    that ViewModel. So what I can do is go up here in my Window and add a Resources section. And in that
                    Resource section I define two DataTemplates, one that is mapped through the DataType property to the
                    ExplicitDataTemplateViewModel Type. Notice the x:Type markup extension here, it's very easy to
                    forget this, and if so, your DataTemplates won't work correctly. But anytime you set the DataType
                    property, notice we don't have to set a key even though we're in a Resource dictionary, because the
                    key will implicitly be the DataType. But what's going to happen here is that anything that's
                    data-bound where this Resource is in scope, specifically our ContentControl that's binding content
                    to one or the other of those ViewModel Types. The data binding is actually going to look out into
                    all the Resources that are currently in scope, see if there is a DataTemplate mapped to the type of
                    the object that's currently being rendered, and if so, it will render out whatever the contents of
                    that DataTemplate are. The contents of this DataTemplate is nothing more than our User Control that
                    represents our view in the MVVM pattern. And remember that I said in a previous demo that whenever a
                    DataTemplate is rendered out, whatever the root element of that DataTemplate is will have its
                    DataContext set to the DataObject for which it's being rendered. So basically, the view's
                    DataContext will be set to the instance of the ViewModel that it's being rendered out for. So we
                    have one map to one ViewModel Type, one map to another ViewModel Type, and again, we're switching
                    which ViewModel is being set in the Command handling of our MainWindowViewModel. With that code in
                    place, I can go ahead and run, and now we can see the two buttons up at the top, I can click on the
                    DataTemplateSelectorsView, we switch to that one. I can click on the ExplicitDataTemplatesView and
                    we switch to that one. And again, the chain of events there are, we're clicking on the button that
                    fires the Command. The Command is wired up to set one or the other ViewModel as the CurrentViewModel
                    that triggers a PropertyChange on the CurrentViewModel, which is bound to the Content property. Now
                    that a new DataObject has shown up in the Content property through a binding, Control goes out and
                    looks in the available Resources, finds the corresponding DataTemplate mapped to that DataType, and
                    renders out the corresponding view for it, setting the DataContext of that root element of the
                    DataTemplate to whatever the DataObject is it's mapped to. And that's how you can use
                    ImplicitDataTemplates to render out views and ViewModels. ImplicitDataTemplates can also certainly
                    be used for heterogeneous collections. Say that you had a bunch of subtypes of product that you were
                    going to render out in a ListBox and you wanted to have a different DataTemplate for each subtype of
                    a product. You could use the DataType to map to those concrete types of the derived types, and then
                    you could have a ListBox bound to a collection of products. And then as it looped through, rendering
                    out each product, it would find the corresponding DataTemplate based on the DataType for the
                    concrete type of product that you're dealing with, and would render out that template.
                </p>
            </div>
            <div class="panel-body">
                <h3>DataTemplateSelectors</h3>
                <p>
                    Sometimes when you want to use DataTemplates, things may be a little more dynamic and you may need
                    to dynamically select the appropriate DataTemplate based on some criteria that goes beyond just the
                    type of the data-bound object. As we just covered, if the criteria is just simply based on the type
                    of the data-bound object, you could use ImplicitDataTemplates, but you might need to select based on
                    some property value on the data-bound object itself, or other logic within the application, and
                    that's where DataTemplateSelectors come in. DataTemplateSelectors at a high level let you
                    dynamically select the right DataTemplate based on whatever logic you need to derive that, and the
                    most common example would be to inspect some property value on the data-bound object and select the
                    appropriate template based on that. So what you do is you derive a class from a base class called
                    DataTemplateSelector in the framework. In that class, you override a SelectTemplate method so the
                    simplest possible implementation would look something like this. We derive our class from
                    DataTemplateSelector, we override the SelectTemplate method. That takes in two parameters. The first
                    one is going to be passed the data-bound object that you're supposed to come up with a DataTemplate
                    for. The second parameter is the element on which the binding is that this DataTemplateSelector is
                    being used from, and you can use either of those criteria and possibly other logic in your
                    application, such as who the user is, what time of day it is, and other criteria such as that, to
                    determine what template to return. Ultimately, you invoke some logic and you come up with a
                    DataTemplate. That logic could dynamically build that DataTemplate in memory, but most often you're
                    going to go out and locate it inside of a Resource dictionary so that those can be declared in the
                    DesignTime environment as XAML. So basically, you use whatever logic is needed and come up with a
                    DataTemplate and return it. And then finally, you need to hook it up, so you're going to set the
                    ItemTemplateSelector or ContentTemplateSelector property on your data-bound control depending on
                    whether it's an ItemsControl or a ContentControl. So let's take a look at a demo of using
                    DataTemplateSelectors to dynamically select the appropriate DataTemplate.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: DataTemplateSelectors</h3>
                <p>
                    In this demo, I'm going to show you how to use DataTemplateSelectors to dynamically select an
                    appropriate DataTemplate based on some property of the data-bound objects. To do this, I'm first
                    going to need to define a DataTemplateSelector, which is nothing more than a class. So I'm going to
                    add a class here called ProductTemplateSelector. I'm going to flesh it out here by inheriting from
                    the DataTemplateSelector class and overriding the SelectTemplate method on that base class, which
                    you can see returns a DataTemplate. It takes in two arguments, the first of which is the data-bound
                    object that's being rendered through a binding. The second is the element on which the binding is
                    attached to. From there, your logic can figure out however it needs to, how to come up with a
                    DataTemplate. Now the implementation I'm showing here is a simple reusable version where I know that
                    I'm going to be using this for Products, so I can go ahead and cast the data-bound object to a
                    Product object. Likewise, I can cast the container to a framework element. As long as both of those
                    casts succeeded, this TemplateSelector must be hooked up in the place I expect it to be. If not, I
                    can just punt here and return null. But as long as I got that far, then I can go and invoke some
                    logic to figure out what DataTemplate to use based on the product that I'm seeing. Now the simple
                    logic I have wired up here is that a product has a Type property on it and that Type is going to be
                    pizza, salad or drink in our Zza data examples. If I just concatenate Template onto the end of that
                    and assume that out in the current Resource dictionary for the element that this binding is on,
                    there is a DataTemplate named that template, then I can locate it with a FindResource and just
                    return that. Now obviously, you could have whatever convoluted logic you want here, you could new up
                    a DataTemplate from scratch and dynamically populate its elements from programmatic code. Generally
                    you're going to want to declare these in XAML and locate them as a Resource, as I'm doing here,
                    through some kind of naming convention. Now we need to go ahead and hook this up to our data-bound
                    context. So what I'm going to do is go out to a View I created in a previous demo called
                    DataTemplateSelectorsView, and I'm going to add in a Resources section that creates an instance of
                    my ProductTemplateSelector, and I'll need a local namespace up above. Now that I have an instance of
                    that Selector available, I can use it in the data-bound Context. So I'm going to replace my TextBox
                    down here with a ListBox. We'll bind the ItemsSource of that ListBox to Products and we'll set a
                    property called ItemTemplateSelector, pointing through a StaticResource to the instance of our
                    ProductTemplateSelector. Now we just need to get these products from somewhere, so I'm going to wire
                    that up in the ViewModel for this View. So if I go to the DataTemplateSelectorsViewModel and replace
                    that class with something similar to what we've seen before, we have a Products collection exposed.
                    We only populate that Products collection from the database if we're not in Design mode and it
                    raises PropertyChanged events when it gets set. So now how is that ViewModel getting hooked up to
                    our view? Well, if you remember from the ImplicitDataTemplates demo, it's being automatically
                    associated through the DataTemplates out in the MainWindow. So remember we had this
                    DataTemplateSelectorViewModel ImplicitDataTemplate rendering out the DataTemplateSelectorsView,
                    which will set its DataContext to the instance of the ViewModel. So the only thing we have left to
                    do is define the DataTemplates that are going to be rendered out by our ProductTemplateSelector. So
                    if we add into our Resources section here, three DataTemplates, one called pizzaTemplate, one called
                    saladTemplate, and one called drinkTemplate, the Type property on the product is going to be salad,
                    drink or pizza, and we concatenate that template name onto it inside of our ProductTemplateSelector.
                    Each of these is just going to render out a simple representation of a pizza, salad or drink. So by
                    setting that ItemTemplateSelector, it will invoke our DataTemplateSelector, and we can run, go to
                    the DataTemplateSelectorsView, and there you can see the pizzas look like that, the salads look like
                    that, and the drinks look like that. So by defining your own DataTemplateSelector, overriding the
                    SelectTemplate, and invoking whatever logic is needed inside your DataTemplateSelector, you can
                    dynamically return whatever DataTemplate is needed for your scenario.
                </p>
            </div>
            <div class="panel-body">
                <h3>HierarchicalDataTemplates</h3>
                <p>
                    The last kind of DataTemplate we'll look at here is called a HierarchicalDataTemplate, and it's
                    specifically designed to address hierarchical data models presented in a TreeView control in WPF,
                    but it can also be used with some third party controls that present hierarchical data as well. The
                    general idea is that similar to a DataTemplate, it contains a chunk of XAML that represents the
                    visual structure of a data object that's going to be rendered as a node within the tree, but it has
                    a number of additional properties to it to capture the fact that there are child collections and
                    child hierarchies that also need to be rendered. The first of those is the ItemsSource property on
                    the HierarchicalDataTemplate. Basically, this points to a property on the current node object that
                    should be a child collection of objects, and it indicates to the TreeView control that there are
                    more child items to be rendered there. Then there is the ItemTemplate property on the
                    HierarchicalDataTemplate. This provides a DataTemplate for how do you render those child objects in
                    that child collection. If you have fairly static structure to the object model, this is all you'll
                    need. If you have a more dynamic scenario, there is an ItemTemplateSelector property so you can use
                    a DataTemplateSelector, as we covered earlier in the module, to dynamically determine which
                    DataTemplate to use given the type or property values on the data-bound child objects. You can also
                    use ImplicitDataTemplates with HierarchicalDataTemplates, so it has a DataType property just like a
                    normal DataTemplate does, that you can set to a Type and it can automatically map up based on the
                    concrete type of the node that's being rendered which DataTemplate to use. So let's take a look at a
                    demo of using HierarchicalDataTemplates.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: HierarchicalDataTemplates</h3>
                <p>
                    In this demo, I'm going to show you how to work with HierarchicalDataTemplates, which are a special
                    kind of DataTemplate that work with TreeView controls, as well as with other hierarchical data-bound
                    third party vendor components. The starting point here is where we left off in the last demo where
                    we had our ImplicitDataTemplates allowing us to switch between multiple views, the
                    ExplicitDataTemplatesViewModel and the DataTemplateSelectorsViewModel. I've added one more view here
                    that we're going to start fleshing out in this demo called HierarchicalDataTemplateView and
                    ViewModel. And to get those switching, the way we did the other views, I added another ViewModel
                    instance to the MainWindowViewModel, another Command to trigger switching to that view, and the
                    Command handler that sets that as the CurrentViewModel on the MainWindowViewModel. So that should
                    all look familiar from the ImplicitDataTemplates demo. So if I run at this point, I can start up the
                    app. We'll have three buttons now at the top of the screen, and I can switch between the
                    DataTemplateSelectorsView, the ExplicitDataTemplatesView, and this new blank
                    HierarchicalDataTemplatesView and its corresponding ViewModel. So the first thing we're going to
                    want is some real data to work with, in our ViewModel, so I fleshed out some code here. You can see
                    that our ViewModel implements INotifyPropertyChanged, as usual. We have a constructor that is, only
                    when we're not in the Designer, going out to the database through our DBContext and retrieving the
                    Customers collection from our DBContext. In this case, however, it's also using the .Include method
                    of Entity Framework to retrieve the related Orders, OrderItems, and the Product for each OrderItem,
                    which sets up a hierarchical data object graph for us to work with in this demo. The exposed
                    property from our ViewModel is just the root Customers collection and we're going to data bind to
                    that in a TreeView control. So now let's go over to the view for this HierarchicalDataTemplate and
                    let's add a little bit of XAML. What I added here in terms of the root structure of the View is a
                    TreeView control. You can see that the ItemsSource is pointing to our Customers collection, which
                    will be on our DataContext that is our ViewModel. Then we use the ItemTemplate as we did before with
                    the ExplicitDataTemplates demo, to point to a Resource that has a DataTemplate. That DataTemplate is
                    up here, named CustomerTemplate, and it's just got some simple structure, which is a StackPanel with
                    an Image and a TextBlock in it. If we run our demo at this point, and we switch to the
                    HierarchicalDataTemplatesView, you can see that we are getting data rendered out based on our
                    DataTemplate, but notice there's no expander nodes next to these Customer objects, it's really more
                    like a ListBox at this point, and we're not really getting that hierarchical presentation that we
                    want. This is where HierarchicalDataTemplates come in. So I'm going to change out this normal
                    DataTemplate for a HierarchicalDataTemplate for Customers that goes one level deeper to the Orders.
                    So now you can see what we have is a HierarchicalDataTemplate. It still has the same key as before,
                    so that the ItemTemplate can point to it. It's got the same root level structure of a StackPanel
                    with an Image and a TextBlock next to it, but then it's got two additional things. The first is the
                    ItemsSource property. The ItemsSource property on a HierarchicalDataTemplate points to some property
                    hanging off of the current node object, which will be a customer, in this case, that is a collection
                    itself, a child collection. So in this case, the child collection of orders for a given customer
                    will be on an Orders property of the Customer object. That sets up the notion that there's more to
                    render at a child level, and then the ItemTemplate property of the HierarchicalDataTemplate allows
                    us to supply what is the DataTemplate that is going to be used to render that. And here, one level
                    down, we can see we can just use a normal DataTemplate at that level and we have some simple
                    structure there with another StackPanel with an Image and a TextBlock, in this case, binding against
                    the OrderDate using a StringFormat for a short Date string and we'll have the Image pointing to some
                    stock image there. With that in place, if we run, we'll get one level of expansion based on that
                    Orders collection, on each customer. So we go to the HierarchicalDataTemplatesView, you can see we
                    have the Expander icon here, and when we expand, we see the orders for Puckett and the orders for
                    Russell, and so on. Now we can take this even deeper and I can replace this HierarchicalDataTemplate
                    with an even bigger one that goes one level deeper. So we still have the root
                    HierarchicalDataTemplate that our ItemTemplate is pointing to. It's got the binding to the Orders
                    collection on each customer and the structure for each customer. Then it's got the ItemTemplate for
                    each Order in that Orders collection, which again, has its root structure that's a StackPanel, but
                    then it has its own ItemsSource that says each order has an OrderItems property. For each OrderItem,
                    what is the template for that? We go another level down and specify the ItemTemplate for that child
                    HierarchicalDataTemplate and give it some structure. And in this case, if this is our leaf node, we
                    can just use a standard DataTemplate. So if we run this, go to the HierarchicalDataTemplatesView,
                    expand down to Orders, and expand down to OrderItems, then we can see we have different icons and
                    different levels for those. Now the problem with what we've shown so far is, this works if there's a
                    single child collection per level of the hierarchy that you want to drill down into, but what if
                    there's multiple child collections and what if they are composed of heterogeneous derived types from
                    some base type, such as Product as a base type and then specific product-derived types that have
                    their own DataTemplates? Well, the good news is, you can mix HierarchicalDataTemplates with the
                    concept of ImplicitDataTemplates. So I'm going to replace all of these HierarchicalDataTemplate with
                    a series of three DataTemplates in our Resource collection. Notice these are ImplicitDataTemplates
                    using the DataType property to say, if a given data-bound node happens to be a Customer object, then
                    we render it out with this content as our DataTemplate and we can have an ItemSource for that. Now
                    we don't have to specify the ItemTemplate here for those orders, because that can be matched up with
                    a separate ImplicitDataTemplate, so here we have another ImplicitDataTemplate that maps to Order
                    objects and it knows how to render out those nodes and what child collection it can bind against on
                    those nodes. And then finally, down at the leaf node level, for OrderItem, it's got the structure
                    for those. So then we just get rid of the ItemTemplate down here and go ahead and run, switch to the
                    HierarchicalDataTemplatesView, and now you can see the rendering is simpler. I don't have images
                    involved in the templates now, but you can see we've got the name of the customer, the Order Date
                    for the order, and the Product name for the OrderItems. So it's able to match up the right
                    DataTemplate for the right node in the Tree based on the type of the data object being rendered. And
                    again, this would allow us to have multiple derived types in a heterogeneous collection in those
                    child collections, and each one could render out its respective DataTemplate, similar to what we saw
                    with rendering different Views for different ViewModel Types.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    In this module, we saw how you could use DataTemplates to start to put together a much more complex
                    visual structure for the way you render out individual data-bound objects. We saw that at a high
                    level, DataTemplates supply that visual structure for the way you're going to render out a given
                    data-bound object in a data binding scenario. And we talked about the fact that the main place this
                    is going to apply is in ContentControls or ItemsControls, which certainly could be nested down
                    inside of something like a cell of a DataGrid. First we dove into ExplicitDataTemplates where you
                    saw you define a DataTemplate, you give it a name, and you explicitly hook it up to the data-bound
                    control through the ItemTemplate property or the ContentTemplate property. Next, we looked at
                    ImplicitDataTemplates, which can auto-associate an appropriate DataTemplate based on the data-bound
                    object type, using the DataType property of the DataTemplate and the x:Type markup extension to
                    point to the data object type. Then we covered DataTemplateSelectors, which give you a chunk of
                    logic that you can write to dynamically determine which DataTemplate to use for a given data-bound
                    object, and that logic can be based on whatever criteria you want. It could be based on property
                    values on the data-bound object, or other contextual information about the execution environment,
                    such as who the user is or what day it is. Finally, we finished off with HierarchicalDataTemplates,
                    which apply the same capabilities to define the visual structure, but now we're talking about nodes
                    in a hierarchical tree based on a hierarchical data model. We saw that HierarchicalDataTemplates let
                    you specify what the child collections are at a given level in the hierarchy, as well as what
                    DataTemplate to use for the objects in that level.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Design Time Data Binding</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes. In this module, we're going to look into some of the Design Time Data
                    features that Visual Studio has to help you get your UI's hooked up, data-bound, and even generate
                    UI elements based on your data model. We'll also look at how you can use sample data in the
                    Design-Time environment to help get your UI laid out and to have that data to visualize what it's
                    going to look like in the UI as you're designing it. First, we're going to look at two windows
                    within the Visual Studio environment, the Data Sources Window and the Properties Window. Data
                    Sources Window lets you generate data-bound UI elements based on your data model or hook up existing
                    elements, and the Properties Window lets you hook up bindings to individual properties for the
                    elements you're working with in the designer. Next, we're going to look at working with
                    DataTemplates in the designer. Visual Studio carries over some features from Blend where you can
                    actually design DataTemplates in the designer as a stand-alone resource, and then switch back into
                    the main design mode of the designer when you're done. Finally, we'll look at how you can use the
                    overall feature that's referred to as Design Time Data, which is mainly a set of properties and
                    markup extensions that you can use within your XAML that makes certain things available to the
                    designer, but they go away at runtime. And this includes being able to pull in some sample data that
                    will populate your UI in the designer, but not be there at runtime.
                </p>
            </div>
            <div class="panel-body">
                <h3>Data Sources and Properties Windows</h3>
                <p>
                    One window that's been in Visual Studio for a long time and actually dates back to the Windows Forms
                    2.0 days, is the Data Sources Window, but it carries over and works wonderfully with WPF and other
                    XAML technologies as well. Basically, this Data Sources Window lets you point to different object
                    types and it will provide the information about those object types so you can use it to hook up data
                    binding. You can drag-and-drop those entities or the individual properties of an entity onto the
                    XAML Designer. And what will happen is, if you drop in an open area on the Designer, it's going to
                    generate new UI elements and hook up the appropriate properties on those elements with bindings
                    based on what you dragged and dropped. In addition, it's going to generate a CollectionViewSource in
                    the Resource section for the entity type that was dropped and hook that up as the data source for
                    the new bound UI elements that were generated. At design time, this gives the designer enough
                    information to be able to generate the right controls and hook up the bindings to the properties,
                    but at runtime you'll just need to write the code that will populate those CollectionViewSources so
                    that at runtime they have real data. In addition to generating brand-new UI elements by dragging and
                    dropping, you can drag-and-drop from properties or entities within the Data Sources Window onto
                    existing controls, and that will just hook up bindings to appropriate properties on those controls.
                    The icons in this window represent the kind of control that's going to be generated. And you can see
                    drop-down arrows next to the selected item, the Product, in this case, that allows you to change
                    what those mappings are, so you can change what control is going to be generated when you do your
                    drag-and-drop directly through the UI, and you can also go into an Options dialog and you can change
                    what set of controls are available when you do the drop-down for a given property type. In addition
                    to the Data Sources Window, there is the Properties Window, which anyone who's done any UI design in
                    Visual Studio over the years is certainly familiar with. What you may not be familiar with are the
                    data binding features that are within the Properties Window. So first off, next to each property
                    there's a little tiny square there, that's kind of subtle what it is, but if you click on that,
                    it'll bring up a context menu and in that context menu there's an option to create a data binding.
                    If you click on that, you get a dialog that lets you basically set everything you need to set at a
                    property level for data binding. So if you take the aggregate of all the fine-grained properties
                    that we covered in various modules earlier in the course, things like, what are the different kinds
                    of data sources a binding can have, DataContext , Source, RelativeSource, ElementName, and so on,
                    then based on which of those you pick, on the right you can set the Path to a property on the source
                    object. Down at the bottom you can see you can set up a Converter and the More settings will expand
                    and give you access to all those other fine-grained properties, such as UpdateSourceTrigger,
                    IsAsync, Mode, and so on. So let's dive into a series of demos that shows us the full power of the
                    Data Sources Window and the Properties Window in the designer.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Generating DataGrids with Data Sources</h3>
                <p>
                    In this demo, I want to get you familiar with some of the Design Time Data capabilities in Visual
                    Studio 2012 and 2013. We're going to go ahead and start with a fresh new project. We'll make it a
                    WPF project called DesignTimeData. I'm going to add into the solution my data layer that I've been
                    using in other demos, so I'll add an existing project and I'll go find my ZzaData project. I need to
                    update my NuGet packages to make sure both projects use Entity Framework. So now I've added Entity
                    Framework to both projects. I need a connectionString in my App.config that's pointing to my Zza
                    database. The other thing I did here is add a reference from the DesignTimeData project to the
                    ZaaData project so we can use it as our data layer. So the way you're going to get started with the
                    Design-Time features is to use the Data Sources Window. You can get to it through View, Other
                    Windows, Data Sources. You can see this is going to start up blank and you can click on Add New Data
                    Source. There's four choices here, but only one of them, Object, is the main one you're going to
                    use. Database is going to put SQL statements and connections and things, directly into your Views,
                    which is a bad idea from a Separation of Concerns perspective. Service is doing nothing more than
                    shortcutting to the Add Service Reference dialog to hook up to a WCF Service, generate a proxy and
                    data contracts, so that you can start calling that service. You can do that outside of this dialog.
                    SharePoint, I'm not going to get into here, but Object is the one I want to focus on. So if I click
                    Next, what I'm going to be presented are all the namespaces in my solution, and I can drill down and
                    find the data objects that I want to work with. So I'm going to select Customer here as the object I
                    want to work with. I click Finish, and Visual Studio is basically going to reflect on that assembly
                    and that type, and generate some information here in the Data Sources Window that we can then use to
                    start generating data-bound UI through drag-and-drop operations. You can see that it starts off with
                    a customer and presents all the properties defined on that customer. By default, if I drag this out
                    onto my UI here into the main window, it's going to generate a DataGrid with columns for each of the
                    properties mapped to specific column types. Now if we go look at the XAML that was generated, we can
                    see it generated a DataGrid, it set up a binding that just says, ItemsSource ="(Binding)", so it's
                    expecting a collection of customers to come down into this from somewhere, I'll show that in a
                    moment, and then it defines explicit columns for each of the properties that it found on that data
                    object, with each of those columns bound to the appropriate property on the customer object. It also
                    generated up above, notice the Window.Resources created a CollectionViewSource, which we covered a
                    little bit before and we'll cover more in a later module, but it's an ICollectionView object that
                    wraps some data collection. By default, it uses some DesignTimeData attributes that we'll be talking
                    more about later in this module. But you can see, basically, it's specifying that the Collection
                    Type is the Customer Type, and it indicates that it is a list of objects, and then it sets the
                    DataContext on the root Grid element to point to that CollectionViewSource. So it basically wires
                    everything up so that the designer knows about the type of the object it's binding to, it can use
                    the Type information from that object to generate the bindings for the columns, and it sets up the
                    bindings so that if you populate this CollectionViewSource at runtime with a collection of
                    Customers, the binding is going to kick in and you'll see that data. Now it also wired up the loaded
                    event of the window and if we go into the code-behind we can see that it's stubbed out some lines of
                    code here where it gets a reference to the customerViewSource through a FindResource call, and then
                    it just has some commented-out code here that says, if you set the Source property of that
                    CollectionViewSource to a collection, then things are going to be ready to go. So I could drop in
                    here and replace this commented-out line of code with a call through our ZzaDBContext to go get the
                    Customers as a list and push those into the Source property. And with just that much effort, I can
                    go and start and we can see our data being rendered out in a Grid. Obviously, we have some layout to
                    do here, the columns are probably not in the order that you want by default. You can go and start
                    moving those around in the editor, and in the case of a DataGrid, moving those around is nothing
                    more than grabbing a column and sliding it up and down within the environment. So those are the
                    basics of generating a DataGrid through the Data Sources Window based on some data-bound object
                    type.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Generating Input Forms</h3>
                <p>
                    Now in this demo I want to show you how you can go a little further with the Data Sources Window.
                    I'm going to slide the DataGrid that we did in the last demo up to the top so I have some room at
                    the bottom here, and I'm going to expand my overall UI a little bit. I'm going to go back to the
                    Data Sources Window. Now when I did the drag-and-drop before, we got a DataGrid because of this
                    selection. It's the default selection that when you do a drag-and-drop of a given entity type, it's
                    going to generate a DataGrid for that. You can see there's other options here including List that's
                    going to generate a ListViewControl, which is mostly obsolete at this point by the DataGrid, and
                    then the one I really want to show here is the Details View. If I select Details View, the other
                    thing I can do is you can see you have drop-down boxes at the individual property level, and this is
                    where it figures out what kind of column within the DataGrid or what kind of field when you're doing
                    details it's going to generate. So I can leave most of these to TextBox, but I can also exclude
                    certain ones by saying (None). So I'll exclude a few of these and say that we just want the Id,
                    FirstName, LastName, Email, and Phone properties to be generated as the DataForm or DetailsView. Now
                    if I do my drag-and-drop, you can see that what it generates is a Grid or a little data form. Now
                    the ordering of the properties may not be what you want again. It's going to go in alphabetical
                    order, by default, but we can move those around later. If we go look at what it generated, first
                    off, at the top, notice there's no additional CollectionViewSource. It saw that we did a
                    drag-and-drop of the same exact entity type and so it just can reuse that same CollectionViewSource.
                    If we dropped a different entity type, then a new CollectionViewSource would have shown up here.
                    Down below our DataGrid, it added the root grid that's containing all those labels and TextBoxes,
                    and it sets up the appropriate column and row definitions to get that nice rectangular layout. Then
                    it basically generates a Label based on the property, and an input field based on the property. And
                    you saw from those drop-downs where the given input field type was coming from. On the appropriate
                    property for that input field, such as Text on a TextBox, it's going to set up a binding. The
                    binding is going to have the Path to the property on the data-bound object. It's always going to
                    declare the Mode TwoWay for input controls, even though in WPF, most of these are TwoWay by default.
                    It does that so it can have the same DesignTime experience for Silverlight and Windows 8
                    applications where there is no default of TwoWay for editable controls. It also puts a couple of
                    additional properties that have to do with validation on here. We'll get to those in a later module.
                    So you can see it just sets up a Label and input for each of the properties that you had selected
                    that you wanted to generate input for, and puts them all in a parent grid, nicely laid out. Now if
                    you wanted to start reordering these, maybe you wanted Id, then FirstName, then LastName, you could
                    just drop in here and start tweaking the row numbers of the individual controls, and then you'd
                    probably want to move the XAML around, as well, so that it's in a linear layout in the XAML that
                    matches the way it's laid out in the screen, but ultimately it's the Row numbers that derive which
                    grid cell it shows up in. So that shows how you can use the Details view of the Data Sources Window
                    to drag-and-drop and generate a data form. Additionally, you can drag out individual properties, so
                    I could drag out LastName here, for example, and we can see it generates a single grid with two
                    columns to it, one for the Label and one for the input, and you could drag these out as individual
                    grids on a per-property basis if you have some more exotic layout that you need.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Using the Properties Window</h3>
                <p>
                    Now another Design-Time capability that you can leverage in Visual Studio is the Properties Window.
                    If I just drag an unbound control out here, such as the TextBox here, and I want to start data
                    binding this, I can go to the Properties Window, select the property that I want to data bind, and
                    go to this little square over to the right of the input here. If I click on that, you can see a
                    Context menu comes up that includes Create Data Binding. If I click on that, I get a dialog here
                    that lets me start to specify how I want to hook up the data binding. At the top, you can see, is a
                    drop-down that lets you pick what kind of source to use. DataContext is the default, and if there is
                    a Design-Time DataContext available, such as the one shown here, you can see that it knows about
                    this Customer List and this is because of the Grid that this TextBox sits within has a DataContext
                    set using DesignTimeData, which we'll get more into later in the module. So I could just pick the
                    property over on the right here and that's setting the Path property of the binding that's going to
                    result from this. I could also do ElementName bindings, RelativeSource bindings, and StaticResource
                    or Source bindings, by selecting those here. And when I do, then the inputs change to let met pick
                    from what's out there that I can select as the ElementName and what property on that element to use
                    to set the Path. We'll just use DataContext here, say FirstName as our property. Down at the bottom
                    you can see if there are Converters out there, you can either add one dynamically here and it'll let
                    you go create the class and create it as a Resource or if there's ones already in the Resource
                    Dictionary it'll show them here. And then the More settings expands and shows all those other
                    properties we covered in a previous module for things like StringFormat, the Mode property, the
                    UpdateSourceTrigger, FallbackValues, TargetNullValues, and so on. A bunch of these properties on the
                    right have to do with validation, which we'll cover in a later module. So once we click OK there, if
                    we go and inspect the XAML, we can see here is our TextBox, and all it was really doing there is
                    creating a binding. And you can see sometimes it does a little bit strange bindings. Really all we
                    needed was FirstName here, but it adds /FirstName. So ultimately, once you get comfortable with
                    bindings, I generally find it's just as productive to type the code in the XAML Editor as to use the
                    Properties Window, but that may be a more expeditious path for you when you're getting familiar with
                    the syntax.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Customizing Data Sources Control Mappings</h3>
                <p>
                    Another thing you can do with the Data Sources Window, is customize what the set of controls are
                    that it's capable of generating when you do your drag-and-drop operations. If you drop-down this
                    list, I already covered the fact that the defaults here include DataGrid, List, and Details. The
                    reason for that is, it assumes when you add an entity type or an object here, that you're talking
                    about a collection of those. If we go to Customize here, you can see the dialog comes up that allows
                    us to change the mapping there, and you can see the checkboxes there for DataGrid and List and
                    Details is just kind of a built-in one that generates a form as we talked about before, but the
                    important thing is at the top you can see it's mapped to a DataType of (List), a conceptual
                    collection of a given entity type. If you drop that down and go to something like String, then what
                    this is showing is if you're dealing with an individual property of an entity that's of type String,
                    this is the collection of controls it's going to show as options when you go to customize what it's
                    going to generate on drag/drop. You can see at the bottom there's a link you can even add custom
                    controls of your own and third party component libraries will show up in this list as well. And you
                    can just check additional things. So, for example, if I wanted to go back to the List and say I want
                    to be able to generate a ComboBox when I drag-and-drop an entity type that represents a list. I can
                    click OK there and then now I could drop this down, select ComboBox, drag-and-drop, and you can see
                    the sizing is kind of funky, but it generated a ComboBox, and if we go look at the XAML, what it
                    created for me was a ComboBox with the ItemsSource bound to the current DataContext , because it saw
                    that that ComboBox was dropped inside of a Grid that already had a customerViewSource hooked up, so
                    it could data bind to that. Now notice a couple other things about dropping a ComboBox like this.
                    One is that it hooks up two other properties relative to data binding that are important, the
                    DisplayMemberPath property indicates what property on the individual objects in the collection your
                    binding to should be used to render text in the ComboBox. And the SelectedValuePath is going to be
                    used to point to another property on that same object that can be used to track a value, typically a
                    primary key type of value. You can see by default here, it set both of those to the same property.
                    And if we look at our Data Sources Window and expand the Customer, we can see it picked City, even
                    though that was marked None, and that's because it's the first string property that it found on the
                    Customer alphabetically. So as I talked about when dragging and dropping and generating a form, it's
                    always going to generate things based on the alphabetical order of the properties on the object, so
                    you may have to do some tweaking of the XAML afterwards. And the DisplayMemberPath and
                    SelectedValuePath it's rarely going to get correct, so you're always going to want to take a look at
                    those and adjust the values to the appropriate property for your scenario. The other thing it did
                    here is on a ComboBox it always adds this ItemsPanel customization, setting it to a virtualizing
                    StackPanel. There are various reasons the Design Team chose to do that, but in general, you can kill
                    that out of there. A virtualizing StackPanel is only needed when you have a very large number of
                    items that you're going to present in a data-bound control. If you are putting hundreds or thousands
                    of items in a ComboBox, you are just torturing your users, so please don't do that, for user
                    experience sake, and if you don't do that, then you don't need the virtualizing StackPanel. So
                    notice that you can also customize at the individual property level and this is where those other
                    type mappings such as string come in. The set of controls presented here are based on whatever that
                    property type is in this dialog.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Hook Up Existing Controls</h3>
                <p>
                    So far, the examples I've shown of using the Data Sources Window have been for generating the UI, as
                    well as the bindings on the UI properties of that control. Data Sources Window is also capable of
                    just hooking up the binding on an existing control. So, for example, if I go to the Toolbox and go
                    grab a TextBox and put it out here on the UI, I could then decide what I want to put in that
                    TextBox. In this case, I'm going to add another Data Source, so I'm going to grab the Object Data
                    Source, I'm going to go to my ZzaData, and we'll pick Product this time and click Finish. You can
                    see the icon here, that it's mapped to the DataGrid by default, and you can see our customizations
                    from a previous demo there, that ComboBox also shows up now. What I could do is expand and say that
                    maybe it's the name of the property that I want to put into this TextBox. So I can drag-and-drop
                    that onto the existing TextBox, and you can see that the icon changes to a shortcut arrow. If I
                    release, basically it made no modifications to the control in terms of its layout or position, all
                    it did is added a binding for the default property for that control type, so the Text property for a
                    TextBox, and it bounded to the property on the data-bound object we dragged onto it, so Name in this
                    case. It also added a couple other things. As I talked about in a previous demo, it's always going
                    to put Mode TwoWay on there for an input control. It puts these validation properties on here that
                    we'll get to in a later module, and then in this case, because we dragged and dropped a new entity
                    type that didn't already have a Data Source, you can see it hooked it up using a Source binding,
                    pointing to some Resource. If we go back up to the top of our UI now, we can see it added a new
                    CollectionViewSource with a DesignInstance Type of Data:Product. So, similar to what I had covered
                    before for creating this Customer Source that it reused for all the different drag-and-drops of
                    customers, it's going to create one CollectionViewSource for a given entity type and then all the
                    subsequent drag-and-drops will use that single CollectionViewSource if they're using that same
                    entity type. You can certainly break that up on your own and change things around, use MVVM to point
                    to properties on a ViewModel or create different instances of CollectionViewSources, possibly for
                    the same entity type that you populate with different sets of collections. But the Designer is just
                    trying to map it to a Type, so it sets up a single CollectionViewSource per Type. We could also do
                    something similar for a collection-oriented control. I can drag-and-drop a ListBox out here. We
                    won't worry too much about the presentation there. If I then go back to my Data Sources Window and
                    drag-and-drop an entity type onto that ListBox and go look at the XAML and what it did there, we can
                    see the ListBox was preexisting in this case, so all it hooked up for us were the data binding
                    properties again. So it sets up the ItemSource, again, pointing to that ProductViewSource that was
                    already up in the Resource section and it sets the DisplayMemberPath and SelectedValuePath to the
                    first string property that it finds on that entity type, which in this case was Description. Again,
                    you're generally going to have to tweak those to what you intend them to be, probably Name or the
                    DisplayMemberPath on a Product, and Id for the ProductId. So that's how you can use drag-and-drop
                    operations to hook up data bindings to existing controls. In the end, as you can see, it's not
                    really writing that much code for you. As an experienced XAML developer, I find it easier to just
                    drop into the XAML and write the bindings myself, especially because in Visual Studio 2012 they
                    added IntelliSense for bindings. You can see here I get IntelliSense down to the properties of a
                    binding where I can set the Path equal to Name, and I can set Source equal to a StaticResource or
                    productViewSource. But the one thing it did do, which was nice, was the declaration of that
                    CollectionViewSource for me up in the Resources section, and getting this all hooked up. So that can
                    definitely save you a little bit of time getting things wired up.
                </p>
            </div>
            <div class="panel-body">
                <h3>Editing Data Templates</h3>
                <p>
                    Now another feature of Visual Studio you can take advantage of if you don't want to spend all your
                    time just banging out XAML in the Editor, is the Visual Studio DataTemplate editing feature. This is
                    something that came over because in Visual Studio 2012 and later, the Designer is really the same
                    designer that Blend for Visual Studio is using and this is a feature that already existed in Blend.
                    Basically, what you can do is graphically add DataTemplates in the designer. You can go up to an
                    existing control, you can say you want to set up a DataTemplate for it, it will generate that
                    DataTemplate and give you a graphical design experience on top of it. You can add controls to the
                    template, set properties on those controls, and even hook up data binding to the properties of those
                    controls. Now if you go and compare this to the similar features in Blend, it's a little bit
                    limited, but it gives you a little more flexibility to go to any resource in your project and get a
                    graphical editing experience on it. The feature I'm going to show you here in Visual Studio is just
                    for a given control on your UI that you want to hook up a DataTemplate to, and you'll see from the
                    demo that there's a lot of pointing and clicking and mouse movement involved to get this done. If
                    your DataTemplate is fairly simple, you may find, as I usually do, it's easier to just bang out the
                    XAML, but I want to get you exposed to the features. You can try it out and decide which works best
                    for you.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Editing Data Templates</h3>
                <p>
                    Now another nice capability that's available in the Visual Studio designer relative to data binding
                    is the ability to work with DataTemplates directly from the designer. So I can go to something like
                    my ListBox that's selected in the bottom left, I can right-click on it, and if I go to EditTemplate
                    here, this has to do with ControlTemplates, not data binding, but if I go to Edit Additional
                    Templates, you can see Edit Generated Items (ItemTemplate), and basically what we're doing here is
                    creating an ItemTemplate for use with that control. I can say, Create Empty, give it a name, we'll
                    call this ProductTemplate. You can see there's some selections down below about where it's going to
                    go. Those don't actually work correctly and you have no way to change them, so you just say OK here.
                    And what you end up with doesn't seem like a very impressive designer experience at first, because
                    what you've got here is just this little box in the Designer. A very important window in Visual
                    Studio when working in this mode is the Document Outline View. You can see that the Document Outline
                    View shows that we are working with the DataTemplate and it's got a single Grid within it. In fact,
                    if we go look at the XAML, that's exactly what we're looking at, a DataTemplate named
                    ProductTemplate with a Grid inside of it, but what we've got is a Design-Time experience for working
                    with that. So I can zoom in a little bit here, we'll go to 800%, and we can see we have the same
                    kinds of Design-Time experience working with that Grid. So say I want to set this up similar to the
                    ProductTemplate we used in a previous module. We could click here to add a column to my Grid, so now
                    I have two columns in my Grid. I could go to the Toolbox and grab another Grid, and put it in the
                    right cell. I can shrink it down so that it's fully within that cell, right-click, say Reset Layout,
                    All, and now we'll take off all sizing and positioning so that Grid fills the right cell. Then on
                    the edges of that Grid in the designer, you can see I could split it up into two rows. Now I've got
                    a place to put an image on the left, the name on the top, and the description on the bottom, similar
                    to the ProductTemplate that we used in a previous module. So now I just need to add those controls,
                    put the image in the leftmost cell, get it shrunk down so that it's fully within it, do another
                    Reset Layout, All. Then I can select the Right Grid so that I can see the guidelines on there, go to
                    the Toolbox, grab a TextBlock, put it in the upper right. Now this one gets a little harder to
                    resize because it's so darn big compared to that tiny little thing, but I can just shrink it down,
                    get it fully within the cell, right-click, Reset Layout, All, and you can see things get a little
                    wonky here because of the text being in there in a certain text size, but I could go edit that text
                    and zero it out and then things shrink back down to something reasonable. So then I could do
                    something similar, do another TextBlock into the bottom cell, again, it's too large, let's get rid
                    of the text, click out, click back in, and this is where this Document window comes in really handy.
                    Sometimes it's hard, especially with these semi-non-visual controls, like how do I grab the
                    TextBlock in here? You don't, you grab it in the Document Outline, and it will select it down below.
                    And then from there, I can say Reset Layout, All, grab it up here, say Reset Layout, All, and you
                    can see you have a little bit more control from the Document Outline. We can do things with our
                    Grid, such as changing sizing to Auto sizing. Go to the Sizing, Auto size on that, select the top
                    level Grid, go to the sizing of the columns and Auto size those, and now if we look at the resulting
                    XAML, we have something fairly close to what we had done before manually by pasting in some code top
                    level Grid with two columns, the inner Grid with two rows, an Image in the left cell, the TextBlocks
                    in the right cell, and no other sizing or positioning there. Now we need to hook up data binding on
                    these controls to the appropriate properties of a product. Obviously, I could drop right in the XAML
                    here and bang out the code quick enough, but just to show you the designer way of doing it, I could
                    go to my Image in the Document Outline to make sure it's selected, go F4 to bring the Properties
                    Window out, and go to the Source property. I go to this little square to the right of its input
                    field and say, Create Data Binding, and we get back to our Properties data binding window that I've
                    covered before. We would say that we're going to use the DataContext , which is going to flow down
                    into that DataTemplate as we've covered, and we would use a custom Path up here to say that we're
                    going to use the Image property of whatever that DataContext object is. Then, likewise, we could go
                    to this TextBlock, F4 for its properties, go to the Text property, Create Data Binding, set it to
                    DataContext , Path of Name for this one, other TextBox, F4, Create Data Binding, DataContext , and
                    Description for this one. So you can see that's a lot of mouse movement and a lot of clicking and
                    pointing, and generally I just found it would be a lot quicker to drop into the XAML and write those
                    expressions myself, but I just wanted to get you exposed to the designer-based way of setting
                    bindings as well. Now if we go back to the Design surface, you can see we're still in this, sort of,
                    zoomed-in focus where we're designing just the DataTemplate. How do we get out of this and back to
                    the main Designer View? Over here in the Document Outline you see this up arrow, Return scope to
                    (Window) in the upper left of the Document Outline, so we just click on that and we kind of zoom
                    back out. Now you can see the Document Outline transforms to the top-level Window hierarchy, and we
                    get our normal designer back. What if we want to drop back in there and make more tweaks? We can
                    just go select the Control again, right-click, Edit Additional Templates, Edit Generated Items (Item
                    Template), and then Edit Current, and we'll go right back into that existing DataTemplate.
                </p>
            </div>
            <div class="panel-body">
                <h3>Design Time Data</h3>
                <p>
                    Now let's look at an aggregate feature that's referred to as Design-Time Data in Visual Studio.
                    Basically what this is, is for Visual Studio to really light up and give you a lot of support in the
                    designer for working with data binding, the designer is going to have to know what data you're
                    working with. At a minimum, that includes what type of entities you're working with so it knows
                    about the properties and the type of those properties to facilitate some of the dialogs and things
                    that you've seen in previous demos. In addition, if you have sample data available, it can render
                    that in the Design-Time environment. Having this information can help you out in a number of ways
                    with the graphical design of your user interface. First off, in hooking up the code you get better
                    binding IntelliSense. In Visual Studio 2012, the binding properties show up when you're typing in
                    the XAML Editor, but you don't have much information about the actual data that you're working with.
                    One new feature in Visual Studio 2013 is that anything that's wired up as a DataContext in the
                    Design-Time environment will show up in the IntelliSense list. And if you pick those, it's going to
                    set those up to hook up the Path Property of the binding. In addition, you saw the Properties
                    Binding Window can populate with the properties on your current DataContext object or on other
                    Resource objects that you point to with a Source binding. In order to do that, it has to know what
                    those types are. In terms of the sample data, that can help out a lot with getting your UI laid out
                    appropriately. By having that data there in the Designer, you can visualize more what your controls
                    are going to look like once they are populated with data, and that can help you decide on the sizing
                    and positioning of those controls. Now one important thing to realize is that your UI elements are
                    alive in the designer. And what I mean by that is the elements themselves are actually being
                    constructed and loaded to render in the designer, just like they do at runtime. This means that
                    anything you construct in the XAML is also alive too. That means they're going to be constructed and
                    will be invoked from the designer. So, for example, if you're wiring up your ViewModel to the
                    DataContext property in the XAML, that's going to be constructed. And in your Constructor, if you've
                    tried to call to a service or a database, that's not going to work out because you don't have a full
                    execution context there, specifically, you don't have any application configuration and your host
                    executable is actually Visual Studio, not your normal host executable that you're building. So
                    things like database and service calls will generally fail, calls out to certain frameworks may not
                    work correctly, but basic construction of objects, setting of properties and things like that should
                    work just fine. Now to start leveraging this Design-Time Data, you need to start using some
                    framework features that are available. First off, there's a d:namespace that you're going to pull
                    into your XAML. You can see it as expression/blend in the namespace name, and that's because that's
                    where these features were originally introduced back in 2008. Next, you have certain properties that
                    you can set on objects that are only available in the Design-Time environment. So d: DataContext is
                    one that is similar to the normal DataContext property on an element, but if you set this on an
                    element, it's only going to set the DataContext in the Design-Time environment, and it will
                    basically be ignored at runtime as if it wasn't there. But in the Design-Time environment, whatever
                    object you point this to is going to be available in the designer and can be used to render out
                    things in bindings, and it's going to flow down the visual tree just like a normal DataContext does.
                    Another property like this you can use is on a CollectionViewSource, is the d:DesignSource property.
                    So this is the equivalent of the Source property on a CollectionViewSource, which you normally point
                    to whatever the collection is that is wrapping. D:DesignSource just provides a Design-Time
                    collection to use. Next, there's the d:DesignInstance markup extension. So this is a markup
                    extension with curly braces that you can use on the right side of the assignment from something like
                    DesignSource or DataContext . And what you do is you provide it a Type through an x:Type markup
                    extension, and it's basically saying, create me an instance of this object type for the Design-Time
                    environment so that the designer can reflect on it, find out about its properties and the types of
                    those properties and so on, but it will basically be an empty default values for all the properties.
                    Last, there's the d:DesignData property, and this is one that you can point to a XAML file or an XML
                    file that can be turned into an object model, and once that object model is created, if it has the
                    same properties as you expect for your runtime objects, those can be rendered out through the
                    bindings. So you can use d:DesignData to set d: DataContext or d:DataSource, and instead of just
                    getting the Type information, you actually get a whole built-up object model with values for all the
                    properties. So let's take a look at a demo of using all these features.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Design Time Data Features</h3>
                <p>
                    In this demo, I want to get you more familiar with working with DesignTimeSampleData and some of the
                    d:namespace markup extensions that assist you in the Design-Time environment. The starting point
                    here is a simple WPF application project. The only thing I've added here is I've added in the Zza
                    data layer project that we've been using for our data, and I added a ViewModel where this ViewModel
                    class is just set up to expose a Customers collection, and it has some hard-coded data in there
                    right now for a couple of customers that are being put into that collection, but only if you're not
                    in the Design-Time environment. So this is one of the first things that, you know, starts tying in
                    with the sample data here, is you can see that you have this switch available to you that we've used
                    before to make sure the database calls did not get executed in the designer, and here I've set it up
                    the way I did before where it's guarding out the initialization of our data. But in this case,
                    because this data is static data, it turns out this would work okay in the designer, so I'm going to
                    get rid of the not symbol here and make it so that this data is only there if we're in the designer.
                    Now this ViewModel is not hooked up to anything yet, we'll hook this up in a bit. So if I go into my
                    MainWindow and go to the design surface, you can see how I already added Data Sources for some of
                    the primary entities we'll be working with. So I'm going to add one more for my ViewModel itself,
                    because it is just a Data Object that I can bind to its properties. So I'm going to drill down in
                    here and check the box for my MainWindowViewModel. Now as we've seen before in other demos, I could
                    then drag this Customers collection out onto my MainWindow and it would generate a DataGrid for me,
                    it would hook up the data binding for that DataGrid, and it would also generate a
                    CollectionViewSource for Customers. I'm going to Reset Layout, All, and I'm going to drag up the
                    bottom and bring out a TextBox from the Toolbox that we'll also use in this demo. Now if we go into
                    the XAML and inspect what was generated from the drag-and-drop of the ViewModel, it's a little bit
                    more complicated than some of the demos we've seen before, but the thing I want to focus on here is
                    this part of the CollectionViewSource. I pointed it out before, but it generated a
                    CollectionViewSource for the object that we dragged and dropped, and it uses this d:DesignSource
                    property. So this d:namespace is a special namespace declared up above that contains a bunch of
                    custom markup extensions that are able to detect whether they are in the designer or not. And
                    they're really just using that same code that I showed in the ViewModel to do that detection. So,
                    markup extensions like this d:DesignInstance, can basically null themselves out or make themselves
                    so they do nothing when you're not in the designer. So it's as if these properties are not even here
                    if you're at runtime. So d:DesignSource functions like the Source property of a
                    CollectionViewSource, but it will only set the source if you're in the designer. What it's setting
                    it to is a DesignInstance. So a DesignInstance is a markup extension that can create a Design-Time
                    instance of some object. The object type it's going to create in this case is our ViewModel Type,
                    specified through an x:Type markup extension. And you can see over here, as we've talked about
                    before, the CreateList=True is part of the CollectionViewSource to say, even though we're talking
                    about an Entity type here, make it a collection of those entities. So this just gives the designer
                    information about the Type that's going to be used, and that allows it to populate some of those
                    Design-Time features, such as the Create data binding dialog from the Properties window that I
                    showed earlier. However, if we're doing the MVVM pattern, we actually don't want all this extra junk
                    in the way, so I'm going to strip out the loaded event that it added, I'm going to kill these
                    CollectionViewSources, I'm going to get rid of this DataContext on the root Grid, and I'm going to
                    set the binding on the DataGrid to be the Customers property that we expect to be exposed from our
                    ViewModel. Now I'm going to drop in here and set the DataContext to the Window to our ViewModel.
                    This would be a fairly standard structuring for MVVM. Now the reason I'm doing this is to emphasize
                    something about the designer. I'm going to go ahead and build here, and then we'll go over to the
                    design surface itself, and we see that there is immediately data there. And that is because if we go
                    back to our ViewModel, if you remember, we put this statement in here that says, only if you're in
                    Design mode, populate the Customers with these hard-coded data values. And it emphasizes the fact
                    that in the Design-Time environment, what you're seeing in the designer is live code basically. It
                    is constructing all the elements in the element tree and anything done during their construction
                    process is going to be live data. So it constructed the Window, and then to set the DataContext
                    property it constructed the MainViewModel. And in the MainViewModel's constructor, it checked and
                    said, yes I am in Design mode, so I'll new up this collection of customers and set those properties
                    because we're setting customers here and it raises PropertyChanged, events fire, and you're actually
                    looking at running code in the designer here. And so, this is one way you can get some sample data
                    into your Design-Time environment, is if you have some hard-coded sample data that will be part of
                    the construction process of the elements that are declared, then it's going to show up there and you
                    can use that to help get your layout right and visualize exactly what it's going to look like. The
                    problem with that approach is you probably don't want to have all this hard-coded data, especially
                    any complex object model, cluttering up your production code like this, and that's where some of the
                    other Design-Time data features come in.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Design Time Sample Data</h3>
                <p>
                    So what if you wanted to get this hard-coded data out of your ViewModels and model objects and so
                    on? You want to get it out into some separate data files that would not even be loaded at runtime.
                    So what I could do instead, I'm going to put the not symbol back in here, so that now these
                    customers will only be populated at runtime. And again, if I simply build and go back to the
                    Designer, now we can see our data is gone. Now I want to provide some sample data there, and there's
                    a couple ways to go about this. There's one very simple and crude way, which is that you can go into
                    your project and you can add a new Resource Dictionary, which really just gives you a flat XAML
                    file, and we'll call this MyDesignData. Once I'm in here, I can add in other namespaces, such as my
                    Zza.Data namespace, and then I could change the root element to be some object from that namespace.
                    Once I've done that, I could drop in here and just start setting properties on the Customer. So I
                    could set my Id equal to a GUID, I could set my FirstName equal to some value. Now I have a sample
                    data object that I can actually use in the Design-Time environment, so I'll save that and show you
                    the direct way of using it. If I go into the XAML of my MainWindow, I'm going to drop down to that
                    TextBox I put at the bottom. I can add a DataContext to just this element using the d: DataContext
                    property that we saw before, and what I'm going to set it to is a d:DesignData markup extension.
                    This takes a Source property, which can point to a XAML file. It's all pointed to MyDesignData, and
                    it's basically going to look into that XAML file, take the root element, create an instance of it,
                    and use that as the DataContext . Then I can take the text here and just set up a binding to
                    FirstName. And as soon as I do that, in the designer we can see it's pulling Brian out of that
                    DesignTimeData file. Now setting up those data files by hand can be a little bit of work.
                    Unfortunately, there's no direct support in Visual Studio for this, but if you just drop over to
                    Blend for Visual Studio, I'm going to fire up Blend for Visual Studio 2012, and certainly this still
                    works with 2013 as well, I'm just sticking to 2012 since 13 just came out. I can go and open the
                    same project, and once we're in here we can go to this Data tab over on the right and we can select
                    at a Project level, and in the upper right corner you can see Create Sample Data. We'll say, New
                    Sample Data, and you can also create sample data from a class, but I'm just going to show you the
                    raw experience here. I'll say, Create Sample Data, and we'll accept Sample Data Source. And what it
                    starts out with here is it's got a root level collection, which we'll call Customers, just like the
                    Customers property hanging off of our ViewModel. And then it's got a couple of properties declared
                    here, first off, a string, so we'll rename that one to be FirstName. This other one is set to a
                    Boolean, we'll switch that to be a string as well, and you can see there's various options depending
                    on the Type that you select, and we'll call this Id. Now you can see there's not a one-to-one match
                    here, our ID is actually a GUID, a GUID is not an option for the sample data, but for getting the UI
                    laid out and stuff, this can get you pretty close. Now as soon as that's done, what I can do is go
                    over here to my DataGrid and I'm going to delete this DataGrid out of here that was already here.
                    I'm going to go into the Toolbox here, find a DataGrid, select my root Grid here in the MainWindow,
                    and double-click on the DataGrid. That's going to add a new instance of it. I'm going to go ahead
                    and Reset Layout, All. It's going to end up overlaying my TextBox, but we're not going to use that
                    anymore anyway. Now that I have an empty DataGrid here, I can drag-and-drop the Customers collection
                    from my Sample Data Source onto my DataGrid, and we can see it immediately populates with some
                    sample data. Now I'm just going to save what I did and jump back over to Visual Studio. We'll Reload
                    All and let's take a look at what it did for us. First off, you can see it added a Sample Data
                    subfolder, the SampleDataSource, and under that a XAML file with an xsd. The structure of that XAML
                    file is kind of similar to what we were setting up by hand. It's got a single root object, it has a
                    Customers collection property, and then it's got individual customer items underneath that. Now you
                    can see it called these CustomersItem instead of Customer. That shouldn't matter. Bindings don't
                    actually couple to the type of the object that they're binding to, only to the property names on the
                    containing objects. So as long as this matches up with our Customers property on our ViewModel and
                    the properties we put on our CustomerItems match up with the properties on a Customer, we should be
                    good to go for getting this all hooked up. Because we selected Project Level, it declared an
                    instance of that SampleDataSource as an object inside of our application-scoped Resource Dictionary
                    and gave it a key of SampleDataSource. In the MainWindow, you can see what it did is declared our
                    DataGrid from our drag-and-drop operation, and it set the DataContext on that equal to that
                    SampleDataSource. Now it should have, and sometimes does, use the d: DataContext here. You really
                    only want that to be the DataContext on this DataGrid for DesignTimeData. For runtime, we want our
                    DataContext to flow down from the Window, especially if we're doing MVVM like this. So I can build,
                    and go back to the designer, and just prove that our sample data is still there. But now, because
                    our ViewModel was populating our Customers collection, if we are not in the designer, and because
                    this DataContext is only going to overwrite what DataContext comes down the visual tree if we're in
                    Design-time, it means that we can run this and we can see that our data coming from our ViewModel is
                    there at runtime, but in the designer we've got our sample data there. So you can see these
                    d:namespace markup extensions and properties give you a lot of power and flexibility to declare
                    things that will be there in the Design-Time environment. These can help you in getting your UI laid
                    out, visualizing what it's going to look like, handle things like localization, but then at runtime,
                    that data can be replaced automatically with your real runtime data.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    Okay, in this module you saw that Visual Studio provides a lot of features there for giving you a
                    more graphical user interface WYSIWYG experience for working with data binding. You saw that from
                    the Data Sources Window you can drag-and-drop entities or individual properties and generate
                    DataGrids, Detail Forms or even individual fields just through a simple drag/drop operation. And it
                    not only generates the UI elements, it generates them with decent layout, and it hooks up the
                    bindings on the appropriate properties to get it all data bound to the entity or property that you
                    dragged out. Additionally, you saw that you can hook up existing controls. So if you want to first
                    lay out all your controls and then hook them up to data objects, you can simply drag-and-drop from
                    the Data Sources Window onto the existing control, and it won't generate any UI, but it will set the
                    appropriate properties using bindings. You saw that while working with the Data Sources Window, the
                    set of mapped controls that get generated is customizable. It has a default set based on the
                    individual property types. You can customize that to add other control types that are in the
                    framework, or you can bring in your own custom controls or third party libraries to that list as
                    well. You saw that the VS Designer inherits, if you will, from Blend, because it really is the Blend
                    Designer under the covers, a nice little feature for graphically defining your DataTemplate. Now it
                    does involve a lot of point-and-click and drag-and-drop, and mouse movement, so in general, if it's
                    a simple template you may be able to do it faster by typing it, but you saw that you can just
                    right-click on a control, say you want to edit the template for that control, and the designer
                    switches into a Resource editing mode for a single DataTemplate. Finally, you saw you can bring in
                    some sample data into the Design-Time environment. You can either use the designer properties get is
                    in Design mode and have some hard-coded data back inside your model objects or your ViewModel
                    objects that's only used at Design-time, or you can use some of the properties and markup extensions
                    from the d:namespace to pull in sample data from XAML files or XML files and use that to populate
                    your UI in the Design-Time environment only, allowing that data to be overwritten or substituted at
                    runtime with your real-time data.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Containers and Collection Controls</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes. In this module, we're going to dive into some of the containment scenarios
                    and the dynamic generation of contained controls based on data binding. We'll also look in more
                    depth at the common collection controls, including ListBox, ComboBox, TabControl and DataGrid. And
                    we'll finish off by talking a little bit more about collection views, which can be used to modify
                    the collections you're data-bound to. So first up, we're going to dive into what's really going on
                    at runtime when you have a data-driven control and the composition that happens with the UI elements
                    that are generated based on the data. I'll quickly explain what's going on in concept with bullets,
                    and then we'll dive into a demo that hopefully makes it all clear, since it is dynamic in nature.
                    Next, we'll review ComboBoxes and ListBoxes and the key data binding properties and behaviors there.
                    We've seen a lot of this in previous demos, but in those previous demos I just kind of glanced over
                    it and didn't focus one at a time on the properties you'll care about. Next, we'll get into
                    TabControls, which TabControls are more of a structural element, but they can be data-driven
                    themselves. So we'll see a common scenario where you can use TabControls for child view containment
                    that can be dynamically-driven through data binding. Next, we'll get into the Ubiquitous DataGrid
                    and we'll focus on some of the key properties that you'll need to know to really drive a DataGrid in
                    normal data binding scenarios. There are, naturally, all kinds of deep, dark corners in the DataGrid
                    and lots of fancy customizations of appearance and things that are out of scope for this course.
                    What I'm going to focus on are the things that really drive the behavior of the DataGrid, based on
                    it being data-bound. Finally, we'll finish out this module by revisiting Collection Views. I talked
                    about the ICollectionView interface in an earlier module, and we looked at the notion of currency
                    driven by Collection Views. Here we're going to focus on some other things it can do for you in
                    terms of manipulating the collection that you're working with to do things like sorting, filtering,
                    grouping, and master-details presentations.
                </p>
            </div>
            <div class="panel-body">
                <h3>Container Controls</h3>
                <p>
                    Let's talk quickly, in concept, about the data-driven visual composition of data-bound controls, and
                    then we'll see how it really works in the demo. So mainly what I'm focusing on here are
                    ContentControls and ItemsControls. And these controls, when you're using data binding, can
                    dynamically generate child elements. They do it based on the data-bound objects that they're pointed
                    to. Generally, it's going to be based on DataTemplates, but in the case of ItemsControls, the
                    derived types, such as ListBox and ComboBox, have other properties that can decide what to render
                    just based on the data itself. When you're working with ContentControl, it's going to generate a
                    ContentPresenter, and the ContentPresenter is going to become the container for the data-driven
                    content, whatever you're setting as the Content property on the ContentControl through data binding.
                    ContentPresenter is also going to show up in a lot of other controls. A Window has a root
                    ContentPresenter it uses to show the child area, UserControls derive from ContentControl,
                    TabControls contain multiple ContentControls, DataGridCells, and so on, they all use
                    ContentPresenters to render out their data-driven content. And ultimately, the DataContext is going
                    to be set on this element as the ContentObject that's being rendered out, and that's going to flow
                    down the visual tree into something like a DataTemplate that's being rendered as the content. When
                    you're working with ItemsControls, it's going to be an ItemsPresenter as opposed to a
                    ContentPresenter. Similar concept, it's the single root container for each of the items rendered out
                    by that ItemsControl. And that is going to be a specific Type based on the control that's actually
                    rendering, so there's a ComboBoxItem Type, ListBoxItem Type, TabItem, and so on. When it goes and
                    renders out one of those items, generally somewhere down the chain of that item there's going to be
                    a ContentPresenter because that item represents a single piece of content, and the way a single
                    piece of content gets rendered out in a data-bound scenario is through a ContentPresenter. And just
                    like with a ContentPresenter inside a ContentControl, the DataContext on each item container,
                    specifically, ComboBoxItem, ListBoxItem, and so on, is going to be set to the individual data object
                    that's being rendered out within that ItemsControl. So that's a lot of words and lofty concepts.
                    Let's drill into a demo that will make this more concrete by digging in to the visual tree and
                    seeing what's going on when data binding is happening.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Inspecting the Visual Tree</h3>
                <p>
                    In this demo, I want to get familiar with the dynamic generation of data-bound elements when you're
                    working with ContentControls and ItemsControls in data binding scenarios. These controls generate
                    the rendering of the data-bound objects dynamically, and that adds elements to the visual tree.
                    Understanding what's going on down at that level can be very helpful in diagnosing and debugging
                    problems when they occur in your UI and in data binding scenarios. But because none of those
                    elements exist in design time, if you haven't seen it in action, you may not know where to go.
                    Starting point for this demo is a simple WPF project that already has a little bit of code in the
                    code-behind for going out and getting the Products Collection from our ZzaDBContext, similar to
                    previous demos, and pushing it into a CollectionViewSource that's already up inside the View. The
                    code-behind also has some Helper code that's basically going to generate a Tree View, based on a
                    node in the visual tree. So I've got a Helper method here called GetTreeFromNode that's basically
                    going to start at the current node and walk down using a Helper down below called GetVisualTree.
                    GetVisualTree uses the VisualTreeHelper class in WPF to walk through all the children of the current
                    node, and then recursively, notice the call to GetVisualTree here, recursively walk down to its
                    children. It's basically generating a TreeViewItem, which is a node for a Tree View for each item in
                    the visual tree from the object that you pass in, annotating the node that you started with by
                    square brackets. After it's walked down from the current node to all its children generating a tree,
                    it then starts walking up. So it has another Helper method down below called GetParent that will get
                    the ParentElement of the current node and then it uses that in a loop to walk up the tree and get
                    each one of the parents until you get to the root of the visual tree. The TreeViewItem that comes
                    out of this can be passed this helper called ShowTree that's going to basically create a TreeView,
                    put that root node into it, and pop it up in a window. So we're going to use this as a crude
                    visualization of the visual tree and the elements that we're working with. So to get started, let's
                    go over to our UI and I'm just going to drag out a simple TextBox, seemingly simple control, and we
                    will give it a name of TextBox1. I could then drop into my code-behind and use my Helper methods to
                    visualize the visual tree from that node. So I'm going to go in here and say,
                    ShowTree(GetTreeFromNode(TextBox1)). If we go ahead and run, we can see the TextBox loads up there
                    and we've got our visual tree here, starting at the root, which is the window, down through the Grid
                    that's its child. There's our TextBox, then notice that the TextBox itself contains a Border,
                    ScrollViewer, Grid, Rectangle, ScrollContentPresenter, TextBoxViews, and blah, blah, blah. So the
                    point is, any given element within WPF that you declare at design time, can have some complex
                    structure generated at runtime based on that declaration. In this case, what you're seeing is the
                    default ControlTemplate for a TextBox, so this stuff is not so much being generated dynamically
                    based on data, it's just part of the internal structure of a TextBox. Any control in WPF is going to
                    have some amount of that, but what we're going to focus on next is the dynamic generation of
                    elements based on data.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Dynamic Data Control Visual Tree</h3>
                <p>
                    So instead of that, if I replace my TextBox with a ContentControl, and we just use a binding that
                    takes in whatever the current DataContext is, which is going to be the collection coming out of this
                    CollectionViewSource. If we then dump the tree on that ContentControl, and run, now we can see
                    something similar get down to the Grid to the ContentControl, but notice this child element called
                    ContentPresenter. The DataContext on this, notice we're also dumping what the DataContext is at a
                    given level so that we can see where that switches in data-bound scenarios. The DataContext is null
                    on the ContentPresenter because it doesn't have anything to render yet, and we'll see that switch
                    momentarily. But notice that the Collection View flows down to the ContentControl and then the
                    ContentControl is going to render out a ContentPresenter for whatever it's trying to dynamically
                    render we need to give it a template to be able to render. So how can we set the template of a
                    ContentControl? Well we could use a number of different ways, but I'm just going to set an explicit
                    template setting the ContentTemplate property equal to an instance of a DataTemplate containing a
                    TextBlock. That TextBlock is bound to the Name property of the product that's being rendered. And
                    because of the way ListViews work, that was covered in a previous module, even this binding is
                    pointing to a whole collection, ContentControl is going to render out the current item in that
                    collection. So let's go ahead and run with that, and now we can see in the window behind there,
                    Plain Cheese is showing up. That's because that's the current product name. If we drill down in the
                    tree now, we can see we get down to the ContentPresenter level and notice now it does have the
                    DataContext is that ListCollectionView, but then immediately underneath that it renders an instance
                    of our TextBlock and that DataContext flows down to it. But because the control is designed to work
                    with a single object, it will pick the current object out of that collection and bind against the
                    Name property of that current object. So notice the ContentPresenter's role here in a
                    ContentControl, it is the thing that will render out the DataTemplate inside of it. Now what if we
                    go with a little more complicated control, such as a ListBox bound to the entire collection? And in
                    this case, we've got DisplayMemberPath set to Name. If we add that and dump that in a tree instead,
                    and go ahead and run, now we can see the dump here behind. You can see the ListBox is populated. You
                    can start drilling down. Here's our ListBox. It's got some structure with Border, ScrollViewer,
                    Grid, etc., eventually a ScrollContentPresenter, and then notice ItemsPresenter. So for a
                    ContentControl it's a ContentPresenter, that renders out the dynamic item. In an ItemsControl it's
                    an ItemsPresenter that renders out the dynamic items. But then notice we get down to a level called
                    the VirtualizingStackPanel, which is the default presenter for a ListBox, and we can't drill down
                    any deeper because the individual items are being rendered out dynamically in a way that the
                    VisualTreeHelper can't get to. So how can we get to those to visualize their structure? Well, if we
                    go to our ListBox and add an ItemTemplate to it and get rid of our DisplayMemberPath, this
                    ItemTemplate just contains a TextBlock bound to the Name property of the product again, similar to
                    what the DisplayMemberPath was doing, but here we can now hook up a Loaded event that we can then
                    tap into the object that's raising that event, which will be the TextBlock down inside of the
                    ListBox, then we can walk the visual tree from there. So let's go hook up this Loaded event. So I'll
                    jump into the code-behind and add the Loaded event here. We only want this to fire once, not once
                    for each item, so I've got a little guard condition here to make sure it only executes once. And
                    then we're going to do the ShowTree call for that sender object that's raising the event, which will
                    be the individual TextBlock inside of the ListBox. I'll comment out the other ShowTree so we don't
                    get two of them popping up, and let's run with that. Now we can expand down and we can see we get
                    down to the VirtualizingStackPanel level, but we're actually walking up to that level so we're able
                    to walk through it, and notice there's a ListBoxItem, and also notice the DataContext switch at this
                    point. So the true container of an item in the ListBox is a ListBoxItem. If it's a ComboBox, it's a
                    ComboBoxItem; if it's a TabControl, it's a TabItem. So each control has its own item container that
                    it will render out, and that's really the point where it switches from the overall collection to an
                    individual object in that collection as far as the DataContext . That flows down the visual tree
                    from there, and inside of that is a ContentPresenter, because the ListBoxItem is effectively a
                    ContentControl. Inside of the ContentPresenter, that's where our DataTemplate renders. So you can
                    see, now we're able to walk up the visual tree, basically, from that TextBlock in the event handler,
                    all the way up and see the internals of what's going on inside this VirtualizingStackPanel, and it
                    emphasizes that's the point where the DataContext switches. Now let's take an even more dynamic and
                    complicated data-bound container, a DataGrid. A DataGrid is going to render out rows for each object
                    in the collection. Those rows have composite structure of their own. And similar to what I showed
                    with the ListBox, if I just tried to drill down from the DataGrid, I wouldn't be able to get past
                    the Row level, the ItemsPresenter level. So I'm going to play a similar trick here, that I'm going
                    to use a TemplatedColumn, which we'll get into more details on later in the module, and provide a
                    DataTemplate containing a TextBlock bound to the Description field with a Loaded event hooked up on
                    it. I can hook that Loaded event and do my tree walk from there, similar to what I just showed with
                    the ListBox. So let's drop into the code-behind, add that event handler, we'll do our ShowTree on
                    the object that's raising the Loaded event, which will be our TextBlock inside of a cell within the
                    DataGrid, and we've got our guard condition to make sure we only do it once. Let's go ahead and run,
                    and now we can see a DataGrid showing up there, we can drill our way down. Notice the ItemsPresenter
                    in this case is a DataGridRowsPresenter and this is the level where we wouldn't be able to drill
                    down any farther if we hadn't hooked the event down inside of a DataTemplate, but we're really
                    drilling up to that point, so you can see that renders out DataGridRows as the containers. Those
                    have some structure to them. Eventually you get to a DataGridCellsPresenter, which contains an
                    ItemsPresenter itself. So you've actually got ItemsControl behavior at a Row level, but then within
                    a Row, you've got ItemsControl rendering of the individual cells within the Row. Notice in terms of
                    DataContext switching, the Context switch happens at a Row level. The entire Row's DataContext is
                    the Product, and from there down. Inside of the Cells, we've got a DataGridCellsPanel, eventually a
                    DataGridCell is the container for a single cell. There's our ContentPresenter again, the thing
                    that's going to render out our DataContext for that cell. The other thing to note here, that we'll
                    talk about more in the DataGrid section of this module, notice there's no Column objects anywhere
                    here. Columns don't really exist in terms of the object model of a DataGrid at runtime. They're
                    explicitly part of the way you declare the DataGrid at design time, but the rendering actually
                    happens at a Row level and then walking across the cells of a row, not in a column-oriented fashion.
                    And this really emphasizes the pivotal role of the ItemsPresenter here and here, and the
                    ContentPresenter here, for dynamically rendering out the data-driven content of a data-bound
                    control.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Visual Tree Tools - Mole and WPF Inspector</h3>
                <p>
                    Now the other thing I wanted to point out is there are some tools out there that can help you with
                    all this data visualization and visual tree inspection. You don't necessarily have to write these
                    tree dumpers in your code yourself. The first is one called Mole for Visual Studio and this is a
                    debugging visualizer that plugs into either Visual Studio 2013 or 2012 or prior. The other is a tool
                    called WPF Inspector, which you can find out on CodePlex. And there's a new XAML -Inspector coming
                    that will work with other XAML technologies in a similar way. I've got both of these available here,
                    so let me start up the app that I put together in the previous demo, and we're hitting a breakpoint
                    for a DataGridCell_Loaded that's being triggered from a template down inside of the DataGrid. Now
                    when you use Mole, it's a debugger visualizer, which means you can walk up to an object in your
                    environment, go to this little magnifying glass, drop it down, and you can see Mole 2012. I click on
                    that, and it brings up the MoloScope. So Mole gives you, over here on the left you can see, it's
                    broken down the visual tree similar to what I did in my demo. So you've got this Visual Tree
                    TreeView that you can drill through and see all the same kind of stuff rendered out a little nicer
                    than what I was doing. Also, anything you select in here over on the right, you're able to see all
                    of the properties of that object, inspect them, and even edit some of them. So if you want to tweak
                    with styling and things like that, you can do that in here and see what it's going to look like. And
                    if you select a given item up above, you can go down here on the bottom left, click to refresh, it's
                    going to show you what the XAML would look like for that single thing, and you can go into Snapshot
                    and it will render out just that single item. So here we can see we're seeing just a Description
                    cell that would be within the DataGrid. So in terms of being able to walk up to any element in a
                    running application and start inspecting and tweaking it, Mole is very nice for that. The other tool
                    that's very handy here is WPF Inspector. So if I go start up WPF Inspector, and you do have to run
                    this as an administrator, that's an important trick, because it has to have the process rights to be
                    able to go and inspect another process. So notice it shows MainWindow here, that's my running
                    MainWindow. I can attach to that, and it brings up this window that's kind of laid out similar to
                    what Mole had. You can see we can start drilling down in the visual tree. Now in this case I'm
                    drilling down from the top down and we can see I can drill into something like my ListBox and this
                    will let me drill down through that ItemsPresenter and VirtualizingStackPanel, and now I can see the
                    ListBoxItems rendered out. So I don't have to hook those lower-level events with WPF Inspector to
                    drill all the way down the visual tree. This, you can see if you hover over an item, gives you a
                    rendering of what that item looks like in the overall context, and the other thing that's going on
                    here, it's hard to see with the small screen here, but notice as I make selections in WPF Inspector,
                    it's actually putting a red box around them in the running UI with some measurements. Over on the
                    right, similar to Mole, it has the property values so you can inspect those for the currently
                    selected item, and you can do other things with it inspecting the DataContext that's there, even
                    tweaking the values to see what it would look like in the UI. So we could go tweak the name of an
                    item here and tab out of there, minimize this, and we can see it actually dynamically changed it in
                    the running UI. So very handy tool to be aware of for digging into your visual tree, seeing what's
                    there, understanding what's there, and playing with values in it. So both Mole and WPF Inspector are
                    very handy tools to have in your arsenal to be able to drill in and inspect your visual tree,
                    visualize things, and make tweaks to them. And in the context of these demos, for really
                    understanding what's being dynamically generated at an ItemsPresenter and ContentPresenter level,
                    and what the DataContext s are, to make sure your data binding is working out the way you expect it
                    to.
                </p>
            </div>
            <div class="panel-body">
                <h3>ComboBoxes and ListBoxes</h3>
                <p>
                    ComboBoxes and ListBoxes are a mainstay of data-bound scenarios, so let's review the key properties
                    you're going to want to have at the tip of your fingers every time you go to do data binding with
                    these. First off, they both derive from ItemsControl, so all the concepts around ItemsControls and
                    ItemsPresenters and things we've been talking about so far, apply. The data binding properties that
                    are going to be most important to you include, first and foremost the ItemsSource . This is the one
                    you're going to set to a collection that's going to render out the individual items within the
                    ComboBox or ListBox. Next, if you want to keep it simple, you can use the DisplayMemberPath
                    property. DisplayMemberPath is going to be the name of a property on each data-bound object that you
                    want turned into a string and rendered as a string within the ComboBox or ListBox. If you need to
                    start using the SelectedItem, then you're going to have some value that you want to associate with
                    it, so SelectedValuePath lets you point to a different property, or possibly the same property, on
                    each data-bound object to identify the value of each item. Typically, this is going to be an Id-like
                    property, something like a primary key type property that you can use to go and retrieve the whole
                    object from a database or to transmit that Id around as a unique identifier for a particular object.
                    Hand-in-hand with SelectedValuePath is the SelectedValue property. This is the thing you can inspect
                    when the user is interacting with the control to see what the value of that property indicated by
                    SelectedValuePath is, on the currently selected object. Next, if you want to deal with the whole
                    selected object, then you can use SelectedItem. This is going to pass a reference to the entire
                    selected object to whoever calls it. And both SelectedValue and SelectedItem become good candidates
                    for data binding to push the SelectedValue or SelectedItem through a binding in a two-way data
                    binding fashion to some property either in your code-behind or in something like a ViewModel that
                    logic is then later going to act on based on what's selected. As we saw in a previous module, if you
                    want to start driving the visual appearance of each item with something more than just a string,
                    then you can provide an ItemTemplate, and that ItemTemplate is a DataTemplate to render out each
                    item with whatever visual structure you want, containing embedded bindings to the properties of the
                    current item. Now there's one other property on a ListBox to be aware of, called SelectedItems,
                    because ListBoxes support multi-select scenarios. The problem with SelectedItems is, it's not a good
                    candidate for data binding. It's a read-only property, so you can't set it through a data binding.
                    Now there is kind of an advanced way you can deal with this if you've been exposed to the concept of
                    behaviors, either attach behaviors or blend behaviors, these are extensibility points you can write
                    and embed in your XAML. You could write a custom behavior that monitors the SelectionChanged event
                    of the ItemsControl, reads the values from SelectedItems, and then pushes those values as a
                    collection through some property that the behavior exposes through a binding, but doing that goes a
                    little bit beyond the scope of this course. So let's dive into a demo that reviews all of these
                    important properties and how to use them in ComboBoxes and ListBoxes.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: ComboBoxes and ListBoxes</h3>
                <p>
                    In this demo, I want to walk you through the basics of ComboBoxes and ListBoxes. We've seen these in
                    a number of demos before, but I didn't really spend time focusing on each of the data-bound
                    properties and how they relate to one another, so I just wanted to revisit them comprehensively
                    since they're such a pivotal data-bound control. Starting point for this demo is a simple WPF
                    application project with a MainWindow in it, and I added a MainWindowViewModel. In the
                    MainWindowViewModel constructor, we're doing some data retrieval. As usual, we're using our
                    ZzaDBContext to go out to a Zza database, we're getting some products and pushing them into an
                    ObservableCollection. That collection is exposed as a property called Products on our ViewModel that
                    we can data bind to. We're also modifying the Image property of each product to point to a
                    collection of Images that's in our project under the Images subfolder. And we're setting two other
                    properties on initialization here, the SelectedProductId and SelectedProduct, which are both exposed
                    as properties on our ViewModel here. So this just gives us a good DataContext to data bind against
                    for our ComboBoxes and ListBoxes. We also have a RelayCommand in the project, which we've seen in
                    previous demos, just an ICommand object we can use to hook up buttons to point to handling in our
                    ViewModel, which we'll get to. So if I drop into my MainWindow and add a basic ComboBox here, the
                    basic structure is that it is an ItemsControl, so the most important property that you're going to
                    want to set in data binding is the ItemsSource property. Here we're pointing to a Products path on
                    whatever our DataContext is, and you can see up above our DataContext is already wired up so that
                    our MainWindowViewModel is our DataContext . So this will cause it to be constructed, the
                    constructor fires and loads the products, and then data binding fires and reads those products into
                    our ComboBox. If that's all we put on our ComboBox and try to run, as we've seen before, that's not
                    quite enough, because it's just going to ToString each of the Product objects and that's not really
                    what we want. So at a bare minimum, when using a ComboBox, you're going to want to set the
                    DisplayMemberPath property and I'll set that to Name. That basically says, go to the Name property
                    on each of those products, get that out as a string, and then it's going to render a TextBlock,
                    basically, inside of the ComboBox list for each one of those. So running with that, now we get
                    something a little more like what we expect. Now we see the names of each of the products in our
                    ComboBox. Notice that it started with nothing selected, and that's where some of the other
                    data-bound properties can come in. Another one, if you're using DisplayMemberPath, that you'll often
                    use, is SelectedValuePath. SelectedValuePath lets you point to another property on each one of your
                    data-bound objects that contains some sort of identifier typically. So in our case, we can use the
                    Id property. Hand-in-hand with the SelectedValuePath is the SelectedValue property, and this is one
                    that you can programmatically inspect based on events. If you were to hook the SelectionChanged
                    event, for example, you could then get the SelectedValue or the SelectedIndex or the SelectedItem,
                    but in a data-bound scenario you might push this value through data binding into some property,
                    especially in a ViewModel type scenario. So we could set up a binding on this and point it to our
                    SelectedProductId property on our ViewModel, like so. Now, if we go ahead and run, notice that the
                    ComboBox is not empty initially, and that's because of our initialization code back here in the
                    ViewModel. Remember we loaded up the products, but we also initialized the SelectedProductId
                    property to the first item in those products. Another one you could do as an alternative to
                    SelectedValue, you generally won't do both of these, is the SelectedItem property. SelectedItem gets
                    the whole data-bound object, which will be a Product object in this case, and pushes it through a
                    binding to a property in our ViewModel in this case. That, likewise, was being initialized in the
                    constructor to the first item in the list, so we should see that selected now when it starts up. And
                    we could go back here into our SelectedProduct setter, set a breakpoint, and see whenever it's set,
                    our set block is being called, so we have an opportunity to invoke some logic there based on the
                    product that's being selected. If we want to have more structure to the elements within our
                    ComboBox, we could use a DataTemplate, in this case, an ImplicitDatatemplate, but of course, an
                    explicit one would work as well. This DataTemplate is mapped to the Product Type and it uses the
                    Image property to render out an Image and a TextBlock to render out the Name. With that in place, it
                    would do nothing if we don't get rid of the DisplayMemberPath property because those two are
                    incompatible. When you say DisplayMemberPath, you're saying you just want to render out text based
                    on that property, so we can get rid of both DisplayMemberPath and SelectedValuePath, which is not
                    being used anymore, and go ahead and run this. And now we can see that the individual items in our
                    ComboBox have the structure that we determined in our DataTemplate, and obviously we'd want to do
                    some sizing on the ComboBox itself so we could show a whole item when selected. So those are the
                    primary things you're going to use on a ComboBox. Always an ItemsSource when you're data binding,
                    DisplayMemberPath and SelectedValuePath if you're just dealing with simple text rendering, and the
                    SelectedValue property to do something with it or the SelectedItem property to push the whole object
                    when selected, and then to put more structure on the rendering, use DataTemplates. All those same
                    concepts apply to a ListBox. I could go in here and add a ListBox bound to Products here.
                    DisplayMemberPath would, again, apply, as would SelectedItem, SelectedValue, SelectedValuePath, and
                    so on. I'm going to go ahead and run here with both the ComboBox and ListBox bound to Products to
                    emphasize something about synchronization. So right now, notice I can make a selection in the
                    ListBox and it has no impact on the ComboBox, and vice-versa. When you have two data-bound controls
                    pointing to the same collection by default, there is a CollectionViewSource associated with them,
                    but they are not synchronized with that current item in the CollectionViewSource. If you have two
                    things like that and you want them to stay in synch, this is where the IsSynchronizedWithCurrentItem
                    property comes in. Go ahead and set that to True on both of these items and run again, and now we
                    can see if I select Holy Smokes up above, it's highlighted in the list below, Italian Stallion down
                    below, it's selected up above. Now another thing you might sometimes want to do is have some other
                    UI that is driving the selection in a ComboBox, ListBox or DataGrid. So here I'm going to add a
                    simple little Search UI, a TextBox and a button that we can trigger. The TextBox is going to be
                    bound to a property on our ViewModel called SearchInput, and the button is bound to a command that
                    we're going to add. So first let me drop back to the ViewModel and add those two properties. So
                    here's our SearchInput as a string input, and here's our SetProductCommand as a RelayCommand. Now we
                    need to initialize that ProductCommand, so in the constructor up here, we can initialize it and
                    point it to a method called OnsetProduct, and I can declare that method down below here. And you can
                    see when that gets called through the command, I'm going to go out and use the SearchInput text,
                    which was pushed through thanks to two-way data binding, when I click on the button, changes focus,
                    that causes the current value in the TextBox to be pushed down into that SearchInput and that makes
                    it available to do a Search here against our Products based on the Name property, and then we will
                    push that into the SelectedProduct property. That's going to call the setter, which raises a
                    PropertyChanged event, and because our SelectedItem is bound to that SelectedProduct, that's going
                    to cause the ComboBox to change. Because the ComboBox changes and IsSynchronized is set on both of
                    these, it will also cause the ListBox to change. So let's go ahead and run with that, and we can see
                    down below there's a product called Taj Mahal. If I just put in Taj and Search, you can see it's
                    selected up above and selected down below. Put in Smokes, Search, Holy Smokes selected in both
                    controls. So that just further emphasizes the way you can bind SelectedItem, for example, or
                    SelectedValue, change the thing it's bound to in the code-behind, and that will drive what's
                    selected in the UI, a very common thing to do in

                    Model-View-ViewModel

                    data binding scenarios.
                </p>
            </div>
            <div class="panel-body">
                <h3>TabControl Data Binding</h3>
                <p>
                    TabControls are probably not something you think about first and foremost as a data-bound control,
                    because they're often used for structurally setting up some static content in child views within a
                    window. But TabControls are also good for dynamic view containment scenarios, when the set of child
                    views that you want to present is dynamically driven by data. To support this, a TabControl is
                    derived from ItemsControl so each of the tabs is an item that is rendered out, similar to ListBox
                    items in a ListBox. But each TabItem that gets rendered out is really a composite object itself. It
                    contains two pieces of content, and in fact, they're implemented as two separate ContentControls.
                    First off, there is the header. That's what shows up in the little tab at the top, which can,
                    naturally, be put on the sides or bottom if you need to. Then there's the actual client area of the
                    tab, the main part of the tab, if you will, and that's called Content. To drive these dynamically,
                    there's two DataTemplates associated with a TabControl. The ItemTemplate actually applies to the
                    header of each TabItem, and then there's a separate ContentTemplate that applies to the Content of
                    each TabItem. So let's take a look at a demo of how we can use this to compose dynamic child views
                    into a containing main view using a TabControl, DataTemplates, and data binding.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: TabControl Data Bound Views</h3>
                <p>
                    In this demo, I want to get you familiar with TabControls and how they can be used with data
                    binding. Starting point for this is a WPF project with a MainWindow and a MainWindowViewModel, and
                    then a ProductView, which is a UserControl in its own associated ViewModel. The ViewModel for the
                    ProductViewModel is just loading up products into a Products property on the ViewModel, which can be
                    rendered out in a list-oriented control. In addition, it has a ProductType string that can be used
                    to label what kind of products this view is rendering. The view itself is just going to use a
                    ListBox to render out those products, and notice that no DataContext is set inside the UserControl
                    because it's going to be set dynamically through data binding. The individual products are being
                    rendered out using a DataTemplate, specifically an ImplicitDataTemplate for the DataType Product.
                    The MainWindowViewModel, at this point, just has a property called ChildViewModels, which is a
                    collection of those ProductViewModels. So the scenario here is that we want to render out individual
                    tabs in a TabControl for different categories of products or ProductTypes. So using data binding,
                    we're going to create a collection of ChildViewModels here, one for each ProductType, and have data
                    binding render out the appropriate View and ViewModel in a tab for each one of those. To do that,
                    we'll need a TabControl, so let's drop into the MainWindow and add a TabControl bound to that
                    ChildViewModel's property on its ViewModel, which is already wired up as the DataContext . Next, we
                    need to actually populate that ChildViewModels collection with something, so I'm going to drop into
                    the constructor of the ViewModel here and populate it with an ObservableCollection. We're putting
                    one instance of the ProductViewModel in for each of the three ProductTypes that are in our Products
                    collection, pizza, salads, and drinks. ProductViewModel takes that Type that's passed in and uses it
                    to set the ProductType property, and then notice it's filtering the products that it loads into that
                    ViewModel, based on that Type. So now we have a TabControl, which is an ItemsControl itself, bound
                    to a collection of items, but it needs to know how to render those items out, and it's going to do
                    that with DataTemplates. So we're going to go up here to our Resources section and add in a
                    DataTemplate, an ImplicitDataTemplate, mapped to the ProductViewModel Type, which is going to be the
                    individual items that show up in this ChildViewModels collection. And similar to a demo in the
                    DataTemplates module, the actual rendering for a ProductViewModel will be its corresponding view,
                    and its DataContext will be set to that instance of the ViewModel through the magic of how
                    DataTemplates work. Now if we run at this point, we're going to see this strange-looking view where
                    we actually have tabs here, you can see I can click on them and the appearance is changing, but
                    what's actually happening is that view is being rendered in the tab itself, the tab header, and we
                    don't have a scrolling container, so we can't see it, but it's actually rendering them again as the
                    content of the tab, not exactly what we wanted. The reason for this is, a TabControl is an
                    ItemsControl, but it's really a composite ItemsControl, it's going to render a TabItem for each of
                    the items in its data-bound source, but a TabItem itself has two parts to it, it has a header and it
                    has content. The header is a ContentControl and the Content is a ContentControl, and the DataContext
                    for the TabItem as a whole is the individual thing that's being rendered, in this case a
                    ProductViewModel. So, the data binding in the content of the header binds to that, and the data
                    binding in the content of the main client area of the tab, also binds to that. So what we need to do
                    here is control this a little more explicitly. What I'll do is I'll drop into my Resources and add
                    another DataTemplate. This one's going to have a key to it so we can point to it explicitly and
                    we'll call this the TabHeaderTemplate. Here you can see we're just going to bind to ProductType
                    because the overall DataContext for the TabItem is still going to be the ViewModel and that's the
                    property exposed from it. Now we need to go down here to our TabControl and actually pull that
                    template in by name. So we'll set the ItemTemplate property through a StaticResource, pointing to
                    that TabHeaderTemplate. Now, notice if we wanted to do the other one explicitly, we could do that,
                    and what we would use is the ContentTemplate property and point it to whatever template we want, but
                    since we're using an ImplicitDataTemplate here we don't have to do that one. That one can match up
                    implicitly, but if you have an explicit one hooked up, it will ignore the implicit ones. So with
                    that fix in place, now we've got what we want. We've got the TabHeaders are being set based on the
                    ProductType property of our ViewModel, the Tab content is being set to an instance of the ViewModel,
                    which gets married up through the DataTemplate to its view, and rendered out.
                </p>
            </div>
            <div class="panel-body">
                <h3>DataGrid Features</h3>
                <p>
                    Now let's talk about the ubiquitous DataGrid. DataGrids are obviously a mainstay of data binding
                    scenarios and presenting data collections in tabular form. They are ItemsControls themselves, so all
                    the things we've said about ItemsControls apply to them as well. DataGrids are editable. They have
                    an edit mode and a normal mode. When you click in a cell in a row, it goes into edit mode and stays
                    there until you click out of that row. DataGrids support dynamic column generation, so they can
                    reflect on the data-bound objects and generate a column for each property on that object, but most
                    commonly you're going to use static column definitions, setting up exactly what columns you want, in
                    the order you want them, bound to the properties you intend. You can also use templated columns,
                    which we'll look into in more detail. Templating really comes in at two different levels. For the
                    column level, it really amounts to cell level. You define a template column, and that's specifying
                    the visual structure of each cell within that column. There are separate templates that you can set
                    for normal versus edit mode, in case you want to toggle, for example, render something as text when
                    you're not in edit mode, and then switch to a ComboBox when you are in edit mode. There's also a
                    RowDetails template that you can provide on the DataGrid as a whole, and this lets you provide a
                    DataTemplate to render out the child detail for a given row in whatever way that you want. You could
                    render out a data form, a child DataGrid or whatever makes sense for your scenario. An important
                    concept surrounding DataGrids and data binding is to realize that DataGrid columns are not part of
                    the visual tree. So earlier in this module we looked at the breakdown of the visual tree and the
                    dynamic generation of ItemsPresenters and ContentPresenters, and we saw that there are no columns
                    rendered out as part of that tree. On a DataGrid column, however, you will declare bindings. Those
                    bindings are actually kind of held aside and used at the point where it goes to render a cell. At
                    the point where the binding is first evaluated, it's when it's parsing the DataGrid and the columns
                    contained within it. Since that column is not part of the visual tree, things like RelativeSource
                    bindings and ElementName bindings that try to walk throughout the tree to find the source object,
                    are not going to work properly as part of a column. In a demo, I'll show you how you can use
                    templated columns to address that and still have the power and flexibility you need to use
                    RelativeSource or ElementName bindings when you want as part of a column definition. So let's dive
                    into a demo to get more familiar with all these aspects of DataGrids.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: DataGrid Features</h3>
                <p>
                    In this demo, I want to get you more familiar with some of the more detailed features of DataGrids.
                    Now DataGrids are a big topic. You could easily spend a whole module drilling into all kinds of
                    esoteric details about DataGrids. I just want to hit the high points here and the things you're
                    going to use most commonly in data binding scenarios. Our starting point here is a simple WPF
                    project with a MainWindow, and the only thing that's really been added here is a little bit of data
                    access code that's going out at runtime and getting a Customers collection populated, that's exposed
                    from the code-behind as a DependencyProperty that has an ObservableCollection. Notice it's also
                    drilling down and getting the related Orders for those Customers, which we'll use later in the demo,
                    and it's also populating a States property, which is a collection of the state abbreviations, and
                    that's all that's in the code-behind here. Now especially when it comes to putting together a
                    DataGrid, I find using the Data Sources Window to generate the columns for me is very handy.
                    Generally, you're not going to want to auto-generate the columns, because they won't be in the right
                    order and they includes certain properties you don't want to display, so you're going to need
                    explicitly-defined columns, and doing each one by hand in the XAML Editor is a lot of work. Using
                    the Data Sources Window, as I showed in a previous module, and go add a data source, point to the
                    object type that you want, get it into the tree here, and then just drag-and-drop to generate the
                    DataGrid and all of its columns. Now in this case I don't actually want all of those columns, and I
                    want them in a different order. So afterwards, I'm going to drop into the code-behind and move some
                    things around and delete a few columns. I'm just going to do that all quickly here with cut and
                    paste, and we get it down to Id, FirstName, LastName, Phone, and Email, and lastly, a State column.
                    I'm going to make one other modification up here at the root level, I'm going to set the DataContext
                    of the MainWindow to itself. So we saw this in earlier demos using a RelativeSource binding to Self,
                    meaning that the DataContext is the window itself, so the bindings within the view can point to
                    properties in the code-behind of the window, something you can do when you're not doing the MVVM
                    pattern. Next, I'm going to take the CollectionViewSource that was generated through the drag/drop
                    and make a modification to it, setting the Source property equal to the Customers property that's
                    being exposed from the code-behind. With that in place, I can go ahead and run, and we've got our
                    basic data-bound DataGrid scenario. Keep in mind, a DataGrid is editable, by default, so I can go in
                    here and start editing things. There's properties you can set to make it read-only. Also, at the
                    bottom, a DataGrid always has a new entry row, by default, and again, you can set a property to get
                    rid of that if you don't expect people to add new items from the Grid. The basic properties in play
                    here are, of course, ItemsSource because it is an ItemsControl; AutoGenerateColumns False because
                    we're explicitly declaring them, if you forget and leave that True, you'll get duplicate columns;
                    and then you declare a column for each column that you want in your DataGrid. Now the important
                    thing, as I pointed out in a previous demo, is that these columns don't actually exist at runtime.
                    They're a declaration used to generate cells within a row that represent a column, but the Column
                    objects here are just objects, they're not actually part of the visual tree. So that might raise the
                    question of how can they have bindings on them then? Well, the Binding property here is really
                    creating a Binding object, which is held in this Binding property. It's then used to set the binding
                    on whatever element will be generated within a cell, within a row representing that column. It's not
                    actually evaluated at a column level when the DataGrid is being built, only down at a cell level.
                    Now these Width properties are ones you can set size to Header, by default, but you can see it
                    supports *, Auto, and explicit sizing as well. Now when you do your drag-and-drop, it's going to
                    assume everything is just plain text, but you might want a more complicated rendering. There's other
                    built-in column types such as a DataGridComboBoxColumn, DataGridCheckBoxColumns, and so on. Now this
                    DataGridComboBoxColumn may seen tempting, but it's actually a little hard to work with at times
                    because you need to set the ItemsSource to the collection of things that's going to show up in the
                    ComboBox, such as our list of states. But the overall DataContext , when this actually results in
                    rendering a cell, is just going to be a single Customer object in this case. And unless you hang the
                    collection of states off of each Customer object, the ItemsSource property can't get to it through a
                    DataContext binding. Well, you might be tempted to try what I did here and use a RelativeSource
                    binding, walking up the visual tree to the parent DataGrid, because after all, this is a
                    ComboBoxColumn inside of a Columns collection on the DataGrid, it should be able to walk that tree,
                    right? Well, not so much, because again, these columns aren't part of the visual tree at runtime,
                    they're used to generate things at a row and cell level that are part of the visual tree, but the
                    ComboBoxColumn itself is not. So this RelativeSource binding basically won't work out. It does
                    expose other properties, such as SelectedItemBinding, which corresponds to the SelectedItem property
                    for the ComboBox that will be rendered out. As long as you can get a valid binding in there, that'll
                    work fine, as well as SelectedValueBinding, and so on. But if we run right now, you can see that our
                    State column looks kind of empty initially. If we click on it and go into edit mode, then it does
                    actually render like a ComboBox, but the ComboBox is empty. What do want to do when your binding is
                    not doing exactly what you expect it to do? Go look at your output window. Down here in the output
                    window, we can see a System.Windows.Data Error, and it says, Cannot find source for binding
                    'RelativeSource FindAncestor', and it's looking for a DataGrid. The hard part is, there's nothing in
                    this error message that's really going to tip you off if you haven't seen this video or learned
                    about it somewhere else. The problem is that the DataGrid column is not part of the visual tree, so
                    it's not able to walk up and find that DataGrid because it's just not there at the point where this
                    binding is being evaluated. So, what we can do instead is use a TemplatedColumn. TemplatedColumn is
                    a very important concept in DataGrids because it gives you full control over exactly what the visual
                    that will be rendered inside of a cell is. At the TemplatedColumn level, you can still set the
                    Header that will be shown at the top of the Grid and the Width of the column, but everything else
                    will be driven by what you put in the CellTemplate. I should mention there's also a
                    CellEditingTemplate property on the column if you want a different visual rendering for edit mode
                    versus non-edit mode. If you don't set that, it'll use whatever is in the CellTemplate for both
                    modes. CellTemplate is nothing more than a DataTemplate that you can put whatever visual structuring
                    in you want. So, here we use an actual ComboBox with all of its normal ComboBox properties, and in
                    this case, we can use a RelativeSourceBinding, and that's because this ComboBox doesn't come into
                    being until the DataTemplate is rendered within a cell, that cell is in a row, the row is in the
                    DataGrid, so the RelativeSource is actually able to walk up the visual tree and get to whatever it's
                    pointing to. So in this case, I'll point it to the Window level, to the DataContext property, which
                    will be the Window itself, to the States property that's exposed on that. So it's able to use that
                    to get the list of states to render in the ComboBox and then we do the SelectedItem Binding against
                    the current DataContext , which is a Customer object. So we grab the State property off that
                    Customer object to drive what's selected. With that in place, we can run, resize our window, and we
                    can see off to the right our ComboBoxes are there rendering as ComboBoxes interactive all the time,
                    even before you click into the row and get it in edit mode. And we can see that they show the list
                    of items and are data-bound to that. When we set those, they're setting the SelectedItem, which is
                    bound to the state of the Customer and it actually sets that on the Customer. Another last
                    capability to highlight here in DataGrids, is the ability to provide a RowDetailTemplate. So I'm
                    going to pop in here another property on the DataGrid, RowDetailsTemplate, which is just a
                    DataTemplate that will be rendered out as a child panel on each row when it's selected by default.
                    It's driven by a property at the DataGrid level called RowDetailsVisibilityMode. You can set this to
                    collapsed and then programmatically toggle it, or you can use this VisibleWhenSelected. And what you
                    put inside of that DataTemplate is totally up to you. The DataContext for the DataTemplate is going
                    to be the Row DataContext , which means a Customer in our current case. So, because we populated the
                    child Orders for a Customer in the query in the code-behind, it means that we can bind to that as a
                    property hanging off of the current DataContext for a given row, which will be the customer. In this
                    case, I'm just going to cheat and say, AutoGenerateColumns True, but in a real scenario you'd want
                    to explicitly declare just the columns that you want. But this could be a little data entry form,
                    some sort of rendering of the properties of an individual object hanging off of the current row
                    object, such as an address for the customer or so on. So let's go ahead and run with that. Let's
                    also resize our Gird, do a Reset Layout, All, so it fills the window here, and go ahead and run. Now
                    we can see the first row is selected, so we see this child DataGrid containing the orders, and as we
                    select each row we see a child DataGrid with the orders for that item. Obviously, it needs some
                    prettying up with some margins, some backgrounds, you probably want to get rid of the input row for
                    the child items, and so on, but you can see through a DataTemplate you can put whatever you want in
                    that child panel when the row is selected. So those are all the key things you want to know about
                    working with DataGrids and data binding.
                </p>
            </div>
            <div class="panel-body">
                <h3>Collection Views</h3>
                <p>
                    Now let's talk about some of the other things you can do with CollectionViewSources. We've seen
                    these in a number of demos so far, especially those generated by the drag-and-drops from the Data
                    Sources Window. And we mentioned them in a previous module when talking about the ICollectionView
                    interface. So, first off, a CollectionViewSource wraps a collection by pointing to it through its
                    Source property, and then you can use the CollectionViewSource as a collection for data binding. A
                    CollectionViewSource exposes an ICollectionView. So if you want to deal with the ICollectionView,
                    typically for something like maintaining what is the current object or moving the cursor of what the
                    current object is around in the collection, you can do that with the ICollectionView interface,
                    exposed through a .View property on a CollectionViewSource. But what we're going to focus on here,
                    is that you can also use the CollectionViewSource to morph or change the rendered data collection,
                    and use it to sort the data collection, filter which items are presented, or group the items.
                    Additionally, CollectionViewSources are very handy for Master-Detail scenarios, being able to chain
                    together a parent collection to a child collection, to a grandchild collection, and so on, and
                    render those out nicely based on user selections in the view. The way you do this is by chaining
                    them, so you set up multiple CollectionViewSources and you set the source of one
                    CollectionViewSource to a parent CollectionViewSource and use a property path to indicate what
                    properties on the current object in that parent CollectionViewSource should drive the child
                    CollectionViewSource. So let's see how we can sort, filter, and group in one demo, and how we can
                    set up Master-Details in another demo.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Sorting, Filtering, Grouping with CollectionViewSource</h3>
                <p>
                    In this demo, I want to get you familiar with some of the extra things that a CollectionViewSource
                    can do for you when working with data-bound collections, specifically sorting, filtering, and
                    grouping. Starting point here is the end of our last demo working with DataGrids. I'm going to take
                    my DataGrid and pull it down from the top a little bit so that I have room to add some buttons. I'm
                    going to drop into the UI here and add a button, its content is set to Sort, and we're going to hook
                    up an OnSort method in the code-behind. Our OnSort handler here, you can see, is going to reach out
                    and find that customersViewSource that's up in the XAML. This is the one that was generated through
                    drag-and-drop and slightly modified in the last demo, but it's pointing to the Customers collection
                    exposed from the Window code-behind, which is our DataContext . So once we have a reference to a
                    CollectionViewSource, it exposes a number of methods and properties we can use to modify the
                    collection it exposes for data binding purposes, first of which is a SortDescriptions property. It's
                    a collection of SortDescriptions that supports multi-sorting, and we just add new SortDescription
                    objects into it, telling it what property to sort on and what direction to sort. So just simply by
                    adding that and hooking that up to a button, we can go ahead and run, and we can see I will click on
                    the Sort property and now things are sorted by state. Now there is a slightly different way to go
                    about this using CollectionViews, instead of the CollectionViewSource explicitly. So I could comment
                    out the line of code that went directly to the SortDescriptions property of the
                    CollectionViewSource, and instead use the .View property on the CollectionViewSource to get a
                    reference to the ICollectionView interface. We've seen this one in previous demos in an earlier
                    module and we used it to drive the current object within the collection and to be able to move that
                    cursor, if you will, for the current object, forward and backward to select different items in the
                    collection. Well the CollectionView is really the thing that knows how to do the sorting, and it
                    really exposes the same API. It has a SortDescriptions collection that you can add new
                    SortDescriptions into, and do the exact same thing that we were doing directly on the
                    SortDescriptions here. By doing it through ICollectionView, you're not coupled to whether you're
                    actually using a CollectionViewSource or not. I showed in a previous demo, there's always an
                    ICollectionView under the covers you can get to through GetDefaultView. So we could sort through
                    that, even if we're not using a CollectionViewSource. Functionality here is exactly the same. Now
                    another thing I might want to do is filter my data based on some criteria. So I'm going to drop down
                    here and add another button, which will show up at the top, called Filter, and it's going to target
                    a method we'll add in the code-behind called OnFilter. I'll drop in the code-behind and add that
                    method, and you can see what the API looks like here is, again, we reach out and get a reference to
                    our CollectionViewSource. That CollectionViewSource has an event on it called Filter, and when you
                    hook up a subscriber to that event it's going to trigger it to reevaluate its collection, fire that
                    event once for each object, and let your event handler decide whether to include that object or not.
                    So you can see the event handler takes in a FilterEventArgs. Inside of that EventArgs is an item,
                    which is the data-bound object it's evaluating, and you're expected to return a Boolean through the
                    Accepted property of the EventArg. So here I'm just inspecting, is the State equal to Alaska? If so,
                    I set Accepted to true and it will be presented, otherwise, I set it to false. So I can go ahead and
                    run this, expand so we can see our states a little better, hit the filter, and now we see only
                    Alaska. Now, of course, the way this is wired up right now, we would be re-subscribing each time I
                    click on the button, so you'd want to structure that a little bit differently and do it one time as
                    the view initializes. I just wanted to keep it all local here for demo purposes. Now, again, if you
                    go through the CollectionView, there's a little bit different way to get it hooked up here. So we
                    could get to our CollectionViewSource and get to its underlying ICollectionView. And then, instead
                    of the event-based model, which I've always kind of hated events where you're expected to set
                    properties on the EventArgs to make things happen by the caller. It kind of violates the
                    fire-and-forget notion of events, so I'm not a big fan of this event-based way of doing it. The
                    ICollectionView way is a little bit more explicit. What you set is a Filter property on the view.
                    The Filter property is set to a delegate type that's called Predicate. Predicate takes in an object
                    and returns a Boolean. And basically, the Filter Predicate will be evaluated once for each object in
                    the collection any time you set the Filter property or you change the underlying collection. So this
                    is just a little bit more explicit that you pass in an item and you return a Boolean to say yes or
                    no whether you should include it. In this case, I'm doing Arizona instead of Alaska. So with that
                    hooked up, I can run, and we'll see the exact same behavior, just for a different state, click on
                    Filter, and now we just have the two Arizona customers. Lastly, through the CollectionViewSource you
                    can do grouping. So I'll add another button in my UI here to Group objects, and I'll drop into the
                    code-behind and add a handler for that OnGroup method. Similar thing, I need to get a reference to
                    my CollectionViewSource and it exposes a GroupDescriptions property. Now this one I'm not going to
                    show, but there is a way to go down through the ICollectionView and it has a GroupDescriptions
                    property as well. Here we just add a new PropertyGroupDescription, tell it what property it's based
                    on, and it's going to start grouping based on that property. If we go ahead and run with that, click
                    on Group, now we can see the groupings of states over on the right. Now just having them grouped
                    like that may not be enough visual indication, so the DataGrid and ListView controls in WPF support
                    styling based on that group. So I can go back to my XAML here, go up to my DataGrid, and add a
                    property called GroupStyle to the DataGrid, setting it to a GroupStyle instance, and the GroupStyle
                    can have various things in it, but one of the things it has is a HeaderTemplate. That's just a
                    DataTemplate that you can put whatever you want in it. Now the DataContext for this is not going to
                    be a RowObject, it's actually going to be the Group itself, which will have its Name property set
                    based on the Group that it's rendering. So the binding is generally going to be Name here, but with
                    that in place we can go ahead and run again, click on Group, and now we see it puts these bands in
                    here in between the groups and renders out our GroupStyleTemplate. Obviously, you could put some
                    better visual structure to that to make it prettier, but that's how you deal with sorting,
                    filtering, and grouping using the CollectionViewSource.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Master-Details with CollectionViewSources</h3>
                <p>
                    The last I want to show here with respect to CollectionViewSources is how you can use it to drive a
                    Master-Details presentation of related collections and objects. My starting point here is a basic
                    WPF project. The only thing going on ahead of time is some data access code in the code-behind of
                    the window populating a Customers property that we're going to be data binding to. When I populate
                    Customers, notice I'm also drilling down and getting the related Orders, the related OrderItems for
                    the Orders, and the related Product for the OrderItem using Entity Framework. I can go into the
                    designer and the Data Sources Window, and I've already added Data Sources for our Entity objects
                    we're going to be working with here. As we've seen in a previous module, I can start at the root
                    level with Customer, drag-and-drop, and generate a grid. I'm going to resize that grid to fit
                    towards the top here. Now, for the related Orders and OrderItems, it might be tempting to drag out
                    from this level, but if you do you're generating a DataGrid that's bound to an independent
                    collection of orders or OrderItems. What you want to do is drill down to the property on a Customer
                    that is the Orders collection related to that customer. Do your drag-and-drop from there, and the
                    designer will do the right thing, which we'll show the code for in a moment, to generate a different
                    CollectionViewSource, but to tie that CollectionViewSource to the parent CollectionViewSource.
                    Likewise, I can drill down another level to OrderItems, drag that out, and have that related to the
                    parent Orders collection. And then we could go one level down to the related Product, switch that to
                    use the Details view, and generate a little data form for the current product, and I won't worry
                    about the fact that it's being clipped off there. With that code in place, it also generated the
                    Loaded event handler and all I've got to do is go set the Source property for the root
                    customerViewSource to my Customers collection that I populated on construction. So with that in
                    place, I can run, and notice that we have the, not very well laid out, but we have customers up
                    above. Whatever customer I select, we're seeing the orders for that customer in the next grid down.
                    Whatever order I select, I'm seeing the order details, and whatever order detail I select, I'm
                    seeing the related product. So a typical chained Master-Details kind of setup, all in seconds with
                    drag-and-drop. Now let's look at the XAML that it generated, because that's where all the action is.
                    And the magic key really has to do with these CollectionViewSources. The first one was generated
                    from the drag-and-drop of the CustomerEntityType, and we've talked through that before, that it sets
                    it up, says it going to be dealing with Customer, and that's the one that we're populating from the
                    code-behind at runtime. Where the Master-Details happens here is, notice the Source of the second
                    one it generated for Orders. Its set to a Binding whose Source is explicitly set to be the
                    CollectionViewSource up above for the Customers. That Customers collection is going to have a
                    current item in it, as we've talked about before, and that current item is going to have an Orders
                    property. So the path on this Binding is to the Orders property of the current item in that
                    collection. Likewise, for the OrderItemsViewSource it's pointing to the OrdersViewSource into the
                    OrderItems property on the current item in that OrdersViewSource. Notice there's not a separate
                    CollectionViewSource for the Product. When I generated the grid containing the data entry fields for
                    the product, it set the DataContext for that grid to the OrderItemsViewSource, which again, is going
                    to have a current item that's an OrderItem. And then it generated the bindings on the individual
                    fields to use the property Product.Description, Product.HasOptions, and so on. So you can see
                    through the currency that's managed by an ICollectionview, which a CollectionViewSource has under
                    the covers, whenever the current item changes, if there's another CollectionViewSource that's bound
                    to that collection in the current item, it can get to the properties of that current item and use
                    that to drive a separate CollectionViewSource, and so on down the chain.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    Okay, in this module we went through a lot about container controls and the dynamic generation of
                    child controls based on data binding, as well as collection controls and how they really worked. So
                    first we looked at ContentControls and ItemsControls and their pivotal role in the dynamic UI
                    composition based on data binding. We saw that ContentControls render out ContentPresenters, and
                    it's inside the ContentPresenter that the actual data-driven content, such as a DataTemplate, gets
                    rendered. Likewise, in an ItemsControl, an ItemsControl will render out an ItemsPresenter, and that
                    ItemsPresenter will be responsible for rendering out individual item containers. Inside those
                    containers, eventually, are often ContentPresenters that show the content for an individual
                    DataObject. Next, we reviewed ComboBoxes and ListBoxes, mainstays of data binding, and just made
                    sure you were familiar with all the key properties associated with data binding, including
                    ItemsSource , DisplayMemberPath, SelectedValuePath, SelectedValue, SelectedItem, and so on. Next, we
                    took a look at TabControls and you saw that they can be data-driven as well, especially for dynamic
                    child view containment scenarios. They can point to a collection of ViewModels or data objects that
                    are going to be rendered through a DataTemplate, and the views that get rendered inside the tabs can
                    be driven by DataTemplates, as well as a DataTemplate to render the header in the top part of the
                    tab that shows at the top of a TabControl by default. We drilled into DataGrids and got familiar
                    with the key properties associated with data bindings and the things you could do there. the fact
                    that DataGrids are really just an ItemsControl that's going to render out rows for each of the items
                    in the data-bound collection. DataGrids are defined through columns, but the columns aren't really
                    part of the DataGrid at runtime, as I emphasized. Column definitions result in rows and cells being
                    rendered. So the bindings you specify at a column level, really result in cell-level container
                    bindings at runtime. AS a result, certain kinds of bindings won't work in columns, specifically
                    RelativeSource bindings and ElementName bindings. For those, you can use a CellTemplate.
                    CellTemplate gives you full control of exactly what's going in to a cell, you define a DataTemplate
                    that contains the content you want to see in that cell, and that DataTemplate can contain whatever
                    bindings relative to the DataContext of the row that you want. So if the row is a customer, you can
                    point to properties on the customer and any normal data binding should work there, including
                    RelativeSource bindings and ElementName bindings because the cells are part of the visual tree, the
                    columns are not. We also looked at the fact that DataGrid RowDetailTemplates allow you to provide a
                    child panel that shows up associated with each row that you can populate with the DataTemplate with
                    whatever structure you want in there. It could contain an entire data form, it could contain a child
                    DataGrid, anything you want to put in there, the DataContext for that RowDetailTemplate will be the
                    data-bound row object, such as a customer, and you can use any properties hanging off that customer
                    to render out child details in that panel. Finally, we finished off with CollectionViewSource and
                    you saw that it gives you a very nice, easy-to-use way to sort, filter, group, and do master-detail
                    type setups when working with collections or multiple collections in your views.
                </p>
            </div>
        </div>
        <div class="panel panel-primary">
            <div class="panel panel-heading">
                <h2>Data Input Validation</h2>
            </div>
            <div class="panel-body">
                <h3>Introduction</h3>
                <p>
                    Hi, this is Brian Noyes. In this last module, we're going to look into the validation mechanisms of
                    data bindings and how you can use it to provide validation indications to a user when they put in
                    bad data. First we're going to talk about the simplest mechanism to use, which is to throw an
                    exception when you get bad data and to turn on a flag on the binding to have it give validation
                    indications based on that. After that, we'll look at a built-in mechanism in WPF called
                    ValidationRules. ValidationRules are objects that you implement that encapsulate a rule and get
                    evaluated by a binding when you hook it up to it. If that rule returns an error, then you'll get an
                    error indication on the screen. Next, we'll look at an interface that's been around since .NET 1.0
                    called IDataErrorInfo, which is a standard mechanism for indicating validation errors in combination
                    with data binding. When you use IDataErrorInfo, the object that you're binding to implements this
                    interface and it will be queried for errors after the properties are set. Next, we'll look at
                    INotifyDataErrorInfo, which was added in .NET 4.5 and supports asynchronous validation. It's very
                    similar to IDataErrorInfo, which is a synchronous API, but it supports the notion that you may need
                    to make an asynchronous call to something like a service to determine whether an input value is
                    valid or not, and then once you get the results back, then you want to provide the invalid
                    indication. Next, we'll talk briefly about some binding events that are available that can be handy
                    in dealing with validation and other scenarios as well. We'll talk about how you can customize the
                    validation indications that the built-in controls use for presenting validation errors and how you
                    can provide things like ToolTips with the error strings in them. And then we'll finish off this
                    module by talking about DataAnnotations, which are a standard mechanism in .NET for indicating the
                    validation rules associated with the property through attributes.
                </p>
            </div>
            <div class="panel-body">
                <h3>Validating on Exceptions</h3>
                <p>
                    One of the simplest ways to do validation with bindings is to use exceptions. Normally when you hook
                    up a binding to a property, if that property get or set block throws an exception, the binding is
                    just going to swallow it. It catches the exception. If you watch your output window, you'll see it
                    as a first chance exception, meaning it was handled, and it's handled inside of the binding itself.
                    But if you're explicitly throwing exceptions to indicate that a value that's being set is invalid,
                    you want to use that for validation purposes. All you do to do this is set a property on the binding
                    that says ValidatesOnExceptions=True. Once you do that, the binding catch block that catches the
                    exception, will take the error message of the exception and use that as a validation error. One of
                    the other advantages of this mechanism, besides its simplicity, is that it allows you to reject
                    invalid values before you ever store them, in the property itself. So you can basically check your
                    logic for what the validation rule is in the set block, throw the exception, and don't store the
                    value in the member variable if it's an invalid value. So let's take a look at a demo of how this
                    works in code.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Validating on Exceptions</h3>
                <p>
                    In this demo, we're going to get started with validation by showing you the easiest form of
                    validation to use, and that's using exceptions. The starting point for this demo and the rest of the
                    demos in this module, is a simple WPF project. It's got an empty MainWindow at this point. The only
                    thing in the MainWindow is a CollectionViewSource that's going to be working with a Customer Type.
                    In the code-behind of the MainWindow, we've got the Window Loaded event hooked up to go ahead and
                    access that customerViewSource and just put an empty Customer object into that collection. And the
                    Customer object we'll be dealing with in this demo is just a simple form of Customer. It's got three
                    properties at this point, it's got a HomePhone, a WorkPhone, and a CellPhone, and you can see it's
                    just implementing the INotifyPropertyChanged on that Entity Type. So that's our starting point.
                    Let's go ahead and add a couple of fields to our MainWindow to start doing some validation. So I'm
                    going to drag out the Work Phone and Home Phone fields to generate two input fields, and we won't
                    worry about layout here. Now if you remember from the Data Sources Window demos in a previous
                    module, when we do that drag/drop, because we already have this CollectionViewSource here, it didn't
                    generate a new one, it just set the DataContext on the two Grids that it generated, you can see one
                    grid for one field one grid for the other field. It sets the DataContext on the grid to the
                    customerViewSource, and then on the data input field it added the binding to the appropriate field.
                    Now as we talked about before, when you do these drag-and-drops it adds some of these other
                    properties relative to validation. You can see, by default, it's going to turn on
                    ValidatesOnExceptions=true. The NotifyOnValidationError we'll get to later in the module. I'll take
                    that off for now, as well as the Mode=TwoWay, which we covered in the previous module, is not needed
                    on input controls in WPF. So we're going to focus on this Home Phone field for now. In fact, I'm
                    going to take the ValidatesOnExceptions off for now, so I can first show what the default behavior
                    of bindings is when there are exceptions. So let's drop back to the customer here and add a little
                    Helper method to validate a phone number. This method's going to take in a value and it's going to
                    use a RegularExpression, which you don't have to read through the RegularExpression, but it's
                    looking for a standard 3 digits, 3 digits, 4 digits kind of format, like a U.S. phone number. And if
                    it doesn't match, it's going to throw an exception, an argument exception in this case, with an
                    error string of Invalid phone format. So now all we need to do is go to our HomePhone property, and
                    after we see if the value coming in is different from the one we currently have, we can invoke our
                    ValidatePhone method, passing in the value. So one of the advantages of using exceptions for
                    validation is that you can prevent the value from ever getting stored in your Entity object if it's
                    not a valid value. So if we run this right now, and I've got the output window up at the bottom,
                    note that as I put in an invalid phone number, something like abc, and tab out of the field, you can
                    see some first chance exceptions happening at the bottom. That's because, by default, a binding will
                    swallow any exceptions raised when it calls the set and get block, and it prevents your application
                    from blowing up if it can't evaluate the property that it's pointed to. But in this case, we want
                    that exception to indicate that there's a validation error. So I'm going to go back to my binding
                    and put back on ValidatesOnExceptions=True. Now if we run the same scenario, we go ahead and put in
                    an invalid value and tab out of the field, now we can see there's a red box around the control. So
                    WPF controls, by default, have a built-in error template that simply puts a red box around the
                    control. Now that's generally not enough information for the user, because they don't know exactly
                    what's wrong with that error and you probably want to tell them what the error message was
                    associated with the validation error. We'll get to how you can display those things later in this
                    module, but for now you can see that it has gone into an invalid state and it will remain in that
                    state until we put a valid value in, such as this number, and tab out of the field, and the red box
                    goes away. So validating based on exceptions requires nothing more than in the set block of the
                    property that's going to be set, invoke some logic that goes and decides whether the value is valid
                    and throws an appropriate exception if not.
                </p>
            </div>
            <div class="panel-body">
                <h3>Validating with WPF ValidationRules</h3>
                <p>
                    Another option you have in WPF for defining ValidationRules, getting them evaluated and hooked up to
                    a binding, is to use the built-in WPF concept of a ValidationRule. These ValidationRules are
                    specific to WPF, they did not get carried over to Silverlight, or Windows Phone or Windows 8 XAML
                    technologies. What you do is define a class that inherits from a ValidationRule base class, and then
                    you override a Validate method that's an abstract method in the base class. That Validate method
                    returns a ValidationResult object, which includes a flag to indicate success or failure, a Boolean,
                    and an error message that can be associated with it. Once you have the ValidationRule defined, you
                    go and you hook it up to a ValidationRules collection that's on a binding. To do this, you have to
                    use an expanded syntax that we'll see in the demo for a binding, instead of using a normal curly
                    brace markup extension. The good thing about ValidationRules is they can be used to encapsulate
                    reusable rules, which you can then go plug in to different places in your UI fairly easily. But, of
                    course, the downside is the portability, and you'll see another downside is that they're not very
                    good for context-specific rules. For general purpose rules they're okay, but the rule doesn't get
                    passed enough context about where it's hooked up to really be able to modify its logic based on the
                    context of where it's being used. So let's take a look at a demo of how you define ValidationRules
                    and get them hooked up to your bindings.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Validating with WPF ValidationRules</h3>
                <p>
                    In this demo, I'm going to get you familiar with ValidationRules in WPF, which are objects you can
                    create to encapsulate a rule and attach to a binding as a different way of setting up your
                    validation. Starting point for this demo is the end of the last one. We have our work and home phone
                    inputs. The Home Phone is still hooked up with an exception ValidationRule. We're going to hook up a
                    WPF ValidationRule to the Work Phone. To do that, we first have to define the rule. So I'm going to
                    add a class and call this RegexValidationRule. And basically what you do here is you derive from the
                    ValidationRule base class of WPF. That has an abstract method called Validate that you must
                    override, and you're expected to return a ValidationResult that indicates success or failure, and if
                    it's failure it includes an error string. The Validate method is going to be passed in a value, the
                    value that's being set on some binding that this ValidationRules is going to get attached to, and
                    basically, inside of your Validate method you have to come up with an answer of whether the value is
                    valid or not, so there's some implied context here. In this case, we're writing a reusable
                    ValidationRule based on RegularExpressions. Now as a starting point here I've got the
                    RegularExpression hard-coded into this rule. So really this should be a PhoneValidationRule not a
                    RegexValidationRule because we can't easily modify that. We'll fix that in a bit. But you can see
                    I'm just setting up a Regex, evaluating it with a Match call, and if it doesn't match that
                    RegularExpression, we return a validationResult with a false indication, so it's not valid, and an
                    error string associated with that. If it does match, then we just return
                    ValidationResult.ValidResult. Now let's go back over to our MainWindow to our Work Phone TextBox. So
                    here's the WorkPhone Binding that was put in there through drag-and-drop. I'm going to remove the
                    rest of the properties on the binding. Now the first thing to realize is that there's a different
                    way to set a binding other than the curly brace notation of markup extensions. anything that can be
                    set as a markup extension like this, can also be set as a nested element in XAML. So I can take out
                    the Text property here and add it in like this, where I'm setting the text property as a nested
                    element on my TextBox and the value of that property is inside of the angle brackets, in this case
                    an instance of a binding with its path set to WorkPhone. So that's just the equivalent syntax there
                    for setting up the binding. Now the reason for this is when you use ValidationRules you have to set
                    a property on the binding that cannot be done inline as a markup extension. So then we can expand
                    the binding to allow child elements and add in ValidationRules. So there's a ValidationRules
                    collection on a binding. Inside of that you can add instances of ValidationRules, so we add an
                    instance of our RegexValidationRule inside that collection. And now, anytime that binding goes to
                    set the WorkPhone path, it's going to evaluate that ValidationRule and pass in the value that it was
                    going to use. So with that in place, we could go ahead and run, and we can put the WorkPhone into an
                    invalid state, and tab out of the field, and we can see it goes red. Get it back into a valid state,
                    tab out, and the red box goes away. Now another thing to point out here while I'm at this point is
                    the UpdateSourceTrigger property of a binding. So this is the same UpdateSourceTrigger that we've
                    seen inside the curly brace notation. If we set it to PropertyChanged instead of the default of
                    LostFocus, then we get more immediate feedback to the user of validation errors. So as soon as I go
                    into an invalid state, the red box appears, and as soon as I'm back in a valid state the red box
                    goes away. So UpdateSourceTrigger, if you want immediate feedback to the user as they're typing, of
                    whether their current input is valid or not, can be a good combination when doing validation. In
                    general, one of the problems with ValidationRules is the fact that there's very little context
                    available inside of the Rule itself about what you're evaluating and where it's coming from. All you
                    get is a value here. You can think of this as, if a stranger walks up to you on the street, says 42,
                    are you okay with that. You have no context for why they're asking, where the 42 comes from, what it
                    relates to, all you have is a value and you're supposed to come up with an answer of is that valid
                    or not, and if not, an error string of why not. So you really need to be able to pass some more
                    context down into your ValidationRules to make them more meaningful. So one thing you can do is
                    define properties on your ValidationRules. I'm going to expand my implementation here and add down
                    at the bottom here an Expression property. Now I can pass in the RegularExpression, making this rule
                    really more reusable. So we got rid of the hard-coded RegularExpression, and now we use the
                    Expression property to formulate our Regex and evaluate it. Now we can go back out to our XAML, and
                    set it when we go to use our RegularExpression rule. So now we set the Expression based on the fact
                    that here we have some context that we're trying to evaluate a phone, and so we come up with a
                    RegularExpression that's appropriate for that phone. Obviously, if you're going to put any complex,
                    domain-specific logic into one of these ValidationRules, you're going to have to give it an
                    appropriate name that indicates the nature of the rule that's encapsulated in here and what kind of
                    value it's expected to be passed in. Whatever properties you choose to expose on your
                    ValidationRules, they will have to be set with a value that's static in the XAML. Because the base
                    class of ValidationRules is not a DependencyObject, you can't have DependencyProperties on it, so
                    you can't dynamically set these properties through a binding because a binding can only target a
                    DependencyProperty , so whatever properties you expose will only be able to be passed static values
                    from the XAML.
                </p>
            </div>
            <div class="panel-body">
                <h3>Validating with IDataErrorInfo</h3>
                <p>
                    One of the most common ways to implement validation in data binding in WPF and other technologies is
                    IDataErrorInfo, partly because this has been around for a long time, since .NET 1.0. It was
                    supported in Windows Forms and WPF and carries forward to other XAML technologies as well.
                    Basically, IDataErrorInfo is an interface that defines an API, so that the binding can query for
                    errors on the object that it's bound to. It's got two properties on it. First is an Error property,
                    and that's a string property that's meant to be an error for the object as a whole. That one's not
                    used a whole lot. It can be used in a DataGrid scenario to provide a row level indication, but when
                    you have individual input fields, it's not really used at all. The main one that's focused on is the
                    Indexer. So this is a C# Indexer, or an ItemProperty in Visual Basic, that is passed an argument
                    that is the property name and is then expected to return a string error if there is a validation
                    error for that property. So, as I said, it's been around for a long time, it was actually
                    implemented in DataSet row objects in .NET 1.0 and carrying forward, and it's very flexible on these
                    _____ EDUs. One potential downside to it, depending on your perspective, is that you do have to
                    allow the property to first be set. So the order of operations here is that the binding is going to
                    go set a property because some input has been put into a field in the UI. It has to first set that
                    property and then it will come back and query the IDataErrorInfo interface to basically say, are you
                    happy with that value. So you have to have stored that value in the member variable, so that that
                    subsequent call through IDataErrorInfo can look at the value that was set and decide whether it's an
                    appropriate value. Once you have IDataErrorInfo implemented on your data object that you're going to
                    bind to, you have to turn it on, on the binding. So there's a property on the binding that validates
                    on data errors that you set to true, and that causes the binding to go do that process I talked
                    about where it queries the IDataErrorInfo to see if there's an error associated with the property
                    after it sets it. So let's take a look at a demo of how we implement this on an object and get it
                    hooked up and using it in a binding.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Validating with IDataErrorInfo</h3>
                <p>
                    In this demo, I'm going to show you how to implement the IDataErrorInfo interface and use that to
                    derive your validation. Starting point here is the ending point of the last demo. So we're going to
                    first go and drag the CellPhone property out to generate a new field that we can do data binding
                    with. I'm going to drop into the XAML for that and modify the binding that was generated to get rid
                    of these extra properties, and just put one additional property, which is
                    validatesOnDataErrors=true. We saw validatesOnExceptions earlier, this is an alternative to that,
                    using IDataErrorInfo to derive your validation instead of exceptions. You can certainly do both. In
                    fact, there are times for a numeric input for example, bound to an integer field, that if you put in
                    something like abc, it won't be able to convert it to even set the property. So
                    validatesOnDataErrors won't have a chance to take effect, but validatesOnExceptions would show that
                    there was a format exception thrown trying to set that property. In this case, we're dealing with a
                    string property, so it's not applicable. Now we need to go implement IDataErrorInfo on our model
                    object that we're binding to. So I'll drop into my Customer and add the IDataErrorInfo interface and
                    implement it using Visual Studio. Down at the bottom of my class it added two members, a string
                    called Error, and an Indexer that says columnName here, but you can think of this, really, as
                    propertyName. The reason it generates it as columnName is this dates back to .NET 1.0 and the main
                    thing that implemented this interface was DataSets, so columnName was there to represent a column in
                    a DataTable within a DataSet, but on an Entity it's really the propertyName that's going to be
                    passed into the Indexer and it returns a string. So the idea here is that the Error property is
                    meant to represent an error for the object as a whole. For that, I'm just going to return
                    string.Empty. The Indexer is what we're going to focus our effort on, and the idea is that this will
                    be invoked by the binding when you say NofityOnDataErrors=true, the binding will call this Indexer
                    for the property that its bound to whenever it goes and sets that property. So first it will set the
                    property, then it will invoke the Indexer, telling you what property has been set. So it's basically
                    giving you an opportunity here to say, are you happy with the value that was set. You do have to
                    first accept the value into the property, so you're going to have to let the set block be called,
                    not throw an exception, write it into your member variable, so that down here in the Indexer, you
                    can then look at that value in the member variable and decide whether you like it or not, and if
                    not, return an error string. So what I'm going to do here is I'm going to return a method, because I
                    don't like putting a bunch of logic in a get block of a property. Then I'll go right below that and
                    implement that method. And the nature of the method that you're going to have to implement is,
                    unfortunately, generally a big switch case statement with a case for each property that you have
                    ValidationRules you want to implement. That's one of the downsides of IDataErrorInfo. But because
                    you're inside of the Entity itself, it does give you the flexibility to do cross-property
                    validation, for example, if you have some consistency rule between property A and property B, you
                    can inspect both of those when property A is set or when property B is set and come up with an error
                    based on that. In our case, we're just going to inspect for the CellPhone property when it's set.
                    We're going to use that same RegularExpression, see if it's a match, and return invalid phone format
                    as an error string if it's not a match or just string.Empty if it's good. So basically, if you
                    return null or string.Empty, it means there's no validation error, but any non-empty string means a
                    validation error. So by virtue of the fact that our entity that we're binding to now implements this
                    interface, and our binding says that we do want to honor that interface, this binding will basically
                    hook up to that interface and query for errors every time it goes to set the property that it's
                    bound to. So with that, we can go ahead and run, input an invalid value, tab out, and we can see the
                    error indication there. Get it into a valid value, tab out, and the error goes away. And that's
                    really all there is to IDataErrorInfo. Mostly focused on the Indexer, go decide what property is
                    being set, invoke whatever rules are appropriate for that property, come up with an error string if
                    there is one, and return it.
                </p>
            </div>
            <div class="panel-body">
                <h3>Validating with INotifyDataError</h3>
                <p>
                    Now a new interface that was added in .NET 4.5 that's similar to IDataErrorInfo is
                    INotifyDataErrorInfo. This was originally defined in Silverlight 4 and was added to .NET 4.5 for
                    WPF. It's the same basic concept that the binding can go and query for errors after it's gone and
                    set a property, but it's done with an event-driven interface that allows you to go out
                    asynchronously after the property has been set, triggers some ValidationRule that may take a long
                    time to execute, such as calling a service, and whenever the results come back, you can raise an
                    event that will cause the binding to re-query for errors. So to use this, you set a
                    validateOnNotifyDataErrors property on the binding, the binding will call the GetErrors method of
                    the INotifyDataErrorInfo after it has set a property. It also subscribes to the ErrorsChanged event
                    on the interface, and so if the ErrorsChanged is fired, it will go and re-query GetErrors at the
                    point where that event is raised. To implement this, you're going to manage a dictionary of errors
                    under the covers, so you basically are going to have a set of errors per property that gets returned
                    from the GetErrors method and GetErrors gets called, passing a property name similar to the Indexer
                    on IDataErrorInfo. So one of the advantages here of INotifyDataErrorInfo over IDataErrorInfo is that
                    you can return multiple errors per property. The Indexer on IDataErrorInfo only returns a single
                    string, but you might have multiple rules associated with a single property, each producing its own
                    error, so INotifyDataErrorInfo is more flexible in that way. So let's dive into a demo that shows an
                    asynchronous evaluation of Rules, which is where using INotifyDataErrorInfo really shines.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Validating with INotifyDataError</h3>
                <p>
                    In this demo, I'm going to get you familiar with INotifyDataErrorInfo, which is an asynchronous
                    version of IDataErrorInfo. So starting point here is the end of the last demo where we implemented
                    IDataErrorInfo. I'm going to drop into my Customer here and I'm going to implement
                    INotifyDataErrorInfo instead of IDataErrorInfo. So I changed my interface to INotifyDataErrorInfo, I
                    will use Visual Studio to stub it out, and then I'll go down to the bottom here and I'm going to
                    comment out the IDataErrorInfo methods since they're not going to be used anymore, and let's look at
                    the API of INotifyDataErrorInfo. First off, it's got an ErrorsChanged event and I'm going to use the
                    delegate trick here to make it so I don't have to check for nulls, which was discussed earlier in
                    the course. It's got a GetErrors method that's going to be queried by the binding when you hook up
                    to it, that's the logical equivalent of the Indexer on IDataErrorInfo. So it's going to be passed in
                    a property name, but notice this one returns an IEnumerable, so one difference here is that the
                    Indexer for IDataErrorInfo only allows you to return a single error string per property. With
                    INotifyDataErrorInfo, they recognize that you could have more than one rule associated with a given
                    property, so you can return a collection of errors. And then there's a HasErrors property that's
                    first going to be inspected by the binding before it calls GetErrors. So the basic sequence of
                    events is you have a binding that you indicate that you want to use, INotifyDataErrorInfo, and you
                    hook it up to an object that implements that, when it goes to set a property, it's going to check
                    and call the HasErrors property. If that returns true, then it's going to call GetErrors. If at some
                    point after it's called GetErrors, the ErrorsChanged event fires, it will come back in and call
                    GetErrors again, assuming that there is some asynchronous process that went out and determined
                    errors, populated the collection of errors behind the scenes that GetErrors is using to return its
                    values. So, basically, to start fleshing this out, what you need is somewhere to store some errors,
                    and the shape of that is generally going to be a Dictionary&lt;string, List&lt;string&gt;&gt;, so
                    you want to have that collection of errors that you return up here for a given property name where
                    the key is the property name. For the implementation of GetErrors, we can just simply reach into
                    that PropertyErrors collection, see if there is a key for the propertyName, and if so, return
                    whatever the value is the list of strings associated with it. Now I put a lock statement here
                    because we're going to go and do some asynchronous work using a separate thread, and that separate
                    thread needs to be able to push errors into this PropertyErrors collection. So if you're going to do
                    that in a multi-threaded way, you want to make sure you protect that dictionary because it's not
                    thread-safe, or you could use one of the concurrent collections that are available in the .NET
                    framework. I'm just going to use a basic dictionary here and lock on it. Next, we need to implement
                    this HasErrors method, so I'm going to flesh that out by calling a method, again, because I don't
                    like putting complex logic in a get block, personally. And what this method really does is it just
                    loops through all the keys in the dictionary, checks whether the underlying value is null, and if
                    there are any non-null entries in the dictionary, then it says that there are errors present, and
                    It's going to return true to say that there are errors. And then the binding will come and call
                    GetErrors for the property it's bound to and it will look up the errors and see if there are any. So
                    that's a simple brute force implementation of INotifyDataErrorInfo, but now we need to trigger
                    errors to happen somewhere. Now the whole point of this interface is to support asynchronous
                    scenarios, places where you're going to go and set a property, but you need to go do something like
                    a service call to invoke some logic on a backend to decide whether the value that was set is valid
                    or not. And something like a service call takes a long time, and you shouldn't be blocking the UI
                    waiting for it, so you want to go out and do that asynchronously. Now for demo purposes here, I'm
                    not going to set up a service and call it, I'm just going to use a task-based method to simulate
                    this. So this method is using the Task Parallel Library, it's defining a method called
                    GetErrorsForPhone where I can pass in a value. And what it's going to return, ultimately, is a list
                    of strings, but it does it through a task that can be invoked asynchronously. So inside of this in a
                    real thing, would be the point where I would dispatch an asynchronous service call, but instead what
                    I'm doing for demo purposes is I'm just going to use Task.Factory.StartNew, which causes it to
                    dispatch whatever's inside of this action delegate on a separate thread. The first thing I'm going
                    to do is go sleep for 5 seconds, so that you can see when I run this that's it's truly happening
                    asynchronously. Then I'm going to evaluate the logic that presumably is back behind the service call
                    or something that's going to take a long time to compute, and ultimately I'm returning my list of
                    strings, or null if there are no errors. So, basically, I want this to be invoked at a point where I
                    know that a phone value has changed. So, naturally, a good place for that would be in the set block
                    of our property. So I can go up in here, and after the property has been set, I can dispatch some
                    asynchronous _____ work. So I'm going to call that task-based method, which is non-blocking because
                    it's asynchronous, and when it is complete I use a ContinueWith, this is part of the Task Parallel
                    Library, and say what I want to do when it's done is basically go push any errors that came back in
                    into that PropertyErrors collection. But because this is all being done async, this is going to
                    happen on a separate thread, so this is where I need to also do locking on that dictionary before I
                    try to modify it, so that only one thread at a time can be messing with it. So I basically just take
                    the result property of the task that come back in from our ContinueWith, that will be the list of
                    strings that came out of my Task, and I can push that into the appropriate dictionary entry based on
                    the property that I'm setting. Once I know I've modified that collection, I need to raise that
                    ErrorsChanged event associated with the INotifyDataErrorInfo and tell it what property has changed.
                    That's going to trigger the binding that is tied to that property to go ahead and re-query
                    GetErrors. So with all that in place, I can go ahead and run, we can go into the Cell Phone entry
                    here, put in an invalid value, tab out of the field, count to about 5, and we should see a red box
                    up here. Boom, so that was that 5 second delay with the thread _____ sleep, went out, evaluated the
                    rule, returned the list of strings, raised the event, and triggered a GetErrors, and the errors have
                    been placed into the Errors collection in that asynchronous _____ handling. Now you can see if you
                    implement it this way, GetErrors can certainly still execute synchronously. All it's doing here, is
                    returning whatever is already in the Errors collection. So if we're able to synchronously invoke a
                    ValidationRule client-side up here from the set block of the property and populate the
                    PropertyErrors then, those errors will show up automatically as soon as GetErrors gets called. Those
                    errors will be returned automatically when this gets called, which happens after the PropertyChanged
                    fires from the set block. Now notice that our demo worked even though we have
                    ValidatesOnDataErrors=true here. There's a separate property for ValidatesOnNotifyDataErrors if you
                    only want to support INotifyDataErrorInfo, but ValidateOnDataErrors will also pick up
                    INotifyDataErrorInfo.
                </p>
            </div>
            <div class="panel-body">
                <h3>Binding Events</h3>
                <p>
                    Bindings offer a number of events that you can hook into for various scenarios, and one of those is
                    very specific to validation. Non-specific to validation are two events, there's the
                    Binding.TargetUpdated, which is an event that will fire when data flows from the source to the
                    target, and Binding.SourceUpdated, which will fire when data flows in the other direction,
                    basically, in a two-way data binding scenario when an input value in a field is being pushed down
                    into the source object. The one that's specific to validation is Validation.ValidationError. This is
                    an attached event that will fire whenever a validation error is added or removed from a control that
                    has a binding hooked up. Now none of these events fire by default, you're going to have to enable
                    them on a binding, and you do that with a series of properties on the Binding that are NotifyOn, and
                    the appropriate event, and you set that to true. So you first enable it with one of these flags, and
                    then you hook up the events above to an event handler in the code-behind. So let's take a look at a
                    quick demo of using the ValidationError event, in particular, to be able to know when validation
                    errors occur.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Validation Events</h3>
                <p>
                    Another thing that comes in handy sometimes when working with validation is being able to hook
                    events that fire when the validation state of a control changes. To do that, all we do is we drop
                    into our binding and we set another property called NotifyOnValidationError=true. Once that flag is
                    set, anytime the validation state of that control, meaning errors present or not, changes, it's
                    going to raise a validation event, which we can hook wherever we want in our UI. These
                    ValidationError events are attached events, so you can attach them to any element. So I could go
                    into my TextBox here and say, ValidationError equals some handler that I'm going to put in my
                    code-behind. Because these are bubbling events, I could also put them further up the chain. So
                    instead of on the TextBox itself, I could put it all the way up at Grid level here. Now I need to
                    add that error handler to my code-behind, so I'll drop into the code, add the method, and you can
                    see you get passed a ValidationErrorEventArgs. This thing has several properties on it. It's got a
                    ValidationError is the main thing you're going to look at and that error has a bunch of context on
                    it. The ErrorContent property is the main thing you're going to look at, it's generally going to be
                    the error string that you're dealing with. So I'm just going to Debug.WriteLine out the
                    (e.Error.ErrorContent). Now if we go ahead and run, watch the output window on the bottom, I'll
                    invoke my asynchronous validation, we'll wait the 5 seconds, and we can see Invalid phone format
                    showed up in the output window. So that's all there is to hooking validation errors. Make sure you
                    turn it on, on a binding, put the attached event hooked up somewhere in the UI on the element itself
                    or some parent element, and then have the handler deal with the validationErrorEventArgs that flows
                    in.
                </p>
            </div>
            <div class="panel-body">
                <h3>Validation Error Templates</h3>
                <p>
                    As you've seen so far, WPF controls have a default error template or rendering that it shows when
                    there's validation errors, which is a red box around the control, but it doesn't display anything
                    about the error messages themselves, and you might not always want to use a red box. So the
                    Validation Class has a number of attached properties that will allow you to drive the presentation
                    of errors. First off, there's the validation HasError property. This is a Boolean flag to indicate
                    whether there are any errors associated with the control. You can use that as a condition for
                    something like a property trigger to drive changing the style of the control. Then there's the
                    Errors collection, and this will get you all of the errors associated with the control, generally
                    based on a bound property, and validation errors that flowed through the binding. Finally, there's
                    the ErrorTemplate. The ErrorTemplate is the custom ControlTemplate that is used when there are
                    validation errors. So the default ErrorTemplate adds the red box around the control, but you can
                    customize that and do whatever kind of annotation you want to the control with your own custom
                    rendering. So the basic process is to provide a custom display for the control, you're going to set
                    the ErrorTemplate to some custom ControlTemplate that includes a placeholder in it for the control
                    itself. So, generally, you can think of it as you're surrounding the control with some kind of
                    validation indication, but you could certainly overlay the control with something too. You might
                    also want to do a ToolTip to show the validation errors, and the standard way to do that is to
                    define a Style with a trigger on that Style that monitors the HasError property. When the HasError
                    goes true, it sets a ToolTip on the control it's associated with and uses the Errors collection to
                    render out the string errors associated with it. So let's take a look at a demo of how to do the
                    ToolTips and how to provide a custom ErrorTemplate to modify the way it indicates errors on the
                    screen.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: Custom Validation Error Display</h3>
                <p>
                    So far in our demos, all we've had to go by when we have a validation error is this red box that the
                    control draws by default. It's not really enough information to help out the user. So let's take a
                    look at how we can provide a custom template to either customize the appearance of how it highlights
                    the box and also how we can get to the errors for display purposes. The first thing we might want to
                    do is put a ToolTip on controls that have the red box so the user can hover over them and see what
                    the error is. To do that, I'm going to drop into the XAML, go into the Resource section here, and
                    define a Style. I'm going to give this Style a name of ErrorStyle and let its TargetType be
                    FrameworkElement, so any FrameworkElement can have a ToolTip, we don't have to constrain it to a
                    particular type. What we're going to leverage here is some attached properties that the Validation
                    Class has. So we set up a Trigger section to our Style and we set up a Property Trigger on the
                    attached property, Validation.HasError. So whichever FrameworkElement that we apply this to,
                    basically, this is going to be monitoring the HasError property and whenever that HasError property
                    goes true, the value that we specify here, it's going to trigger this Setter. This Setter is going
                    to go set the ToolTip property of that FrameworkElement, and it's going to set it to a value that it
                    obtains from the Errors collection on the Validation Class. So it's using a RelativeSource Binding
                    here to basically get a reference to the element itself, use the attached property Validation.Errors
                    to get the Errors collection, use the CurrentItem property, which will give you basically the first
                    item in the collection in a safe way, so if there are no errors it doesn't have a problem trying to
                    index in, and then the ErrorContent, which is that same thing we saw in the Validation events demo,
                    which is typically the error string. So now we just need to tie this ErrorStyle onto our controls,
                    so I'll drop down to my TextBox and add Style="(StaticResource ErrorStyle)". Now with that in place,
                    I can put in my abc, tab out, wait for the 5 seconds, and now when I hover over that we can see we
                    get a ToolTip that tells us Invalid phone format is the problem. Now you might also want to
                    customize the way the control displays that error. Instead of a red box, you might want some kind of
                    icon next to it. To do that, we're going to go back up to the Resource section and define a couple
                    more resources. Now this does require you to understand ControlTemplates a little bit, because what
                    we're doing is we're defining a custom ControlTemplate that we're going to apply to our input
                    control. The structure of what you put in that ControlTemplate is totally up to you, but there's a
                    magic element that you need to have in here called AdornedElementPlaceholder, and this is basically
                    going to be a placeholder where the normal TextBox visual tree is going to be placed within this
                    ControlTemplate and whatever else you put around it is up to you. So you can think of it as you're
                    wrapping the normal TextBox with something that you want to show and we're only going to show this
                    when there's a validation error. So what I've got here is I've got a DockPanel. The last element in
                    a DockPanel will fill the DockPanel. And then notice, I put an Ellipse, which I Dock to the Right,
                    and just _____ have some structure to that Ellipse. So this is basically going to give us a little
                    gradient-shaded round circle. Notice it also has a ToolTip associated with it that we can hover
                    over. So we've defined this ControlTemplate and now we have to associate it with the controls that
                    are going to use it. So we apply an implicit Style here which is going to apply to all TextBoxes
                    that don't already have a Style, _____ setting some margin, and then the key thing here is we're
                    setting the ErrorTemplate and this Validation.ErrorTemplate is an attached property that we can set
                    and we're setting it to our ControlTemplate that we just defined up above. Validation system is
                    smart enough to know, only use this template if there are validation errors. In addition, we want a
                    ToolTip on these controls as well, so similar to the Style trigger that we put separately, we embed
                    that same ToolTip using the "(Validation.Errors) CurrentItem.ErrorContent" when there is an error on
                    the control. So with that in place, we can run, and remember on the Cell Phone we had applied a
                    Style explicitly for the ToolTip, but the other two don't have a Style applied, so we can see that
                    now we get that red dot to the right, instead of a red box around the control. And, if we hover over
                    the red dot, we get the, Contains invalid data that is part of that ellipse. If we hover over the
                    TextBox, we get the Invalid input format that's coming out of the ToolTip. So that's how you can
                    provide a custom Error indication for a control by providing a ControlTemplate that contains the
                    AdornedElementPlaceholder for the normal control and whatever you want to surround it with, and
                    making sure you set that as the ErrorTemplate for the control that you want.
                </p>
            </div>
            <div class="panel-body">
                <h3>DataAnnotations</h3>
                <p>
                    The last thing I want to talk about in this module is using DataAnnotations. DataAnnotations are a
                    namespace in the .NET framework, specifically System.ComponentModel.DataAnnotations, that have
                    become very widespread for validation purposes. It's a common mechanism for expressing validation
                    rules on properties, done through attributes. There's a set of built-in attributes for common
                    scenarios, including Required, RegularExpressions, StringLength, Range, Phone, Email, Url,
                    CreditCard, and then there's a CustomValidation attribute that you can use to point to a method
                    where you put your own custom logic. Basically, you put these attributes on a property and they will
                    be evaluated in validation scenarios. Now they can be automatically evaluated by some parts of .NET,
                    specifically, ASP.NET model binding will automatically evaluate DataAnnotation attributes. Entity
                    Framework will also automatically evaluate them. And it's somewhat defunct at this point, but
                    Silverlight RIA Services also had built-in support for this. Now WPF does not automatically evaluate
                    these, so you have to write a little bit of code using two classes from the DataAnnotations
                    namespace, ValidationContext and Validator, to get it to, basically, reflect on the property, find
                    the attributes, evaluate the rule, and return an appropriate error if validation has failed. So
                    let's take a look at how we can integrate this into our validation scenarios in WPF.
                </p>
            </div>
            <div class="panel-body">
                <h3>Demo: DataAnnotations</h3>
                <p>
                    Now another thing you should be familiar with respective to validation that's very common in the
                    .NET framework and other parts of the framework, are DataAnnotations. DataAnnotations are a
                    capability that comes in from a reference that you'll add to your project called
                    System.ComponentModel.DataAnnotations. DataAnnotations are known by Entity Framework, ASP.NET,
                    Silverlight RIA Services, and you can enable them in WPF very easily. First what we're going to do
                    is define a base class that we can put on our entities and I'll call this EntityBase. And we're
                    using this to encapsulate just the few lines of code that we need to evaluate DataAnnotations.
                    Specifically, there's a class called the ValidationContext. You pass it a reference to the object
                    that you're trying to validate, you set a property on it called MemberName to tell it what property
                    is being evaluated, and then you use the Validator class .ValidateProperty method, passing in the
                    value that's being set on that property, and the context object that you created up above, that
                    wraps the object being validated. ValidateProperty is going to throw an exception if this value is
                    not appropriate based on attributes that you can put on the properties. So this is basically some
                    infrastructure that you need, to get DataAnnotation attributes evaluated. So let's go add some
                    attributes. I'm going to comment out the ValidatePhone method call here in the HomePhone property,
                    and I'm going to add several DataAnnotation attributes. So first off, I'm going to put a
                    RegularExpression as one of the built-in attributes, so that we can just declaratively put the
                    RegularExpression that applies to this property, right there where it's defined, instead of having
                    to call out to some method and go see what that method does and write the Regex code to evaluate it.
                    Likewise, we could say this is a Required field, and it will give a validation error if it's empty
                    or null. We could give it a StringLength. If it was a numeric value, there is a Range attribute.
                    There's also a CustomValidation attribute that you can point to a method to encapsulate your own
                    logic. So these are just a nice declarative way to put attributes on a property to indicate what the
                    ValidationRule associated with that property is. But attributes don't do anything unless some code
                    goes and evaluates them. So that is why we put that EntityBase class in place, if we add EntityBase
                    as a base class for our entity, and then in the property we invoke that validate method. So we call
                    ValidateProperty on our base class, passing in the property name and the value that's being set.
                    That's going to trigger that code down in EntityBase to use the ValidationContext and Validator to
                    basically reach back up to this property, pull off each of the DataAnnotation attributes, execute
                    them to find out if there's an error, and if so, throw an exception with those errors. So with that
                    in place, we can go ahead and run, go to our Home Phone, see the StringLength, for example, tab out
                    of the field, and we can see we get our field Home Phone must be a string with a maximum length of
                    12. So it even gives you a nice error string there based off of the attribute, and those are
                    localizable. If you have some custom error you want, you can see that there are name parameters
                    including ErrorMessage, ErrorMessageResource string and Type if you're using resources for
                    localization, and a MinimumLength. Now one other thing to point out is, if you don't want to do it
                    with exceptions, now this is working because we have ValidateOnExceptions on our binding. If you
                    don't want to do it with exceptions, there's an alternative way on the Validator class called
                    TryValidateProperty. This will return a Boolean flag and it will populate a collection of
                    validationResults with any errors that result. So you can integrate this with the IDataErrorInfo
                    pattern to return the collection strings that come out of this if there was an error, instead of
                    throwing an exception. I'm just going to leave it with the ValidateProperty here, but generally just
                    throwing the exception and using ValidatesOnExceptions will work nicely. So that's all there is to
                    using DataAnnotations, put the appropriate attributes on your properties, have the few lines of code
                    invoked that get those DataAnnotations evaluated.
                </p>
            </div>
            <div class="panel-body">
                <h3>Summary</h3>
                <p>
                    In this module, we covered the key capabilities of using validation with data binding. First off, we
                    started with the easy stuff, which is, if you want to use an exception to indicate that a value
                    that's being set on a set block is an invalid value, then you simply throw that exception and set
                    the ValidatesOnExceptions property on your binding. Control will kick in, it'll show whatever
                    ErrorTemplate it has, and it will indicate that there's a validation error for that input. You saw
                    another mechanism, that's specific to WPF, is to use ValidationRules. You inherit from the
                    ValidationRule base class, you override a Validate method, you implement whatever logic is
                    appropriate for your ValidationRule in that class, and then you attach that ValidationRule to a
                    binding. You have to use an expanded syntax for the binding, using nested elements instead of curly
                    braces, and those ValidationRules don't have a lot of context passed in, just simply a value, so you
                    often need to put additional properties on there and set them from the XAML so that the
                    ValidationRule can have some decent logic in it. But these are a decent way to define an
                    encapsulated rule that can be reusable across different scenarios in your applications. Next, we
                    looked at IDataErrorInfo, which is the most common way of doing validation on business objects and
                    has been around since .NET 1.0. IDataErrorInfo is an interface you implement on your model objects
                    that will be queried by the binding when you enable it, after it sets the property. And that
                    querying basically lets the binding ask the object, are you happy with the value I just set on a
                    given property, and your implementation is expected to return an error string if not. The control
                    will then kick in and indicate that there's a validation error. Next we covered
                    INotifyDataErrorInfo, which is an asynchronous version of IDataErrorInfo. It came in, in .NET 4.5
                    and it supports scenarios where you may need to go make an asynchronous call to something like a
                    Services to determine whether an input value is valid. You can then raise an event that will cause
                    the binding to re-query for errors and show the error indications at the point where the error
                    arrives. Next, we talked about some binding and validation events that are available, and you saw
                    that these are simple events that you can hook up on your controls, and the validationError event,
                    in particular, ties in with validation to let you have handling in your code-behind whenever the
                    validation state of a control changes. Next, we looked at how you can provide custom
                    ControlTemplates to change the way built-in controls render when there is a validation error.
                    Instead of the default red box around the control, you can put a red dot to the right, you can put
                    an overlay on it, you could put dancing bears and spinning stars on the control if you like. We also
                    covered how you can provide a ToolTip to present the error information. Finally, we finished off
                    with DataAnnotations and explained that they are a standard way in .NET, using attributes to
                    indicate validation rules associated with the property. There's a set of built-in DataAnnotation
                    attributes for common scenarios, such as Required, StringLength, and RegularExpression, and you can
                    write your own custom rules and attach them through DataAnnotations as well. You saw that in WPF you
                    need a little bit of code to get the DataAnnotations evaluated, but that's easy to introduce from
                    the set blocks of your properties.
                </p>
            </div>
            <div class="panel-body">
                <h3>Course Wrap Up</h3>
                <p>
                    So that completes our course on WPF data binding in depth. You got a good end-to-end coverage of all
                    the capabilities of WPF data binding, starting with the data binding Overview, where we covered the
                    basics of bindings and DataContext , and so on. We got into Data Sources and what kinds of objects
                    you can work with, what types of interfaces and support those objects need, as well as what types of
                    collections you want to work with for data binding. We got into the Binding Core Concepts, talking
                    about things like alternate ways of expressing what the source object is, what the path on that
                    source object is, and what the direction of flow of data with the Mode property is. We got into the
                    more advanced properties of data bindings and talked about things like doing Async bindings and the
                    UpdateSourceTrigger property to trigger when data flows, and using FallbackValues and StringFormats,
                    and so on. We covered DataTemplates in depth, and you saw that those really start to unleash the
                    power of data binding to allow you to have custom rendering of your data-bound objects in any kind
                    of container control that's going to do data binding. We looked at the Design Time features in
                    Visual Studio and a little bit in Blend, that help you get really productive with data binding,
                    dragging and dropping your way to a data-bound UI and generating the UI elements and getting them a
                    decent layout to start with. We dove under the covers a little bit and showed you what's really
                    going on when data binding occurs in building up the visual tree based on the data-bound objects.
                    And we reviewed the common collection controls and made sure you really knew how to use all the
                    properties associated with data bindings for things like ComboBoxes, ListBoxes, TabControls, and
                    DataGrids, as well as CollectionViewSources. And finally, we finished off in this module with
                    Validation. So that pretty much wraps it up. Thank you very much for viewing the course. Please
                    recommend it to your friends. Be sure to come back and watch parts again if you need to review
                    concepts and review the code, and hopefully at this point you feel very well-equipped to go start
                    hooking up your complex data-bound UIs for your business applications.
                </p>
            </div>
        </div>
    </div>
</div>