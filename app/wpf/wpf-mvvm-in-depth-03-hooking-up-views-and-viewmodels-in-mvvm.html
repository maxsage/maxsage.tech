<div class="container">
    <div class="panel-group">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h2>Hooking up Views and ViewModels in MVVM</h2>
            </div>
            <div class="panel-body">
                <h2>Overview</h2>
                <p>
                    In this module we will cover different ways that Views can be hooked up to their ViewModels. We will
                    also cover how databinding is used to expose data from your Data Models to your Views. We will start
                    with View-First Construction Patterns where the View is constructed first and then takes care of
                    constructing and hooking up its own ViewModel.
                </p>
                <p>Next we will cover Data Binding to make it clear how MVVM relies on data binding and uses it to flow
                    data between the View and the ViewModel.
                </p>
                <p>
                    Finally, we will cover ViewModel-First approach where Data Templates are used to create the View
                    based on an instance of a ViewModel being placed into a data binding context.
                </p>
                <h2>View-First Construction</h2>
                <p>
                    View-First Construction can be performed declaratively in the XAML. XAML parsing kicks in just as
                    your View is being constructed initiated by the call to InitializeComponent() that is in your Views
                    Constructor:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-001A.png"/>
                    <figcaption>Fig 03-001A</figcaption>
                </figure>
                <p>Whether the View is a Window, User Control or a Page. The parser generally works top to bottom and
                    left to right as it works its way through your XAML. It calls the default constructor for each
                    element as it encounters it and then sets any properties for the constructed object based on the
                    attributes of that element. It also wires up event handlers based on the attributes as well.
                </p>
                <p>
                    Properties can also be set using nested elements for when the value of the object is a property that
                    needs to be constructed as well. As a result of this process, simply adding your ViewModel as a
                    nested element in the setter for the DataContext property allows you to satisfy the basic equation
                    of MVVM.
                </p>
                <p>
                    Another way you can do View-First construction is by simply constructing the ViewModel yourself in
                    the code behind of your View and setting the DataContext there with the instance:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-001B.png"/>
                    <figcaption>Fig 03-001B</figcaption>
                </figure>
                <p>Typically, this is performed in the constructor method for your View but you could also defer the
                    construction until the Loaded event of the View fires.
                </p>
                <p>
                    One reason for constructing the ViewModel in the code-behind instead of the XAML is that the
                    ViewModel constructor takes parameters. XAML parsing can only construct elements if they have a
                    default constructor so if the ViewModel needs to have something passed into it that is accessible
                    from the code behind of the View that might be another reason for doing the construction in the code
                    behind.
                </p>
                <p>Another reason would be if you were using something like a dependency injection container to do the
                    construction of the ViewModel. So that it can inject any dependencies the ViewModel has.
                </p>
                <p>Let's start putting together a sample that demonstrates View-First construction and that we can build
                    on for the rest of the demos for this module and the next.
                </p>


                <h2>Demo: View-First MVVM Hook-up</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-XAMLHookup-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-XAMLHookup-End</p>
                <p>
                    In this demo we will create a View and a ViewModel and hook them up statically through the XAML. The
                    starting point for this demo is that we have a data layer (Zza.Data) covered previously. It's a
                    separate class library project with a Entity Framework DbContext and some Model objects associated
                    with that for a Pizza ordering domain. We've also got the repository layer that I also covered
                    previously and we'll be consuming our data through that.
                </p>
                <p>
                    We will put the View and the ViewModel in a Customers feature folder. The View is just a UserControl
                    called CustomerListView and the ViewModel is just a class called CustomerListViewModel. And it
                    follows the naming conventions that the View has View at the end of it's type name and the ViewModel
                    has ViewModel at the end of it's typename so there easy to correlate. Now before we dig into the
                    MVVM let's go ahead and build this and I'll place an instance of my View in the MainWindow so we'll
                    go to the designer, toolbox drag and drop CustomerListView then right-click and select reset all
                    from the Layout menu to remove the padding and margins etc. This drag and drop operation basically
                    creates an instance of the UserControl in the View and adds the appropriate namespace.
                </p>
                <p>
                    Make the ViewModel class public and add a property (using the prop Visual Studio code snippet). Make
                    the type of the property an ObservableCollection of type Customer (don’t forget to add the relevant
                    using statements). Name the property Customers:
                </p>
                <figure>
                    <pre><code
                            class="cs hljs">public ObservableCollection&lt;Customer&gt; Customers { get; set; }</code></pre>
                    <figcaption>Fig 03-001</figcaption>
                </figure>
                <p>
                    Next we will populate the Collection. Add an instance of our repository to the ViewModel:
                </p>
                <figure>
                    <pre><code
                            class="cs hljs">private ICustomersRepository _repo = new CustomersRepository();</code></pre>
                    <figcaption>Fig 03-001C</figcaption>
                </figure>
                <p>and a constructor to populate our Customers collection.</p>
                <p>So first we might try setting the Customers collection through the repo:</p>
                <figure>
                    <pre><code class="cs hljs">Customers = _repo.GetCustomersAsync()</code></pre>
                    <figcaption>Fig 03-001D</figcaption>
                </figure>
                <p>But the challenge here is that this is an async method that produces a Task and not the Result and we
                    can't use async and await keywords in .Net so we will have to force the method to execute
                    synchronously which you can do with the .Result property on a Task:</p>
                <figure>
                    <pre><code class="cs hljs">Customers = _repo.GetCustomersAsync().Result;</code></pre>
                    <figcaption>Fig 03-001E</figcaption>
                </figure>
                <p>Now that still doesn't produce what we need cause the repository produces a List and we need an
                    ObservableCollection so we'll have to wrap the result:</p>
                <figure>
                    <pre><code class="cs hljs">Customers = new ObservableCollection&lt;Customer&gt;(_repo.GetCustomersAsync().Result);</code></pre>
                    <figcaption>Fig 03-002</figcaption>
                </figure>
                <p>Now we would generally be good to go with this but something you generally want to do if you have
                    lines of code like this in the construction process that are going to do complicated things like
                    try and go to a database or call a service is to add a guard condition to make sure they don't
                    execute in the designer or they can break the design surface so you can't use it anymore. To do
                    that we'll add a simple line of code:</p>
                <figure>
                    <pre><code class="cs hljs">if(DesignerProperties.GetIsInDesignMode(
                        new System.Windows.DependencyObject())) return;</code></pre>
                    <figcaption>Fig 03-002A</figcaption>
                </figure>
                <p>
                    is
                    add
                    code to
                    the ViewModel to prevent the
                    execution of the above code when in the designer using the
                    GetIsInDesignMode() method.
                </p>
                <p>In the CustomerListView.xaml View add a namespace for the ViewModel. Set the DataContext to an
                    instance of the ViewModel:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-003.png"/>
                    <figcaption>Fig 03-003</figcaption>
                </figure>
                <p>Add a DataGrid to display the data:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-004.png"/>
                    <figcaption>Fig 03-004</figcaption>
                </figure>
                <p>Now if you run the application the DataGrid should be populated with data:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-005.png"/>
                    <figcaption>Fig 03-005</figcaption>
                </figure>
                <p>We can also hook-up the View and ViewModel from the code behind with code like this:</p>
                <figure>
                    <pre><code class="cs hljs">this.DataContext = new CustomerListViewModel();</code></pre>
                    <figcaption>Fig 03-006</figcaption>
                </figure>
                <p>It generally doesn’t matter whether you set the DataContext before or after the call to
                    InitializeComponent().
                </p>
                <h2>View-First with ViewModelLocators</h2>
                <p>
                    The next form of View-First construction is a meta-pattern called ViewModelLocator. This is sort of
                    a pseudo pattern or common approach that is layered on top of the MVVM pattern.
                </p>
                <p>
                    When doing MVVM every View has to be hooked up to its ViewModel. The ViewModelLocator is a way of
                    centralising the code that takes care of that - decoupling the View more so it does not have to
                    explicitly know about its ViewModel type and how to construct it.
                </p>
                <p>
                    There are a number of different approaches to using ViewModelLocators. The one covered here is most
                    similar to the one that is part of the Prism framework. The ViewModelLocator provides a standard,
                    consistent, declarative and more loosely coupled way of doing View-First construction in that it
                    automates the process of getting our ViewModel hooked up to our View.
                </p>
                <p>The ViewModelLocator follows the following high level process:</p>
                <ul>
                    <li>The ViewModelLocator has to figure out what type is being constructed</li>
                    <li>As long as you have a convention for naming Views and ViewModels the ViewModelLocator can infer
                        what the ViewModel Type is associated with that View
                    </li>
                    <li>Once it knows the ViewModel Type needed it can construct that ViewModel – possibly using a
                        dependency injection container
                    </li>
                    <li>Finally, it sets the Views DataContext property to the ViewModel</li>
                </ul>
                <h2>Demo: MVVM Hook-up with ViewModelLocator</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-ViewModelLocator-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-ViewModelLocator-End</p>
                <p>In this demo we will look at using a ViewModelLocator to wire up our View and ViewModel in a
                    View-First way.
                </p>
                <p>Firstly, make sure you remove the DataContext hook-up XAML and code in the code behind.</p>
                <p>Define a ViewModelLocator class called ViewModelLocator. Make it public and static.</p>
                <p>
                    Use the propa code snippet to stub out a new Attached Property called AutoWireViewModel, make its
                    type Boolean and make it contained within the ViewModelLocator class with a default of false.
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-007.png"/>
                    <figcaption>Fig03-007</figcaption>
                </figure>
                <p>
                    You now have a basic Attached Property definition. Next we will turn this into a simple Behaviour by
                    wiring up a change event handler for the property. Add a handler in the PropertyMetadata called
                    AutoWireViewModelChanged
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-008.png"/>
                    <figcaption>Fig03-008</figcaption>
                </figure>
                <p>Stub this method out:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-009.png"/>
                    <figcaption>Fig03-009</figcaption>
                </figure>
                <p>
                    In the new method we want to automate the process of figuring what ViewModel to create and wiring it
                    up to the View. Firstly, add a guard condition that does nothing if we are in DesignMode. Next we
                    need to get the ViewType name using the following code:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-010.png"/>
                    <figcaption>Fig03-010</figcaption>
                </figure>
                <p>
                    The d argument is the element on which this Attached Property is being set. We are expecting that
                    this Attached Property will only be used on the root element of a View. So by getting the type of
                    that element we know what the View type is. Then we can get the type name from the FullName property
                    of the Type object. Next from the viewType we can infer a ViewModel type (as long as we are
                    following a standard convention). We append “Model” onto the ViewType name and we have type name of
                    the ViewModel:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-011.png"/>
                    <figcaption>Fig03-011</figcaption>
                </figure>
                <p>We use the Activator.CreateInstance method to create an instance of the ViewModel type.</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-012.png"/>
                    <figcaption>Fig03-012</figcaption>
                </figure>
                <p>Finally, we set the DataContext of the View to the newly created ViewModel:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-013.png"/>
                    <figcaption>Fig03-013</figcaption>
                </figure>
                <p>Now that our simple ViewModelLocator is complete we can use it to wire up our View and ViewModel.</p>
                <p>In the View add a namespace so that we can get to the ViewModelLocator type.</p>
                <p>Next on our root element which is the ViewType I add the AutoWireViewModel property:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-014.png"/>
                    <figcaption>Fig03-014</figcaption>
                </figure>
                <p>By doing that our ViewModelLocator will kick in as that property is being set and will take care of
                    the wiring for us.
                </p>
                <p>
                    You do the exact same thing in any View that you want to hook up to a ViewModel. To emphasize this
                    let’s add another View (CustomerDetailView) and associated ViewModel (CustomerDetailViewModel) in
                    the Customers folder.
                </p>
                <p>Add the local namespace and AutoWireViewModel property (set to true) in the new Views XAML as we did
                    before.
                </p>
                <p>In the MainWindow drag the CustomerDetailView from the toolbox to the design surface (make some room
                    for it first).
                </p>
                <p>Run the application.</p>
                <p>The advantages of using a ViewModelLocator are:</p>
                <ul>
                    <li>A standard declaration in every View</li>
                    <li>The View is not coupled to its particular ViewModel Type</li>
                    <li>You can potentially use DI in a ViewModelLocator</li>
                </ul>
                <h2>Data Binding Support for MVVM</h2>
                <p>
                    Data binding is the key feature that differentiates MVVM from other UI separation patterns. For data
                    binding to work you need to have a View. You also need another object that the bindings will point
                    to. In MVVM the main thing the elements in your View bind to are properties in your ViewModel. The
                    order that the View and ViewModel are constructed depend on the situation in the application.
                </p>
                <p>
                    Because of the way a DataContext works in XAML the DataContext set at the root element also becomes
                    the DataContext for every child element (unless it explicitly sets the DataContext property to
                    something else or it is being rendered out as part of an Items control which sets the DataContext to
                    the item).
                </p>
                <h2>Demo: Data Binding for MVVM Data Flows</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-DataBinding-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-DataBinding-End</p>
                <p>
                    In this demo we will review how data binding works and show how it supports the ViewModel and Model
                    Types. Open the CustomerListView. Replace the previous DataGrid (which by default has
                    AutoGenerateColumns set to true) with one that specifies more explicit column definitions:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-015.png"/>
                    <figcaption>Fig03-015</figcaption>
                </figure>
                <p>
                    The DataGrid is still bound to the Customers collection exposed by our ViewModel but we have
                    individual column definitions which have their own Bindings.
                </p>
                <h2>ViewModel-First Construction with DataTemplates</h2>
                <p>
                    ViewModel-First leverages the capabilities of implicit Data Templates in WPF. Implicit data
                    templates can automatically select an appropriate template from the current Resource Dictionary for
                    an element that is using data binding. They do this based on the type of the data object that is
                    being rendered by the data binding.
                </p>
                <p>
                    You first have some element that is binding to a Data Object. When the property that is being bound
                    on the control drives the rendered content on that control (such as ContentControl Content property
                    or an ItemsControl ItemSource property) the control will look at the object produced by the binding.
                    If it’s a UI element the control will just render the element as content based on its layout scheme
                    for children.
                </p>
                <p>
                    If the object produced by the binding is not a UI element (such as a ViewModel instance) the Control
                    will go and look at the current Resource Dictionary that is in scope for the element and see if it
                    can locate a Data Template that is mapped to the type of the object that is being produced by the
                    binding. If it finds a match it creates an instance of the root element found in that data template
                    which implicitly causes the construction of any Child elements. Then it renders that element as the
                    Child content after having set the DataContext property of the root element to the Data Object
                    instance that kicked of the whole process. Which in this example means the DataContext of the Child
                    View is set to its ViewModel.
                </p>
                <h2>Demo: Explicit and Implicit DataTemplates</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-DataTemplates-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-DataTemplates-End</p>
                <p>Now let’s look at how you do ViewModel-First leveraging data templates (specifically implicit data
                    templates).
                </p>
                <p>
                    The first step is to use Data Templates in a basic Data Binding scenario. Split the DataGrid into
                    two rows of equal height. Put a ListBox in the second row with a Binding to the Customers collection
                    (the same one the DataGrid is bound to).
                </p>
                <p>
                    If you run now each Customer has a display of Zza.Data.Customer because the object is not a UI
                    element so the Framework is just calling the object’s ToString() method. We can fix this with
                    implicit templates by defining a data template. Add a Resources section to the root containing a
                    DataTemplate called CustomerTemplate:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-016.png"/>
                    <figcaption>Fig03-016</figcaption>
                </figure>
                <p>To use the template, go back to the ListBox and specify an ItemTemplate:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-017.png"/>
                    <figcaption>Fig03-017</figcaption>
                </figure>
                <p>Now when we run we see the presentation setup in the template:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-018.png"/>
                    <figcaption>Fig03-018</figcaption>
                </figure>
                <p>
                    To make this an implicit template we remove the ItemTemplate from the ListBox, go back to the
                    Template definition and instead of a key we would give it a DataType:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-019.png"/>
                    <figcaption>Fig03-019</figcaption>
                </figure>
                <p>Don’t forget to add a namespace reference for Zza.Data:</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-020.png"/>
                    <figcaption>Fig03-020</figcaption>
                </figure>
                <h2>Demo: Implicit DataTemplates for ViewModel-First MVVM Hook-up</h2>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-DataTemplates-Start</p>
                <p>Dropbox\DevelopmentTutorials\WPFMVVMInDepth\3WPFMVVMInDepth\MVVMHookupDemo-DataTemplates-End</p>
                <p>Now we want to use DataTemplates to wire up our View and ViewModel.</p>
                <p>Firstly, add a MainWindowViewModel.</p>
                <p>
                    Add a CurrentViewModel property to this class. For demo purposes statically wire this up to an
                    instance of the CustomerListViewModel. So we are exposing that child ViewModel now as something that
                    can be data bound to from elements within the MainWindow.
                </p>
                <p>
                    The next step is to wire this up as the ViewModel for the MainWindow. We could use a
                    ViewModelLocator for this step but for this demo we will wire it statically in the XAML:
                </p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-021.png"/>
                    <figcaption>Fig03-021</figcaption>
                </figure>
                <p>Next add a DataTemplate to the XAML Window.Resources to specify a Layout.</p>
                <figure>
                    <img src="app/wpf/images/wpfmvvmindepth/Fig03-022.png"/>
                    <figcaption>Fig03-022</figcaption>
                </figure>
                <p>
                    The above DataTemplate basically says if you encounter a DataType of CustomerListViewModel (which is
                    what CurrentViewModel is set to in the MainWindowViewModel) use the CustomerListView as a Layout
                    template.
                </p>
                <p>Make sure to specify the x:Type mark-up extension otherwise the DataTemplate will just silently fail.
                </p>
                <h2>No One’s on First</h2>
                <p>The last scenario to consider is a case where the View doesn’t construct the ViewModel or vice a
                    versa.
                </p>
                <p>
                    Sometimes a separate chunk of code that simply constructs an instance of each and then sets the
                    DataContext of the View to the ViewModel. An example of this would be a Client Service that manages
                    pop up dialogs to be presented to the user. When a given popup is requested by a Command (say a
                    tools/options dialog) the code in the client service could do the construction of each, wire them
                    together and place them into a popup window and show it.
                </p>
                <p>Most of the time you will be doing ViewModel-First or View-First but you don’t always have to take
                    that approach.
                </p>
                <h2>Summary</h2>
                <p>We showed a number of ways to hook-up Views and ViewModels:</p>
                <ul>
                    <li>View-First Construction via XAML</li>
                    <li>View-First Construction via code behind</li>
                    <li>Using a ViewModelLocator</li>
                </ul>
                <p>Data binding forms the communication pathways between the View and ViewModel</p>
                <p>DataTemplates allow dynamic selection and hook-up of ViewModels for View.</p>
            </div>
        </div>
    </div>
</div>
